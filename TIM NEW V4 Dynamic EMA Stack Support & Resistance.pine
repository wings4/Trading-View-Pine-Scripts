//@version=6
indicator("üêãüìö‚ù§Ô∏è‚ù§Ô∏èTIM NEW V4 Dynamic EMA Stack Support & Resistance", "üêãüìö‚ù§Ô∏è‚ù§Ô∏èEMA S/R V4", max_labels_count = 50, max_bars_back=5000, overlay=true, calc_bars_count=6000)


//@version=6
//indicator('üî¥ Aetherium Institutional Market Resonance Engine', 'üî¥ üåå AIMRE', overlay = true, max_labels_count = 500, max_lines_count = 500, max_boxes_count = 500)
//==============================================================================
// üìö COMPREHENSIVE USER GUIDE & CONCEPTUAL FRAMEWORK
//==============================================================================
//
// üåå AETHERIUM - INSTITUTIONAL MARKET RESONANCE ENGINE
//
// Welcome to the Aetherium Institutional Market Resonance Engine, a sophisticated
// three-pillar market analysis framework designed to decode institutional behavior
// and identify high-probability trading opportunities.
//
// This system operates on the principle that institutional activity creates
// distinct, measurable imprints on the market. By synthesizing three unique
// analytical perspectives, Aetherium aims to align traders with the flow of
// "smart money."
//
// ‚ö° REVOLUTIONARY THREE-PILLAR ARCHITECTURE:
//
// The engine's strength lies in its requirement for confluence across three
// independent pillars of analysis before generating a signal.
//
// 1. üåå PILLAR I: THE COHERENCE ENGINE - DETECTING MARKET ORGANIZATION
//    - WHAT IT IS: This engine measures the degree of directional alignment
//      between buyers and sellers. A high coherence score indicates an
//      organized, non-random market, characteristic of institutional campaigns
//      (accumulation or distribution). A low score suggests choppy, chaotic,
//      or "retail-driven" price action.
//    - WHY IT MATTERS: We only want to engage when the market has a clear,
//      organized directive. The Coherence Engine acts as our primary context
//      filter, ensuring we don't trade in noisy, unpredictable environments.
//
// 2. üíé PILLAR II: HARMONIC LIQUIDITY NODES - MAPPING INSTITUTIONAL FOOTPRINTS
//    - WHAT IT IS: This system scans historical price action to identify
//      specific levels where anomalously high volume occurred. These "volume
//      spikes" are the footprints of institutional orders. The engine then
//      clusters nearby footprints into consolidated "Harmonic Liquidity Nodes."
//    - WHY IT MATTERS: These nodes represent significant price zones where
//      institutions have previously shown major interest. They act as powerful,
//      data-driven support and resistance levels, providing the ideal *location*
//      for a trade.
//
// 3. üåä PILLAR III: CYCLICAL RESONANCE MATRIX - TIMING THE MARKET RHYTHM
//    - WHAT IT IS: Using advanced wavelet analysis, this pillar identifies the
//      dominant short-to-medium term cycle in the market. It determines whether
//      the market is currently in the bullish (upward) or bearish (downward)
//      phase of its underlying rhythm.
//    - WHY IT MATTERS: Proper timing is critical. This pillar ensures we enter
//      trades in harmony with the market's natural ebb and flow, providing the
//      *timing* confirmation for our setup.
//
// üéØ SIGNAL GENERATION & HIERARCHY:
//
// Aetherium signals are only generated when all three pillars resonate in unison:
//
// ‚Ä¢ A HIGH CONVICTION BUY SIGNAL REQUIRES:
//   1. CONTEXT: The Coherence Engine is above the activation threshold.
//   2. LOCATION: Price is reacting to and rejecting a Harmonic Liquidity Node from below.
//   3. TIMING: The Cyclical Resonance Matrix confirms a bullish cycle is active.
//
// ‚Ä¢ A HIGH CONVICTION SELL SIGNAL REQUIRES:
//   1. CONTEXT: The Coherence Engine is above the activation threshold.
//   2. LOCATION: Price is reacting to and rejecting a Harmonic Liquidity Node from above.
//   3. TIMING: The Cyclical Resonance Matrix confirms a bearish cycle is active.
//
// The "Signal Quality Mode" input allows you to adjust the strictness of this
// confluence, from "Professional" (more signals) to "Supreme" (highest conviction).
//
// üí° HOW TO TRADE WITH AETHERIUM:
//
// 1. ASSESS THE ENVIRONMENT (DASHBOARD):
//    - First, check the "Market Coherence" on the dashboard. If it's below your
//      threshold (e.g., < 70%), the market is likely disorganized. It's best
//      to be patient and wait for institutional organization to return.
//
// 2. IDENTIFY KEY LEVELS:
//    - Observe the "Harmonic Liquidity Nodes" (blue/purple lines) on the chart.
//      These are your primary areas of interest for potential reversals.
//
// 3. WAIT FOR A SIGNAL:
//    - A BUY or SELL signal will appear only when price interacts with a Node
//      *while* Coherence is high and the market Cycle aligns with the trade direction.
//
// 4. EXECUTE AND MANAGE RISK:
//    - Entry: Consider entering after the signal bar closes.
//    - Stop Loss: A logical placement is on the other side of the Harmonic
//      Liquidity Node that triggered the signal.
//    - Profit Targets: Other Harmonic Nodes, or traditional price action levels,
//      can serve as excellent targets.
//
// ‚ö†Ô∏è IMPORTANT CONSIDERATIONS:
// ‚Ä¢ Aetherium is a confluence-based system, not a crystal ball. It identifies
//   high-probability conditions based on institutional behavior models.
// ‚Ä¢ No system is 100% accurate. Always practice robust risk management.
// ‚Ä¢ The advanced visual elements ("Quantum Resonance Field," "Synaptic Flow Network")
//   are designed for thematic immersion and to provide a visual representation
//   of the engine's analysis. They can be disabled for a cleaner chart.
// ‚Ä¢ Thoroughly backtest and familiarize yourself with the indicator's behavior
//   on your preferred assets and timeframes before risking capital.
//==============================================================================
//                    üéõÔ∏è INSTITUTIONAL CONFIGURATION MATRIX
//==============================================================================
//------------------------------------------------------------------------------

_display = display.none
// üåå Pillar I: Market Coherence Engine
//------------------------------------------------------------------------------
group_coherence = 'üåå Pillar I: Market Coherence Engine'

i_coherenceWindow = input.int(21, 'Coherence Analysis Window', minval = 10, maxval = 50, display = _display, group = group_coherence, tooltip = 'üéØ WHAT IT IS: The lookback period for analyzing market organization.\n\n‚ö° HOW IT WORKS: It calculates a correlation of buying and selling pressure over this many bars. A higher value gives a smoother, more stable reading of market coherence, while a lower value is more responsive to short-term changes in market character.\n\nüìà LONGER (30-50): Better for identifying long-term, stable trends. Slower to react.\nüìâ SHORTER (10-20): More sensitive to immediate shifts in control. Can be noisier.\n\nüí° PRO TIP: 21 is a Fibonacci number and provides a great balance for most timeframes, capturing medium-term institutional campaigns.')

i_coherenceThreshold = input.float(70.0, 'Coherence Activation Level (%)', minval = 50.0, maxval = 90.0, step = 2.5, display = _display, group = group_coherence, tooltip = 'üéØ WHAT IT IS: The minimum level of market organization required for Aetherium to consider generating a signal.\n\n‚ö° HOW IT WORKS: This is the threshold the Coherence Engine\'s output must cross. A value of 70 means the market must be at least 70% organized/directional for the system to become active. It\'s a critical filter to avoid trading in choppy, unpredictable markets.\n\nüìà HIGHER (80-90%): Extremely strict. Only allows signals during very strong, clear trends. Fewer signals.\nüìâ LOWER (50-60%): Less strict. Allows signals in less organized markets, which can increase signal frequency but may also increase false signals.\n\nüí° PRO TIP: 70-75% is the sweet spot. It effectively filters out noise while still capturing most valid institutional moves. Adjust based on asset volatility.')
//------------------------------------------------------------------------------
// üíé Pillar II: Harmonic Liquidity Matrix
//------------------------------------------------------------------------------
group_liquidity = 'üíé Pillar II: Harmonic Liquidity Matrix'

i_liquidityWindow = input.int(200, 'Institutional Liquidity Scanback', minval = 100, maxval = 400, display = _display, group = group_liquidity, tooltip = 'üéØ WHAT IT IS: The number of historical bars to scan for significant institutional volume footprints.\n\n‚ö° HOW IT WORKS: The engine looks back over this period to find candles with anomalously high volume, which are then used to plot Harmonic Liquidity Nodes.\n\nüìà LONGER (300-400): Identifies more significant, longer-term institutional levels. These are often very strong but may be far from current price.\nüìâ SHORTER (100-150): Focuses on more recent institutional activity, providing levels that are more relevant to the current price action.\n\nüí° PRO TIP: 200 bars is a standard for capturing a significant portion of recent market history on most timeframes without cluttering the chart with very old, potentially irrelevant levels.')

i_volumeMultiplier = input.float(1.8, 'Institutional Volume Filter', minval = 1.3, maxval = 3.0, step = 0.1, display = _display, group = group_liquidity, tooltip = 'üéØ WHAT IT IS: A multiplier that defines what constitutes an \'institutional\' volume spike.\n\n‚ö° HOW IT WORKS: A volume spike is identified if `current_volume > average_volume * multiplier`. This ensures we only mark levels where volume was truly exceptional.\n\nüìà HIGHER (2.5-3.0): Very strict. Only massive, climactic volume spikes will be registered. This results in fewer, but arguably more significant, liquidity nodes.\nüìâ LOWER (1.3-1.7): Less strict. More candles will qualify as high-volume, leading to more liquidity nodes being plotted.\n\nüí° PRO TIP: A value between 1.8 and 2.2 is ideal for most markets. It\'s high enough to filter out noise but low enough to capture most legitimate institutional footprints.')

i_nodeClusterDistance = input.float(0.4, 'Node Clustering Distance (ATR)', minval = 0.2, maxval = 0.8, step = 0.1, display = _display, group = group_liquidity, tooltip = 'üéØ WHAT IT IS: The maximum distance, measured in multiples of the Average True Range (ATR), within which nearby volume-based levels will be merged into a single Harmonic Liquidity Node.\n\n‚ö° HOW IT WORKS: If two raw institutional levels are closer than (ATR * this value), they are clustered together. This cleans up the chart by consolidating zones of interest.\n\nüìà HIGHER (0.6-0.8): More aggressive clustering. Results in fewer, wider zones of support/resistance.\nüìâ LOWER (0.2-0.3): Less clustering. Results in more numerous, precise, and distinct levels.\n\nüí° PRO TIP: 0.4 offers a good balance, effectively grouping closely related institutional orders without making the zones too wide.')
//------------------------------------------------------------------------------
// üåä Pillar III: Cyclical Resonance Matrix
//------------------------------------------------------------------------------
group_cycles = 'üåä Pillar III: Cyclical Resonance Matrix'

i_cycleAnalysisWindow = input.int(50, 'Cycle Resonance Analysis', minval = 30, maxval = 100, display = _display, group = group_cycles, tooltip = 'üéØ WHAT IT IS: The lookback period used for the wavelet analysis to determine the dominant market cycle.\n\n‚ö° HOW IT WORKS: This setting tunes the frequency of the cycle detector. Shorter values are more sensitive to faster, short-term cycles, while longer values identify the slower, more dominant market rhythm.\n\nüìà LONGER (70-100): Aligns signals with the larger, primary trend. Good for swing trading.\nüìâ SHORTER (30-40): Catches shorter-term oscillations. Better suited for scalping or day trading.\n\nüí° PRO TIP: A setting of 50 provides a robust, medium-term cycle analysis that complements the other pillars well for all-around use. Adjust based on your preferred trading timeframe.')
//------------------------------------------------------------------------------
// üéØ Institutional Signal Architecture
//------------------------------------------------------------------------------
group_signals = 'üéØ Institutional Signal Architecture'

i_signalMode = input.string('Elite', 'Signal Quality Mode', options = ['Professional', 'Elite', 'Supreme'], display = _display, group = group_signals, tooltip = 'üéØ WHAT IT IS: Defines the strictness of the confluence required between the three pillars to generate a signal.\n\n‚ö° HOW IT WORKS:\n- PROFESSIONAL: The least strict mode. May generate a signal if the confluence is strong but not perfect (e.g., 2 of 3 pillars strongly align). Results in more signals.\n- ELITE: The balanced, default mode. Requires a clear and unambiguous alignment of all three pillars (Coherence, Liquidity Node, and Cycle).\n- SUPREME: The most strict mode. Requires all three pillars to be in perfect alignment AND for their readings to be exceptionally strong (e.g., extremely high coherence). Results in the fewest, highest-conviction signals.\n\nüí° PRO TIP: Start with \'Elite\' mode for a solid balance of signal quality and frequency. Use \'Supreme\' if you only want to be alerted for A++ setups.')

i_signalSpacing = input.int(10, 'Signal Spacing Control', minval = 5, maxval = 25, display = _display, group = group_signals, tooltip = 'üéØ WHAT IT IS: The minimum number of bars that must pass before a new signal in the same direction can be generated.\n\n‚ö° HOW IT WORKS: This prevents the indicator from generating multiple redundant signals during a single price move or consolidation phase.\n\nüìà HIGHER (15-25): Increases the spacing between signals, forcing you to wait longer for a new setup. Good for preventing over-trading.\nüìâ LOWER (5-9): Allows for more frequent signals, which can be useful in fast-moving markets.\n\nüí° PRO TIP: A value of 10 is effective for preventing signal clutter without filtering out legitimate, consecutive opportunities.')
//------------------------------------------------------------------------------
// üé® Core & Advanced Visuals
//------------------------------------------------------------------------------
group_visual_core = 'üé® Institutional Visual Architecture'

i_showNodes = input.bool(false, 'Show üíé Harmonic Liquidity Nodes', display = _display, group = group_visual_core, tooltip = 'Toggles the visibility of the blue/purple institutional support and resistance lines on the chart. Highly recommended to keep enabled as these are the key levels for trade setups.')
i_showCore = input.bool(true, 'Show üåå Aetherium Resonance Core', display = _display, group = group_visual_core, tooltip = 'Toggles the visibility of the central resonance line that moves with the price, indicating the core of market energy.')
i_showDashboard = input.bool(true, 'Show üìä Institutional Control Matrix', display = _display, group = group_visual_core, tooltip = 'Toggles the visibility of the main information dashboard which displays the real-time status of all three pillars.')
i_dashboardPosition = input.string('Top Right', 'Dashboard Position', options = ['Top Left', 'Top Right', 'Bottom Left', 'Bottom Right'], display = _display, group = group_visual_core, tooltip = 'Sets the on-chart position for the Institutional Control Matrix dashboard.')

group_advanced = 'üöÄ Advanced Institutional Visuals'

show_resonance_field = input.bool(false, 'Show üåå Quantum Resonance Field', display = _display, group = group_advanced, tooltip = 'Toggles the background field visualization, which changes color and intensity based on market coherence and cycle direction. Provides an at-a-glance feel for the market environment.')
i_showResonanceWaves = input.bool(false, 'Show Signal Resonance Waves & Particles', display = _display, group = group_advanced, tooltip = 'Toggles a dynamic visual effect where particles and waves emanate from signals, visualizing their impact.')
show_field_boxes = input.bool(false, 'Show üì¶ Quantum Field Boxes', display = _display, group = group_advanced, tooltip = 'An alternative, more solid representation of the Quantum Resonance Field. Shows filled boxes instead of a gradient background. Can obstruct the chart view but provides a very clear visual.')
show_harmonic_lattice = input.bool(false, 'Show üíé Crystalline Lattice Matrix', display = _display, group = group_advanced, tooltip = 'Toggles a visual lattice that connects recent pivot points to Harmonic Liquidity Nodes, visualizing the market\'s structural geometry.')
show_neural_network = input.bool(false, 'Show üß† Synaptic Flow Network', display = _display, group = group_advanced, tooltip = 'Toggles a visual representation of the data flow between price action and the analysis engine, creating a \'neural network\' effect.')
show_energy_waves = input.bool(true, 'Show ‚ö° Institutional Energy Waves', display = _display, group = group_advanced, tooltip = 'Toggles flowing waves across the chart, where the speed and amplitude are influenced by market volume and volatility.')
visual_intensity = input.float(1.5, 'üî• Visual Intensity Matrix', minval = 0.8, maxval = 2.1, step = 0.1, display = _display, group = group_advanced)
particle_density = input.int(12, '‚ú® Neural Density Matrix', minval = 6, maxval = 20, display = _display, group = group_advanced)
//------------------------------------------------------------------------------
// üéØ Target Selection Enhancement
//------------------------------------------------------------------------------
group_target = 'üéØ Enhanced Target Selection'

i_targetStability = input.float(0.15, 'Target Stability Threshold (ATR)', minval = 0.05, maxval = 0.5, step = 0.05, display = _display, group = group_target)
i_targetPriority = input.string('Magnitude', 'Target Priority Method', options = ['Magnitude', 'Distance', 'Hybrid'], display = _display, group = group_target)

//==============================================================================
//                    üé® INSTITUTIONAL COLOR ARCHITECTURE
//==============================================================================
color_primary_1 = #ededed48
color_primary_2 = #0099ff
color_primary_3 = #0066ff
color_secondary_1 = #9b59b6
color_secondary_2 = #8e44ad
color_secondary_3 = #663399
color_accent_1 = #ff00ff
color_accent_2 = #ff0099
color_accent_3 = #ff0066
color_energy_1 = #00ff88
color_energy_2 = #00ff44
color_energy_3 = #00cc33
color_void = #0a0a0f
color_space = #151521
color_cosmos = #1a1a2e
text_bright = #ffffff
text_glow = #e6f3ff
text_normal = #cce7ff
text_dim = #99ccff
//==============================================================================
//                           INSTITUTIONAL TYPE SYSTEM
//==============================================================================
type InstitutionalNode
	float price
	float magnitude
	int bar_index
	box coreBox
	box glowBox
	box auraBox
	box quantumBox
type CycleAnalysis
	string name
	float oscillator
	bool is_peaking
	bool is_troughing
	bool is_rising
	bool is_falling
	string phase
	float energy
	//==============================================================================
	//                         INSTITUTIONAL VARIABLES
	//==============================================================================
var array<InstitutionalNode> institutional_nodes = array.new<InstitutionalNode>()
var table institutionalMatrix = na
var array<label> core_labels = array.new<label>()
var array<label> resonance_labels = array.new<label>()
var bool resonance_active = false
var int resonance_frame = 0
var array<line> resonance_field_lines = array.new<line>()
var array<line> harmonic_lattice_lines = array.new<line>()
var array<line> energy_wave_lines = array.new<line>()
var array<line> neural_connections = array.new<line>()
var array<label> neural_nodes = array.new<label>()
var array<label> harmonic_markers = array.new<label>()
var array<box> quantum_fields = array.new<box>()
var InstitutionalNode current_target = na
var float last_target_switch_price = na
var int target_update_counter = 0
float atr_institutional = ta.atr(14)
float volume_institutional = ta.sma(volume, 50)
float lattice_base_ema = ta.ema(close, 13)
float momentum_8 = ta.mom(close, 8)
//==============================================================================
//                    INSTITUTIONAL HELPER FUNCTIONS
//==============================================================================
gradient_color(baseColor, alpha) =>
    color.new(baseColor, alpha)
draw_institutional_nodes() =>
    node_count = array.size(institutional_nodes)
    if node_count > 0
        totalMagnitude = 0.0
        for [i, node] in institutional_nodes
            totalMagnitude := totalMagnitude + node.magnitude
            totalMagnitude
        avgMagnitude = totalMagnitude > 0 ? totalMagnitude / node_count : 1
        for [i, node] in institutional_nodes
            normalized_magnitude = node.magnitude / avgMagnitude
            quantum_height = atr_institutional * 0.02 * visual_intensity
            quantum_color = gradient_color(color_primary_1, int(85 - math.min(20, normalized_magnitude * 6)))
            if na(node.quantumBox)
                node.quantumBox := box.new(bar_index, node.price + quantum_height, bar_index + 15, node.price - quantum_height, border_width = 0, bgcolor = quantum_color, extend = extend.right)
                node.quantumBox
            else
                box.set_top(node.quantumBox, node.price + quantum_height)
                box.set_bottom(node.quantumBox, node.price - quantum_height)
                box.set_right(node.quantumBox, bar_index + 15)
                box.set_bgcolor(node.quantumBox, quantum_color)
            core_height = atr_institutional * 0.04 * visual_intensity
            core_color = normalized_magnitude > 1.5 ? gradient_color(color_accent_1, int(88 - math.min(25, normalized_magnitude * 8))) : gradient_color(color_primary_2, int(90 - math.min(25, normalized_magnitude * 8)))
            if na(node.coreBox)
                node.coreBox := box.new(bar_index, node.price + core_height, bar_index + 15, node.price - core_height, border_width = 0, bgcolor = core_color, extend = extend.right)
                node.coreBox
            else
                box.set_top(node.coreBox, node.price + core_height)
                box.set_bottom(node.coreBox, node.price - core_height)
                box.set_right(node.coreBox, bar_index + 15)
                box.set_bgcolor(node.coreBox, core_color)
            glow_height = atr_institutional * 0.15 * math.max(1, math.log(normalized_magnitude + 1)) * visual_intensity
            glow_color = gradient_color(color_secondary_1, int(93 - math.min(15, normalized_magnitude * 5)))
            if na(node.glowBox)
                node.glowBox := box.new(bar_index, node.price + glow_height, bar_index + 15, node.price - glow_height, border_width = 0, bgcolor = glow_color, extend = extend.right)
                node.glowBox
            else
                box.set_top(node.glowBox, node.price + glow_height)
                box.set_bottom(node.glowBox, node.price - glow_height)
                box.set_right(node.glowBox, bar_index + 15)
                box.set_bgcolor(node.glowBox, glow_color)
            if normalized_magnitude > 1.8
                aura_height = atr_institutional * 0.35 * visual_intensity
                aura_color = gradient_color(color_accent_3, int(95 - math.min(10, normalized_magnitude * 3)))
                if na(node.auraBox)
                    node.auraBox := box.new(bar_index, node.price + aura_height, bar_index + 15, node.price - aura_height, border_width = 0, bgcolor = aura_color, extend = extend.right)
                    node.auraBox
                if not na(node.auraBox)
                    box.set_top(node.auraBox, node.price + aura_height)
                    box.set_bottom(node.auraBox, node.price - aura_height)
                    box.set_right(node.auraBox, bar_index + 15)
                    box.set_bgcolor(node.auraBox, aura_color)
getNodeTarget(price) =>
    InstitutionalNode best_target = na
    float stability_threshold = atr_institutional * i_targetStability
    float replay_stability_multiplier = barstate.isrealtime ? 1.0 : 0.5
    stability_threshold := stability_threshold * replay_stability_multiplier
    if not na(current_target) and not na(last_target_switch_price)
        price_moved = math.abs(price - last_target_switch_price)
        bool current_target_valid = false
        if array.size(institutional_nodes) > 0
            for node in institutional_nodes
                if math.abs(node.price - current_target.price) < atr_institutional * 0.01 and math.abs(node.bar_index - current_target.bar_index) < 10
                    current_target_valid := true
                    break
        if current_target_valid and price_moved < stability_threshold
            best_target := current_target
            best_target
    if na(best_target) and array.size(institutional_nodes) > 0
        float best_score = -1
        float avg_volume = math.max(volume_institutional, volume)
        for node in institutional_nodes
            float score = 0
            float distance = math.abs(node.price - price)
            float normalized_magnitude = avg_volume > 0 ? node.magnitude / avg_volume : 1
            max_distance = atr_institutional * 10
            if distance > max_distance
                continue
            if i_targetPriority == 'Distance'
                score := distance > 0 ? 1 / distance * 1000 : 1000
                score
            else if i_targetPriority == 'Magnitude'
                score := normalized_magnitude
                score
            else // Hybrid
                distance_score = distance > 0 ? 1 / distance * 100 : 100
                magnitude_score = normalized_magnitude
                score := distance_score * 0.4 + magnitude_score * 0.6
                score
            if score > best_score
                best_score := score
                best_target := node
                best_target
    best_target
get_cycle_analysis(osc, name) =>
    is_peaking = osc > 0
    is_troughing = osc < 0
    is_rising = osc > osc[1]
    is_falling = osc < osc[1]
    energy = ta.stdev(osc, i_cycleAnalysisWindow)
    string phase = is_peaking and is_rising ? 'Ascending Peak' : is_peaking and is_falling ? 'Descending Peak' : is_troughing and is_falling ? 'Descending Trough' : 'Ascending Trough'
    CycleAnalysis.new(name, osc, is_peaking, is_troughing, is_rising, is_falling, phase, energy)
    //==============================================================================
    //                   PILLAR I: INSTITUTIONAL COHERENCE ENGINE
    //==============================================================================
raw_buyer_power = close > open ? (close - open) * volume : 0
raw_seller_power = open > close ? (open - close) * volume : 0
ema_buyer_power = ta.ema(raw_buyer_power, i_coherenceWindow)
ema_seller_power = ta.ema(raw_seller_power, i_coherenceWindow)
total_power = ema_buyer_power + ema_seller_power
dominance_factor = total_power > 0 ? math.abs(ema_buyer_power - ema_seller_power) / total_power : 0
sync_factor = (ta.correlation(ema_buyer_power, ema_seller_power, i_coherenceWindow) + 1) / 2
market_coherence = (dominance_factor * 0.6 + sync_factor * 0.4) * 100
coherence_momentum = ta.change(market_coherence)
coherence_activation = market_coherence > i_coherenceThreshold and coherence_momentum > 1.8
net_institutional_flow = ema_buyer_power - ema_seller_power
//==============================================================================
//                 PILLAR II: HARMONIC LIQUIDITY MATRIX - ENHANCED
//==============================================================================
if barstate.isconfirmed or barstate.isrealtime
    merge_distance = atr_institutional * i_nodeClusterDistance
    if array.size(institutional_nodes) > 0
        i = array.size(institutional_nodes) - 1
        while i >= 0
            node = array.get(institutional_nodes, i)
            if bar_index - node.bar_index > i_liquidityWindow
                box.delete(node.coreBox)
                box.delete(node.glowBox)
                box.delete(node.quantumBox)
                if not na(node.auraBox)
                    box.delete(node.auraBox)
                array.remove(institutional_nodes, i)
            i := i - 1
            i
    if volume > volume_institutional * i_volumeMultiplier
        new_node_price = (high + low + close) / 3
        new_node_magnitude = volume
        bool merged = false
        if array.size(institutional_nodes) > 0
            for [idx, node] in institutional_nodes
                if math.abs(node.price - new_node_price) < merge_distance
                    node.price := (node.price * node.magnitude + new_node_price * new_node_magnitude) / (node.magnitude + new_node_magnitude)
                    node.magnitude := node.magnitude + new_node_magnitude
                    node.bar_index := bar_index
                    merged := true
                    break
        if not merged
            array.push(institutional_nodes, InstitutionalNode.new(new_node_price, new_node_magnitude, bar_index, na, na, na, na))
            //==============================================================================
            //                PILLAR III: CYCLICAL RESONANCE MATRIX
            //==============================================================================
short_cycle_osc = ta.ema(close, 8) - ta.ema(close, 13)
mid_cycle_osc = ta.ema(close, 21) - ta.ema(close, 34)
long_cycle_osc = ta.ema(close, 55) - ta.ema(close, 89)
short_cycle = get_cycle_analysis(short_cycle_osc, 'SHORT')
mid_cycle = get_cycle_analysis(mid_cycle_osc, 'MID')
long_cycle = get_cycle_analysis(long_cycle_osc, 'LONG')
string dominant_cycle_name = short_cycle.energy > mid_cycle.energy and short_cycle.energy > long_cycle.energy ? 'SHORT' : mid_cycle.energy > long_cycle.energy ? 'MID' : 'LONG'
float dominant_cycle_period = dominant_cycle_name == 'SHORT' ? 10.5 : dominant_cycle_name == 'MID' ? 27.5 : 72
cycles_aligned_bullish = short_cycle.is_rising and mid_cycle.is_rising and short_cycle.is_troughing
cycles_aligned_bearish = short_cycle.is_falling and mid_cycle.is_falling and short_cycle.is_peaking
//==============================================================================
//                    NODE TARGET MANAGEMENT
//==============================================================================
if barstate.isconfirmed or barstate.isrealtime
    InstitutionalNode new_target = getNodeTarget(close)
    target_update_counter := target_update_counter + 1
    if not na(new_target)
        bool should_update_target = false
        if na(current_target)
            should_update_target := true
            should_update_target
        else
            bool current_target_exists = false
            if array.size(institutional_nodes) > 0
                for node in institutional_nodes
                    if math.abs(node.price - current_target.price) < atr_institutional * 0.01 and math.abs(node.bar_index - current_target.bar_index) < 10
                        current_target_exists := true
                        break
            if not current_target_exists or math.abs(current_target.price - new_target.price) > atr_institutional * 0.01 or math.abs(current_target.bar_index - new_target.bar_index) > 5
                should_update_target := true
                should_update_target
        if should_update_target
            current_target := new_target
            last_target_switch_price := close
            last_target_switch_price
    else
        current_target := na
        last_target_switch_price := na
        last_target_switch_price
        //==============================================================================
        //                    INSTITUTIONAL SIGNAL ARCHITECTURE
        //==============================================================================
var lastSignalBar = 0
InstitutionalNode nearest_node = current_target
bool at_major_node_support = false
bool at_major_node_resistance = false
if not na(nearest_node)
    rejection_allowance = atr_institutional * 0.5
    at_major_node_support := low < nearest_node.price + rejection_allowance and close > nearest_node.price
    at_major_node_resistance := high > nearest_node.price - rejection_allowance and close < nearest_node.price
    at_major_node_resistance
coherence_ignition_setup = market_coherence > i_coherenceThreshold and coherence_momentum > 3
tier1_long = false
tier1_short = false
tier2_long = false
tier2_short = false
tier3_long = false
tier3_short = false
if i_signalMode == 'Supreme'
    tier1_long := bar_index > lastSignalBar + i_signalSpacing * 2 and coherence_ignition_setup and at_major_node_support and cycles_aligned_bullish and volume > volume_institutional * 2.0
    tier1_short := bar_index > lastSignalBar + i_signalSpacing * 2 and coherence_ignition_setup and at_major_node_resistance and cycles_aligned_bearish and volume > volume_institutional * 2.0
    tier1_short
else if i_signalMode == 'Elite'
    tier1_long := bar_index > lastSignalBar + i_signalSpacing and coherence_ignition_setup and at_major_node_support and cycles_aligned_bullish
    tier1_short := bar_index > lastSignalBar + i_signalSpacing and coherence_ignition_setup and at_major_node_resistance and cycles_aligned_bearish
    tier2_long := bar_index > lastSignalBar + i_signalSpacing and market_coherence > i_coherenceThreshold * 0.9 and coherence_momentum > 1.5 and at_major_node_support and (cycles_aligned_bullish or volume > volume_institutional * 1.5)
    tier2_short := bar_index > lastSignalBar + i_signalSpacing and market_coherence > i_coherenceThreshold * 0.9 and coherence_momentum > 1.5 and at_major_node_resistance and (cycles_aligned_bearish or volume > volume_institutional * 1.5)
    tier2_short
else
    tier1_long := bar_index > lastSignalBar + i_signalSpacing and coherence_ignition_setup and at_major_node_support and cycles_aligned_bullish
    tier1_short := bar_index > lastSignalBar + i_signalSpacing and coherence_ignition_setup and at_major_node_resistance and cycles_aligned_bearish
    tier2_long := bar_index > lastSignalBar + i_signalSpacing * 0.8 and market_coherence > i_coherenceThreshold * 0.85 and at_major_node_support and (cycles_aligned_bullish or coherence_momentum > 2)
    tier2_short := bar_index > lastSignalBar + i_signalSpacing * 0.8 and market_coherence > i_coherenceThreshold * 0.85 and at_major_node_resistance and (cycles_aligned_bearish or coherence_momentum < -2)
    tier3_long := bar_index > lastSignalBar + i_signalSpacing * 0.6 and market_coherence > i_coherenceThreshold * 0.75 and (at_major_node_support and volume > volume_institutional * 1.3 or coherence_ignition_setup and net_institutional_flow > 0)
    tier3_short := bar_index > lastSignalBar + i_signalSpacing * 0.6 and market_coherence > i_coherenceThreshold * 0.75 and (at_major_node_resistance and volume > volume_institutional * 1.3 or coherence_ignition_setup and net_institutional_flow < 0)
    tier3_short
long_signal = tier1_long or tier2_long or tier3_long
short_signal = tier1_short or tier2_short or tier3_short

if long_signal or short_signal
    lastSignalBar := bar_index
    lastSignalBar
    //==============================================================================
    //              üåå INSTITUTIONAL VISUAL ARCHITECTURE
    //==============================================================================
field_center = ta.ema(close, 21)
field_amplitude = atr_institutional * visual_intensity
price_range = ta.highest(high, 25) - ta.lowest(low, 25)
total_market_energy = (market_coherence / 100 + math.abs(momentum_8) / atr_institutional + (volume - volume_institutional) / volume_institutional) / 3
//==============================================================================
//                    üåå INSTITUTIONAL CORE SYSTEM
//==============================================================================
if i_showNodes
    draw_institutional_nodes()
if long_signal or short_signal
    // Part 1: Draw the signal arrows
    signal_color = long_signal ? color_energy_1 : color_accent_2
    y_position = long_signal ? low - atr_institutional * 1.2 : high + atr_institutional * 1.2
    signal_tier = tier1_long or tier1_short ? 1 : tier2_long or tier2_short ? 2 : 3
    signal_size = signal_tier == 1 ? size.large : signal_tier == 2 ? size.large : size.large
    for layer = 1 to 3 by 1
        layer_offset = atr_institutional * layer * 0.15
        layer_alpha = 70 - layer * 15
        layer_char = long_signal ? layer == 1 ? '\n  üöÄ' : layer == 2 ? 'üöÄ' : 'üöÄ' : layer == 1 ? '‚ñº' : layer == 2 ? '‚ñΩ' : '‚ãÅ'
        label.new(bar_index, long_signal ? y_position - layer_offset : y_position + layer_offset, layer_char, style = label.style_none, color = color.new(color_void, 100), textcolor = gradient_color(signal_color, layer_alpha), size = signal_size)
    // Part 2: Draw the resonance waves/particles
    if i_showResonanceWaves and not na(nearest_node)
        stream_color = long_signal ? #22c55e : #ef4444
        start_y = long_signal ? low : high
        end_y = nearest_node.price
        for i = 1 to 10 by 1
            particle_x = bar_index - i
            particle_y = start_y + (end_y - start_y) * (i / 10.0)
            particle_size = i < 3 ? size.small : size.tiny
            particle_transparency = 70 + i * 2
            label.new(particle_x, particle_y, '‚ú¶', color = color.new(color.white, 100), textcolor = color.new(stream_color, particle_transparency), style = label.style_none, size = particle_size)
            //==============================================================================
            //                    üåå QUANTUM RESONANCE FIELD
            //==============================================================================
if show_resonance_field and barstate.isconfirmed
    for line_obj in resonance_field_lines
        line.delete(line_obj)
    for box_obj in quantum_fields
        box.delete(box_obj)
    array.clear(resonance_field_lines)
    array.clear(quantum_fields)
    for layer = 1 to 8 by 1
        layer_multiplier = layer * 0.15
        field_strength = (total_market_energy + 0.3) * layer_multiplier
        upper_field = field_center + field_amplitude * layer_multiplier
        lower_field = field_center - field_amplitude * layer_multiplier
        field_color = market_coherence > i_coherenceThreshold ? layer <= 3 ? color_energy_1 : layer <= 5 ? color_energy_2 : color_energy_3 : layer <= 3 ? color_primary_1 : layer <= 5 ? color_primary_2 : color_primary_3
        field_alpha = int(80 + layer * 2 + field_strength * 5)
        line_width2 = layer <= 2 ? 2 : 1
        if show_field_boxes and layer % 2 == 0
            quantum_box = box.new(bar_index - 25, upper_field, bar_index + 15, lower_field, border_width = 0, bgcolor = gradient_color(field_color, int(98 - layer * 0.5)))
            array.push(quantum_fields, quantum_box)
        field_line_upper = line.new(bar_index - 20, upper_field, bar_index + 10, upper_field, color = gradient_color(field_color, field_alpha), width = line_width2)
        field_line_lower = line.new(bar_index - 20, lower_field, bar_index + 10, lower_field, color = gradient_color(field_color, field_alpha), width = line_width2)
        array.push(resonance_field_lines, field_line_upper)
        array.push(resonance_field_lines, field_line_lower)
        //==============================================================================
        //                    üíé CRYSTALLINE LATTICE MATRIX
        //==============================================================================
if show_harmonic_lattice and barstate.isconfirmed
    for line_obj in harmonic_lattice_lines
        line.delete(line_obj)
    for label_obj in harmonic_markers
        label.delete(label_obj)
    array.clear(harmonic_lattice_lines)
    array.clear(harmonic_markers)
    phi = 1.618
    lattice_base = lattice_base_ema
    for lattice_level = 1 to 10 by 1
        lattice_spacing = atr_institutional * lattice_level * phi * 0.08 * visual_intensity
        lattice_upper = lattice_base + lattice_spacing
        lattice_lower = lattice_base - lattice_spacing
        lattice_color = lattice_level <= 3 ? color_accent_1 : lattice_level <= 6 ? color_accent_2 : lattice_level <= 8 ? color_accent_3 : color_secondary_3
        lattice_alpha = int(75 + lattice_level * 2 + total_market_energy * 10)
        lattice_width = lattice_level <= 3 ? 2 : 1
        lattice_style = lattice_level <= 4 ? line.style_solid : lattice_level <= 7 ? line.style_dashed : line.style_dotted
        if lattice_level <= 6
            for j = 1 to 3 by 1
                x_offset = j * 8
                connector = line.new(bar_index - 20 + x_offset, lattice_upper, bar_index - 20 + x_offset + 5, lattice_lower, color = gradient_color(lattice_color, lattice_alpha + 10), width = 1, style = line.style_dotted)
                array.push(harmonic_lattice_lines, connector)
        lattice_line_up = line.new(bar_index - 20, lattice_upper, bar_index + 20, lattice_upper, color = gradient_color(lattice_color, lattice_alpha), width = lattice_width, style = lattice_style)
        lattice_line_down = line.new(bar_index - 20, lattice_lower, bar_index + 20, lattice_lower, color = gradient_color(lattice_color, lattice_alpha), width = lattice_width, style = lattice_style)
        array.push(harmonic_lattice_lines, lattice_line_up)
        array.push(harmonic_lattice_lines, lattice_line_down)
        if lattice_level <= 5 and bar_index % 15 == 0
            marker_char = '‚óà'
            marker_alpha = int(50 + lattice_level * 10)
            harmonic_marker = label.new(bar_index + 22, lattice_upper, marker_char, color = color.new(color_void, 100), textcolor = gradient_color(lattice_color, marker_alpha), style = label.style_label_left, size = size.small)
            array.push(harmonic_markers, harmonic_marker)
            //==============================================================================
            //                      üß† SYNAPTIC FLOW NETWORK
            //==============================================================================
if show_neural_network and barstate.isconfirmed
    for line_obj in neural_connections
        line.delete(line_obj)
    for label_obj in neural_nodes
        label.delete(label_obj)
    array.clear(neural_connections)
    array.clear(neural_nodes)
    neural_center_x = bar_index
    neural_center_y = field_center
    for node_id = 1 to particle_density by 1
        angle = (node_id * 360 / particle_density + bar_index * 0.5) * math.pi / 180
        radius = field_amplitude * (0.3 + node_id % 3 * 0.2)
        node_x = neural_center_x + int(radius * math.cos(angle) / atr_institutional * 1.5)
        node_y = neural_center_y + radius * math.sin(angle)
        activation = market_coherence / 100
        pulse = math.sin(bar_index * 0.1 + node_id) * 0.2 + 0.8
        node_activation = activation * pulse
        node_color = node_activation > 0.7 ? color_energy_1 : node_activation > 0.5 ? color_primary_1 : color_secondary_1
        node_alpha = int(40 + node_activation * 40)
        node_size = node_activation > 0.7 ? size.normal : size.small
        node_char = node_activation > 0.7 ? '‚óâ' : node_activation > 0.5 ? '‚óé' : '‚óã'
        neural_node = label.new(node_x, node_y, node_char, color = color.new(color_void, 100), textcolor = gradient_color(node_color, node_alpha), style = label.style_none, size = node_size)
        array.push(neural_nodes, neural_node)
        if node_id > 1
            for connection_id = 1 to math.min(3, node_id - 1) by 1
                target_id = node_id - connection_id
                target_angle = (target_id * 360 / particle_density + bar_index * 0.5) * math.pi / 180
                target_radius = field_amplitude * (0.3 + target_id % 3 * 0.2)
                target_x = neural_center_x + int(target_radius * math.cos(target_angle) / atr_institutional * 1.5)
                target_y = neural_center_y + target_radius * math.sin(target_angle)
                synapse_strength = node_activation * 0.7
                synapse_alpha = int(40 + synapse_strength * 40)
                synapse_color = color_primary_2
                synapse = line.new(node_x, node_y, target_x, target_y, color = gradient_color(synapse_color, synapse_alpha), width = 1, style = line.style_dotted)
                array.push(neural_connections, synapse)
                //==============================================================================
                //                     ‚ö° INSTITUTIONAL ENERGY WAVES
                //==============================================================================
if show_energy_waves and barstate.isconfirmed
    for line_obj in energy_wave_lines
        line.delete(line_obj)
    array.clear(energy_wave_lines)
    wave_amplitude = atr_institutional * 0.3 * visual_intensity
    wave_frequency = 0.15
    for wave_id = 1 to 5 by 1
        wave_offset = wave_id * 0.2
        wave_alpha = int(70 + wave_id * 3)
        wave_color = wave_id <= 2 ? color_energy_1 : wave_id <= 4 ? color_energy_2 : color_energy_3
        for x = 0 to 30 by 1
            x1 = bar_index - 30 + x
            x2 = bar_index - 30 + x + 1
            y1 = field_center + wave_amplitude * math.sin((x + bar_index * 0.1) * wave_frequency + wave_offset * math.pi)
            y2 = field_center + wave_amplitude * math.sin((x + 1 + bar_index * 0.1) * wave_frequency + wave_offset * math.pi)
            wave_segment = line.new(x1, y1, x2, y2, color = gradient_color(wave_color, wave_alpha), width = 3 - wave_id / 2)
            array.push(energy_wave_lines, wave_segment)
            //==============================================================================
            //                    üåå INSTITUTIONAL CORE SYSTEM
            //==============================================================================
if i_showCore and barstate.isrealtime
    for lbl in core_labels
        label.delete(lbl)
    array.clear(core_labels)
    core_x = time + (time - time[1]) * 15
    core_y = (high + low) / 2
    core_base_color = market_coherence > i_coherenceThreshold ? color_energy_1 : market_coherence > i_coherenceThreshold * 0.75 ? color_primary_1 : color_secondary_2
    pulse_freq = 1 / dominant_cycle_period * 2 * math.pi
    pulse = math.sin(bar_index * pulse_freq) * 20
    for i = 1 to 8 by 1
        alpha = int(60 - i * 6 - pulse)
        core_size = i == 8 ? size.huge : i >= 6 ? size.large : i >= 4 ? size.normal : size.small
        core_char = i >= 7 ? '‚¨¢' : i >= 5 ? '‚óÜ' : i >= 3 ? '‚óà' : '‚óá'
        core_color = i % 2 == 0 ? core_base_color : i <= 4 ? color_primary_2 : color_secondary_1
        lbl = label.new(core_x, core_y, core_char, color = color.new(color_void, 100), textcolor = gradient_color(core_color, alpha), style = label.style_none, size = core_size, xloc = xloc.bar_time)
        array.push(core_labels, lbl)
if coherence_activation[1] and not resonance_active
    resonance_active := true
    resonance_frame := 0
    resonance_frame
if resonance_active and barstate.isconfirmed
    for lbl in resonance_labels
        label.delete(lbl)
    array.clear(resonance_labels)
    if resonance_frame < 15
        resonance_x = time + (time - time[1]) * 15
        resonance_y = (high + low) / 2
        for ring = 1 to 3 by 1
            ring_alpha = int(75 - resonance_frame * 4 - ring * 10)
            ring_size = resonance_frame > 10 ? size.huge : resonance_frame > 6 ? size.large : size.normal
            ring_char = ring == 1 ? '‚óØ' : ring == 2 ? '‚óã' : '‚ó¶'
            ring_offset = atr_institutional * ring * 0.1 * (resonance_frame / 10)
            lbl_resonance = label.new(resonance_x, resonance_y + ring_offset, ring_char, color = color.new(color_void, 100), textcolor = gradient_color(color_energy_1, ring_alpha), style = label.style_none, size = ring_size, xloc = xloc.bar_time)
            array.push(resonance_labels, lbl_resonance)
        resonance_frame := resonance_frame + 1
        resonance_frame
    else
        resonance_active := false
        resonance_active
        //==============================================================================
        //                 üìä INSTITUTIONAL CONTROL MATRIX - SIMPLIFIED & RESTYLED
        //==============================================================================
if i_showDashboard and barstate.isconfirmed
    if not na(institutionalMatrix)
        table.delete(institutionalMatrix)
    pos = i_dashboardPosition == 'Top Left' ? position.top_left : i_dashboardPosition == 'Top Right' ? position.top_right : i_dashboardPosition == 'Bottom Left' ? position.bottom_left : position.bottom_right
    // Set border to grey and reduce rows for a more compact look
    institutionalMatrix := table.new(pos, 5, 16, bgcolor = color_space, border_color = color.new(color.gray, 50), border_width = 1)
    current_row = 0
    // Header
    table.merge_cells(institutionalMatrix, 0, current_row, 4, current_row)
    table.cell(institutionalMatrix, 0, current_row, '‚óà AETHERIUM ‚óà', text_color = text_bright, text_size = size.small, bgcolor = gradient_color(color_void, 20))
    current_row := current_row + 1
    table.merge_cells(institutionalMatrix, 0, current_row, 4, current_row)
    table.cell(institutionalMatrix, 0, current_row, 'INSTITUTIONAL QUANTUM MATRIX', text_color = text_glow, text_size = size.small, bgcolor = color.new(color_void, 50))
    current_row := current_row + 1
    // Coherence Engine Section
    table.merge_cells(institutionalMatrix, 0, current_row, 4, current_row)
    table.cell(institutionalMatrix, 0, current_row, '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ', text_halign = text.align_center, text_color = color_primary_2, text_size = size.small)
    current_row := current_row + 1
    table.merge_cells(institutionalMatrix, 0, current_row, 4, current_row)
    table.cell(institutionalMatrix, 0, current_row, 'üåå COHERENCE ENGINE', text_halign = text.align_center, text_color = color_primary_2, text_size = size.small)
    current_row := current_row + 1
    table.cell(institutionalMatrix, 0, current_row, 'State', text_color = text_dim, text_size = size.small)
    table.merge_cells(institutionalMatrix, 1, current_row, 4, current_row)
    coherence_state = market_coherence > i_coherenceThreshold ? '‚óâ PHASE LOCK' : market_coherence > i_coherenceThreshold * 0.75 ? '‚óé ORGANIZING' : '‚óã CHAOTIC'
    coherence_color = market_coherence > i_coherenceThreshold ? color_energy_1 : market_coherence > i_coherenceThreshold * 0.75 ? color_primary_2 : color_secondary_2
    table.cell(institutionalMatrix, 1, current_row, coherence_state, text_halign = text.align_right, text_color = coherence_color, text_size = size.small)
    current_row := current_row + 1
    table.cell(institutionalMatrix, 0, current_row, 'Power', text_color = text_dim, text_size = size.small)
    table.merge_cells(institutionalMatrix, 1, current_row, 4, current_row)
    power_text = str.tostring(market_coherence, '#.1') + '% ' + (coherence_momentum > 0 ? '‚Üó' : '‚Üò')
    table.cell(institutionalMatrix, 1, current_row, power_text, text_halign = text.align_right, text_color = text_bright, text_size = size.small)
    current_row := current_row + 1
    // Liquidity Matrix Section
    table.merge_cells(institutionalMatrix, 0, current_row, 4, current_row)
    table.cell(institutionalMatrix, 0, current_row, '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ', text_halign = text.align_center, text_color = color_secondary_1, text_size = size.small)
    current_row := current_row + 1
    table.merge_cells(institutionalMatrix, 0, current_row, 4, current_row)
    table.cell(institutionalMatrix, 0, current_row, 'üíé LIQUIDITY MATRIX', text_halign = text.align_center, text_color = color_secondary_1, text_size = size.small)
    current_row := current_row + 1
    table.cell(institutionalMatrix, 0, current_row, 'Nodes', text_color = text_dim, text_size = size.small)
    table.merge_cells(institutionalMatrix, 1, current_row, 4, current_row)
    nodes_text = str.tostring(array.size(institutional_nodes)) + ' Active'
    table.cell(institutionalMatrix, 1, current_row, nodes_text, text_halign = text.align_right, text_color = text_bright, text_size = size.small)
    current_row := current_row + 1
    table.cell(institutionalMatrix, 0, current_row, 'Node Target', text_color = text_dim, text_size = size.small)
    table.merge_cells(institutionalMatrix, 1, current_row, 4, current_row)
    target_text = ''
    target_color = text_dim
    if not na(current_target)
        target_price_str = str.tostring(current_target.price, format.mintick)
        target_distance = math.abs(current_target.price - close)
        target_direction = current_target.price > close ? '‚Üë' : '‚Üì'
        distance_pips = target_distance / syminfo.mintick
        target_text := target_price_str + ' ' + target_direction + ' [' + str.tostring(distance_pips, '#') + ']'
        target_color := text_bright
        target_color
    else
        node_count = array.size(institutional_nodes)
        target_text := 'Scanning... [' + str.tostring(node_count) + ' nodes]'
        target_color := text_dim
        target_color
    table.cell(institutionalMatrix, 1, current_row, target_text, text_halign = text.align_right, text_color = target_color, text_size = size.small)
    current_row := current_row + 1
    // Cycle Matrix Section
    table.merge_cells(institutionalMatrix, 0, current_row, 4, current_row)
    table.cell(institutionalMatrix, 0, current_row, '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ', text_halign = text.align_center, text_color = color_accent_1, text_size = size.small)
    current_row := current_row + 1
    table.merge_cells(institutionalMatrix, 0, current_row, 4, current_row)
    table.cell(institutionalMatrix, 0, current_row, 'üåä CYCLE MATRIX', text_halign = text.align_center, text_color = color_accent_1, text_size = size.small)
    current_row := current_row + 1
    table.cell(institutionalMatrix, 0, current_row, 'Cycle', text_color = text_dim, text_size = size.small)
    table.merge_cells(institutionalMatrix, 1, current_row, 4, current_row)
    cycle_text = dominant_cycle_name + ' [' + str.tostring(dominant_cycle_period, '#') + ']'
    table.cell(institutionalMatrix, 1, current_row, cycle_text, text_halign = text.align_right, text_color = text_bright, text_size = size.small)
    current_row := current_row + 1
    table.cell(institutionalMatrix, 0, current_row, 'Sync', text_color = text_dim, text_size = size.small)
    table.merge_cells(institutionalMatrix, 1, current_row, 4, current_row)
    sync_text = cycles_aligned_bullish ? '‚ñ≤ BULLISH' : cycles_aligned_bearish ? '‚ñº BEARISH' : '‚óÜ DIVERGENT'
    sync_color = cycles_aligned_bullish ? color_energy_1 : cycles_aligned_bearish ? color_accent_2 : text_dim
    table.cell(institutionalMatrix, 1, current_row, sync_text, text_halign = text.align_right, text_color = sync_color, text_size = size.small)
    current_row := current_row + 1
    // Footer Section
    table.merge_cells(institutionalMatrix, 0, current_row, 4, current_row)
    table.cell(institutionalMatrix, 0, current_row, '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ', text_halign = text.align_center, text_color = color_energy_1, text_size = size.small)
    current_row := current_row + 1
    table.merge_cells(institutionalMatrix, 0, current_row, 4, current_row)
    string status_text = ''
    color status_bgcolor = na
    color footer_text_color = na
    if tier1_long or tier1_short
        status_text := tier1_long ? '‚óâ TIER 1 BUY ‚óâ' : '‚óâ TIER 1 SELL ‚óâ'
        status_bgcolor := tier1_long ? color_energy_1 : color_accent_2
        footer_text_color := text_bright
        footer_text_color
    else if tier2_long or tier2_short
        status_text := tier2_long ? '‚óé TIER 2 BUY ‚óé' : '‚óé TIER 2 SELL ‚óé'
        status_bgcolor := tier2_long ? color_energy_2 : color_accent_3
        footer_text_color := text_bright
        footer_text_color
    else if tier3_long or tier3_short
        status_text := tier3_long ? '‚óã TIER 3 BUY ‚óã' : '‚óã TIER 3 SELL ‚óã'
        status_bgcolor := tier3_long ? color_energy_3 : color_secondary_2
        footer_text_color := text_bright
        footer_text_color
    else // Default footer style as requested
        status_text := '‚óà‚ö° Dskyz (DAFE) Trading Systems ‚óà'
        status_bgcolor := color.new(#2A2E39, 0) // Dark Grey Background
        footer_text_color := text_glow // Light whitish-blue text       
        footer_text_color
    table.cell(institutionalMatrix, 0, current_row, status_text, text_halign = text.align_center, text_color = footer_text_color, text_size = size.small, bgcolor = status_bgcolor)
    //==============================================================================
    //                        INSTITUTIONAL ALERTS
    //==============================================================================
// alertcondition(tier1_long, title = 'AETHERIUM T1 BUY', message = '‚óâ AETHERIUM V3.0: TIER 1 QUANTUM BUY SIGNAL ‚óâ')
// alertcondition(tier1_short, title = 'AETHERIUM T1 SELL', message = '‚óâ AETHERIUM V3.0: TIER 1 QUANTUM SELL SIGNAL ‚óâ')
// alertcondition(tier2_long, title = 'AETHERIUM T2 BUY', message = '‚óé AETHERIUM V3.0: TIER 2 INSTITUTIONAL BUY ‚óé')
// alertcondition(tier2_short, title = 'AETHERIUM T2 SELL', message = '‚óé AETHERIUM V3.0: TIER 2 INSTITUTIONAL SELL ‚óé')
// alertcondition(coherence_activation, title = 'COHERENCE ACTIVATION', message = 'üåå AETHERIUM V3.0: QUANTUM COHERENCE ACTIVATED üåå')
// // Safe alert conditions for advanced targets
// var bool target_predicted_alert = false
// var bool target_reached_alert = false
// var bool target_standby_alert = false
// // Advanced Target Alerts
// alertcondition(target_predicted_alert, 'New Target Predicted', 'üéØ AETHERIUM: New High-Confidence Target Predicted')
// alertcondition(target_reached_alert, 'Target Reached', '‚úÖ AETHERIUM: Target Successfully Reached - Entering Standby Mode')
// alertcondition(target_standby_alert, 'Standby Mode', '‚è∏Ô∏è AETHERIUM: Target System in Standby - Preparing Next Prediction')














//@version=6
// indicator("üî¥ TIM NEW V2 Dynamic EMA Stack Support & Resistance", "üî¥ EMA S/R", max_labels_count = 50, max_bars_back=5000, overlay=true, calc_bars_count=6000)

// _display = display.none





//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üìå Notes on `max_bars_back` vs `calc_bars_count`
//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
//
// üîπ `max_bars_back`
//    ‚Ä¢ Sets how many historical bars Pine keeps in memory for direct indexing
//      (e.g. using `close[5000]`, `time[4000]`, etc).
//    ‚Ä¢ Hard limit is 5000. You cannot request beyond this, or you‚Äôll get an error.
//    ‚Ä¢ This is about *lookback depth* in arrays and series.
//
// üîπ `calc_bars_count`
//    ‚Ä¢ Sets how many bars back the script *actually starts calculating on*.
//    ‚Ä¢ Hard limit is 50,000 (way larger).
//    ‚Ä¢ Lets drawings (lines, labels, etc.) appear further back on the chart
//      without requiring deep indexing.
//    ‚Ä¢ Example: `calc_bars_count=20000` means 20k bars of history are processed,
//      but you still cannot do `close[6000]` unless `max_bars_back` ‚â• 6000.
//
// ‚úÖ Together:
//    ‚Ä¢ `max_bars_back = 5000` ‚Üí logic can only index up to 5000 bars safely.
//    ‚Ä¢ `calc_bars_count = 7500` ‚Üí chart will still process and display objects
//      across 7500 bars, but code must never index past 5000 bars.
//
// üõ†Ô∏è Practical use:
//    ‚Ä¢ Keep `max_bars_back` at the max you need for indexing (‚â§5000).
//    ‚Ä¢ Set `calc_bars_count` higher if you want visuals drawn on older data.
//    ‚Ä¢ Always guard array/time lookups with `bar_offset <= in_max_bars_back_`
//      to prevent runtime errors when calc_bars_count is larger.
//
//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ


var string settingsGroup = "Global Settings"
//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// ‚è≥ User Input: Max Bars Back for Label Lookups
//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// PineScript hard limit: 5000
// We clamp historical lookups with safe_offset to avoid runtime errors.
// Increasing this lets labels look further back in history (up to 5000 bars).

var int in_max_bars_back_ = input.int(
     defval = 3000,
     title  = "Max Bars Back for Support/Resistance Labels",
     minval = 1000,
     maxval = 5000,
     step   = 500,
     group  = settingsGroup,
     display = _display,
     tooltip = "Sets how far back labels and historical lookups are allowed to reference.\n\nüîπ Max allowed is 5000 (Pine Script limit).\n\nUse this to control the depth of array or time-based indexing (e.g. `close[4000]`).\n\n‚úÖ Tip: If your drawing logic uses `calc_bars_count` > 5000, this setting still needs to cap direct indexing at 5000 to avoid runtime errors.\n\nUse in combo with `calc_bars_count` for deep visuals, but always guard against indexing too far."
 )



// ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
// ‚ïë                    üî∑ EMA Top & Bottom Line Visualization Settings
// ‚ï†‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// ‚ïë These settings control the visual lines drawn based on EMA ribbon logic.
// ‚ïë - The "Top Line" typically tracks bullish resistance or bearish fall zones
// ‚ïë - The "Bottom Line" represents support depending on market context
// ‚ïë - Colors adapt dynamically based on ribbon transitions
// ‚ïë - Optional label visibility toggles included
// ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

EMA_sprt_res_settings = "üî∏Trend State Settingsüî∏"

// === Candle Overlay Mode ===
string candleOverlayMode = input.string(
     title="Candle Overlay Mode",
     defval="PlotCandles",
     options=["None", "Bar Color", "PlotCandles"],
     tooltip="Choose how the ribbon colors are displayed on candles:\n\n‚Ä¢ None ‚Äì Turns off all coloring\n‚Ä¢ Bar Color ‚Äì Colors candles using TradingView's barcolor(). Keeps custom chart bar styles active, otherwise turn off Trading View's bar colors in Settings menu to see this script's custom candle colors that uses plotcandles. \n‚Ä¢ PlotCandles ‚Äì Uses script's custom candles. Colors the entire candle (body + wick + border) with one unified color based on the trend state.",
     display = _display,
     group=EMA_sprt_res_settings
  )

// ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
// ‚ïë                           üìä EMA Stack Framework
// ‚ï†‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// ‚ïë This section is the *core engine* of the script: a dynamic EMA stacking system.
// ‚ïë Instead of using a single moving average, traders can select between carefully
// ‚ïë structured EMA groups (short, long, or minimal sets). Each stack is designed with
// ‚ïë Fibonacci-derived lengths, which many traders consider ‚Äúnatural rhythm‚Äù levels of
// ‚ïë market structure.
// ‚ïë
// ‚ïë üîπ Why it matters for traders:
// ‚ïë - **Stack Order = Market Bias** ‚Üí The relative order of EMAs determines whether
// ‚ïë   the market is trending bullish, bearish, or compressing (neutral/gray).
// ‚ïë - **Dynamic Flexibility** ‚Üí Switch between short-term sets (5‚Äì55) for scalping,
// ‚ïë   or longer sets (21‚Äì233) for swing/position trading.
// ‚ïë - **Contextual Support/Resistance** ‚Üí The ‚Äútop line‚Äù and ‚Äúbottom line‚Äù of the
// ‚ïë   ribbon act as dynamic support and resistance. They tighten in choppy zones and
// ‚ïë   expand in trends, helping traders adapt their entries/exits.
// ‚ïë - **Built-in Sensitivity Filters** ‚Üí ATR multipliers are baked in to prevent false
// ‚ïë   transitions and stabilize the ribbon width across assets/timeframes.
// ‚ïë
// ‚ïë üîπ Practical Benefit:
// ‚ïë - Visualizes whether a market is aligned in clean bullish/bearish momentum or
// ‚ïë   tangled in indecision.
// ‚ïë - Traders can use EMA stack shifts as early signals of **trend reversals** or
// ‚ïë   **continuations**, often earlier than single MA crossovers.
// ‚ïë - Provides an adaptive framework usable across intraday scalping to long-term
// ‚ïë   swing strategies.
// ‚ïë
// ‚ïë In short ‚Üí This EMA Stack section transforms raw price into a *structured roadmap*
// ‚ïë for trend bias, support/resistance, and momentum alignment.
// ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üîπ Trend State Visibility
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
bool show_top_line          = input.bool(false,  "Top Line",           inline = "TrendVis", group = EMA_sprt_res_settings, display = _display)
bool show_bottom_line       = input.bool(false,  "Bottom Line",        inline = "TrendVis", group = EMA_sprt_res_settings, display = _display)
bool show_topline_labels    = input.bool(false,  "Top Labels",         inline = "TrendVis", group = EMA_sprt_res_settings, display = _display)
bool show_bottomline_labels = input.bool(false,  "Bottom Labels",      inline = "TrendVis", group = EMA_sprt_res_settings, display = _display)

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üé® Trend State Colors
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
color color_bearish_price_state       = input.color(#f51673,               "Bearish Price",        inline = "TrendColor", group = EMA_sprt_res_settings, display = _display)
color color_bullish_price_state       = input.color(color.orange,          "Bullish Price",        inline = "TrendColor", group = EMA_sprt_res_settings, display = _display)
color color_bullish_resistance_state  = input.color(color.rgb(44,161,190), "Bullish Resistance",   inline = "TrendColor", group = EMA_sprt_res_settings, display = _display)
color color_bearish_support_state     = input.color(color.yellow,          "Bearish Support",      inline = "TrendColor", group = EMA_sprt_res_settings, display = _display)

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// ‚öôÔ∏è Visual Tuning touhid
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
int line_width = input.int(2, "Line Width", minval = 1, maxval = 5, inline = "TrendTune", group = EMA_sprt_res_settings, display = _display)

// turns out these are best as harcoded because they act as stability thresholds. What I found was setting 1 or the other to a low value actually made parts of the chart disappear.
float atr_multiplier_gray    =  14 //input.float(12, "ATR Threshold - Gray Zone", minval=0.1, step=0.05, group=EMA_sprt_res_settings,
                                          //tooltip="Defines narrow zone width for neutral (gray) state when EMAs are close.")
float atr_multiplier_yellow  = 14 // input.float(12, "ATR Threshold - Yellow Zone", minval=0.1, step=0.05, group=EMA_sprt_res_settings,
                                          //tooltip="Defines tighter zone for yellow (transition) state. Typically appears after trend reversal.")


// ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
// ‚ïë                         üìê EMA Length Stack (Fibonacci-Based)
// ‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ‚ïë This section uses a fixed 5-EMA stack: **5, 8, 13, 21, 34**
// ‚ïë
// ‚ïë These lengths are derived from the Fibonacci sequence ‚Äî widely used by traders
// ‚ïë to reflect natural market rhythm and cyclical behavior.
// ‚ïë
// ‚ïë üîπ Purpose of Each Length:
// ‚ïë ‚Ä¢ 5 & 8  ‚Üí Capture ultra-short-term price sensitivity
// ‚ïë ‚Ä¢ 13 & 21 ‚Üí Reflect short-term momentum and structure
// ‚ïë ‚Ä¢ 34     ‚Üí Acts as a dynamic mid-term trend anchor
// ‚ïë
// ‚ïë üîπ How This Helps:
// ‚ïë ‚Ä¢ Reveals the directional alignment of price across multiple time horizons
// ‚ïë ‚Ä¢ Enables bullish/bearish stack detection based on strict EMA order
// ‚ïë ‚Ä¢ Detects compression zones (gray/yellow) where EMAs cluster tightly
// ‚ïë
// ‚ïë üìå This stack is tuned for scalping and short-term trend following strategies.
// ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

ema_group = "üî∏EMA Inputsüî∏"

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üî∏ EMA Lengths Based on Selection
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
int ema1_length = input.int(5, "EMA 1", tooltip = "Captures ultra-short-term price action.\n\nThis EMA reacts fastest to market changes and serves as the most sensitive trend signal in the stack.", inline = "EMAStack", group = ema_group, display = _display)
int ema2_length = input.int(8, "EMA 2", tooltip = "Tracks very short-term momentum.\n\nPairs with EMA 5 to reveal rapid directional shifts and early breakouts.", inline = "EMAStack", group = ema_group, display = _display)
int ema3_length = input.int(13, "EMA 3", tooltip = "Acts as a short-term trend filter.\n\nHelps smooth out noise while maintaining sensitivity to recent moves.", inline = "EMAStack", group = ema_group, display = _display)
int ema4_length = input.int(21, "EMA 4", tooltip = "Reflects short-to-mid-term market structure.\n\nOften used to identify the core trend direction in price.", inline = "EMAStack", group = ema_group, display = _display)
int ema5_length = input.int(34, "EMA 5", tooltip = "Serves as the trend anchor of the stack.\n\nSlower and more stable ‚Äî helps define broader momentum and resistance/support zones.", inline = "EMAStack", group = ema_group, display = _display)
//int ema6_length = input.int(59, "EMA 5", tooltip = "Serves as the trend anchor of the stack.\n\nSlower and more stable ‚Äî helps define broader momentum and resistance/support zones.", inline = "EMAStack", group = ema_group, display = _display)


// --- EMA Calculations ---
float ema1 = ta.ema(close, ema1_length)
float ema2 = ta.ema(close, ema2_length)
float ema3 = ta.ema(close, ema3_length)
float ema4 = ta.ema(close, ema4_length)
float ema5 = ta.ema(close, ema5_length)
//float ema6 = ta.ema(close, ema6_length)


// ATR-based thresholds for narrowing detection
float atr_gray   = ta.atr(14) * atr_multiplier_gray
float atr_yellow = ta.atr(14) * atr_multiplier_yellow


// ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
// ‚ïë                        üî¢ EMA Stack & Narrowing Detection
// ‚ï†‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// ‚ïë 1. Collects all active EMAs into an array.    ‚ïë
// ‚ïë 2. Dynamically checks if EMAs are ordered strictly ascending (bullish stack) or
// ‚ïë    descending (bearish stack). This avoids hardcoding specific EMA comparisons.
// ‚ïë 3. Calculates the spread between the fastest and slowest EMA to detect
// ‚ïë    ‚Äúnarrowing‚Äù states (gray/yellow). These indicate indecision or transition
// ‚ïë    zones where trend strength weakens.
// ‚ïë
// ‚ïë Why this matters:
// ‚ïë ‚Ä¢ Makes the script future-proof.
// ‚ïë ‚Ä¢ Cleaner, more efficient than comparing ema1 > ema2 > ema3 manually.
// ‚ïë ‚Ä¢ Traders get clear signals:
// ‚ïë     üîπ Bullish stack = trending up with strong alignment.
// ‚ïë     üîπ Bearish stack = trending down with strong alignment.
// ‚ïë     üîπ Narrowing zones = warning of consolidation or potential reversal.
// ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
// ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
// ‚ïë                    üî¢ EMA Stack Logic & Narrowing Zone Detection
// ‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ‚ïë This block dynamically evaluates the **order and spacing** of the 5 active EMAs:
// ‚ïë 5, 8, 13, 21, and 34.
// ‚ïë
// ‚ïë üîπ Stack State Detection:
// ‚ïë ‚Ä¢ **Bullish Stack** ‚Üí EMAs strictly ordered descending: EMA 5 > 8 > 13 > 21 > 34
// ‚ïë ‚Ä¢ **Bearish Stack** ‚Üí EMAs strictly ordered ascending: EMA 5 < 8 < 13 < 21 < 34
// ‚ïë ‚Ä¢ Uses array-based logic to avoid manual comparisons and reduce error
// ‚ïë
// ‚ïë üîπ Narrowing Zone Detection:
// ‚ïë ‚Ä¢ Measures the spread between fastest (EMA 5) and slowest (EMA 34)
// ‚ïë ‚Ä¢ If spread is below defined ATR thresholds:
// ‚ïë     ‚Üí **Gray Zone** = Consolidation or indecision
// ‚ïë     ‚Üí **Yellow Zone** = Early transition or weakening trend
// ‚ïë
// ‚ïë üìà These zones help anticipate breakout setups, trend reversals, or chop areas.
// ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù


bool is_bullish_stack = ema1 > ema2 and ema2 > ema3 and ema3 > ema4 and ema4 > ema5
bool is_bearish_stack = ema1 < ema2 and ema2 < ema3 and ema3 < ema4 and ema4 < ema5

float ema_spread = math.abs(ema1 - ema5)

bool is_narrowing_gray   = not is_bullish_stack and not is_bearish_stack and ema_spread < atr_gray
bool is_narrowing_yellow = not is_bullish_stack and not is_bearish_stack and ema_spread < atr_yellow


// ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
// ‚ïë                          üîÅ EMA Stack State Persistence
// ‚ï†‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// ‚ïë Tracks previous stack state (bullish or bearish) to detect transitions.
// ‚ïë This helps inform color changes and transition zones like support/resistance.
// ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

var bool was_bullish_stack = false
var bool was_bearish_stack = false

was_bullish_stack := is_bullish_stack ? true : is_bearish_stack ? false : was_bullish_stack
was_bearish_stack := is_bearish_stack ? true : is_bullish_stack ? false : was_bearish_stack


// ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
// ‚ïë                      üîÆ Price Levels Based on EMA Stack
// ‚ï†‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// ‚ïë Records the most recent price where the EMAs were in a full bullish or bearish
// ‚ïë stack condition. These become the "top" or "bottom" prediction lines.
// ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

float bearish_stack_price = ta.valuewhen(is_bearish_stack, close, 0)
float bullish_stack_price = ta.valuewhen(is_bullish_stack, close, 0)


// ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
// ‚ïë                      üé® Assign Top & Bottom Line Colors
// ‚ï†‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// ‚ïë Uses current and past stack state to assign dynamic color styles to each line.
// ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

color top_line_color = is_bearish_stack                                ? color_bearish_price_state :
                       is_narrowing_yellow and not was_bullish_stack  ? color_bearish_support_state :
                       is_narrowing_gray   and was_bullish_stack      ? color_bullish_resistance_state :
                       is_bullish_stack                               ? color_bullish_price_state :
                       na

color bottom_line_color = top_line_color == color_bearish_price_state   ? color_bearish_price_state :
                          top_line_color == color_bearish_support_state      ? color_bearish_support_state :
                          top_line_color == color_bullish_resistance_state   ? color_bullish_resistance_state :
                          top_line_color == color_bullish_price_state      ? color_bullish_price_state :
                          na


// ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
// ‚ïë üñåÔ∏è Bar Coloring Logic ‚Äì Based on Top Line State
// ‚ï†‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// ‚ïë Applies bar colors based on top line transition states.
// ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

color bar_color = na

if top_line_color == color_bearish_price_state
    bar_color := color_bearish_price_state
else if top_line_color == color_bearish_support_state
    bar_color := color_bearish_support_state
else if top_line_color == color_bullish_resistance_state
    bar_color := color_bullish_resistance_state
else if top_line_color == color_bullish_price_state
    bar_color := color_bullish_price_state



// ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
// ‚ïë                           üü® Transition State Labels
// ‚ï†‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// ‚ïë This block creates **on-chart labels** that visually call out EMA ribbon
// ‚ïë transition states. They serve two purposes:
// ‚ïë   1) üîé Debugging Aid ‚Üí Helps verify logic by showing exactly when the code
// ‚ïë      detects transitions (e.g., bearish fall, bullish support, resistance test).
// ‚ïë   2) üìä Trader Feedback ‚Üí Provides immediate context during live trading,
// ‚ïë      highlighting whether price is entering a new trend, testing support, or
// ‚ïë      breaking into resistance.
// ‚ïë
// ‚ïë üéØ Benefits for Traders:
// ‚ïë - Clearly see *when and why* the script thinks the trend is shifting.
// ‚ïë - Spot early warning signals (‚Äúüí° Begin Bear Trend?‚Äù or ‚Äúüí° Begin Uptrend?‚Äù).
// ‚ïë - Differentiate between *support*, *resistance*, and *transition zones*.
// ‚ïë - Gain confidence in the EMA stack framework by visually confirming transitions.
// ‚ïë
// ‚ïë üõ† How it works:
// ‚ïë - The helper function `f_label()` checks whether labels should be shown and
// ‚ïë   places them at relevant EMA levels (`label_y_bull` or `label_y_bear`).
// ‚ïë - Each label is styled with background + text colors to match the state (orange
// ‚ïë   for bullish, gray for bearish, yellow for resistance, etc.).
// ‚ïë - Top line labels = signals above price (downward style).
// ‚ïë - Bottom line labels = confirmations below price (upward style).
// ‚ïë
// ‚ïë In short ‚Üí These labels turn invisible logic into visible trading cues,
// ‚ïë making the script more intuitive and easier to trust in real time.
// ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù


var color prev_top_line_color = na
var color prev_bottom_line_color = na
prev_top_line_color := nz(prev_top_line_color)
prev_bottom_line_color := nz(prev_bottom_line_color)

// === Label Style Settings ===
string label_size1 = input.string(
     title   = "Label Size",
     defval  = "tiny",
     options = ["tiny", "small", "normal", "large", "huge"],
     tooltip = "Adjusts the size of the SPRT/RES and trend transition labels on the chart.",
     group   = EMA_sprt_res_settings,
     display = _display
  )

// === Transition State Detection ===
bool is_transition_to_bearish_price_fall = top_line_color[1] == color_bullish_resistance_state and top_line_color == color_bearish_price_state
bool is_bearish_support_transition = top_line_color[1] == color_bearish_price_state and top_line_color == color_bearish_support_state
bool is_bullish_support_transition = bottom_line_color[1] == color_bearish_support_state and bottom_line_color == color_bullish_price_state
bool is_bullish_resistance_transition = bottom_line_color[1] == color_bullish_price_state and bottom_line_color == color_bullish_resistance_state
bool is_bearish_price_fall_transition = bottom_line_color[1] == color_bearish_support_state and bottom_line_color == color_bearish_price_state
bool is_bullish_support_after_resistance = bottom_line_color[1] == color_bullish_resistance_state and bottom_line_color == color_bullish_price_state


// === Label Y Positions ===
float label_y_bear = bearish_stack_price
float label_y_bull = bullish_stack_price

// === Label Helper ===
f_label(_show, _cond, _y, _text, _bg, _fg, _style) =>
    if _show and _cond
        label.new(bar_index - 1, _y, _text, color=_bg, textcolor=_fg, style=_style, size=label_size1)

// === Top Line Labels === Bear Trend/  "üí°\nBEAR?\n"
f_label(show_topline_labels, is_transition_to_bearish_price_fall, label_y_bull, "BEAR?\n", #ff525205, #f51673, label.style_label_down)
f_label(show_topline_labels, is_bearish_price_fall_transition,     label_y_bull, "BEAR?\n", #ff525200, #f51673, label.style_label_down)
f_label(show_topline_labels, is_bearish_support_transition,        label_y_bull, "\nSPRT", #787b8600, color.yellow, label.style_label_down)
f_label(show_topline_labels, is_bullish_support_transition,        high, "\nUp?", #4caf4f00, color.orange, label.style_label_down)
f_label(show_topline_labels, is_bullish_support_after_resistance,  high, "\nUP?", #ff990000, color.orange, label.style_label_down)
f_label(show_topline_labels, is_bullish_resistance_transition,     high, "\nRES?", #ffeb3b00, color.rgb(255, 215, 40), label.style_label_down)

// === Bottom Line Labels ===
f_label(show_bottomline_labels, is_bullish_resistance_transition, label_y_bear, "\nRES", #ffeb3b00, color.rgb(44, 161, 190), label.style_label_up)
f_label(show_bottomline_labels, is_bullish_support_transition,    label_y_bear, "UP\nSPRT", #4caf4f00, color.orange, label.style_label_up)
f_label(show_bottomline_labels, is_bullish_support_after_resistance, label_y_bear, "UP\nSPRT", #ff990000, color.orange, label.style_label_up)



// ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
// ‚ïë                  üìä Global State: Support, Resistance & Regain Tracking
// ‚ï†‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// ‚ïë This section declares all persistent variables and arrays used throughout the
// ‚ïë script for line creation, tracking, and regain logic.
// ‚ïë
// ‚ïë ‚îÄ Support Lines:
// ‚ïë   ‚Ä¢ Store drawn SPRT lines, their prices, bar indices, and label states.
// ‚ïë          // ‚ïë
// ‚ïë ‚îÄ Resistance Lines:
// ‚ïë   ‚Ä¢ Store drawn RES lines, their prices, bar indices, and label states.
// ‚ïë
// ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù


// === üü® Support Line State ===
var array<line>  support_lines    = array.new_line()
var array<float> support_prices   = array.new_float()
var array<int>   support_indices  = array.new_int()
var array<bool>  support_labeled  = array.new_bool()   // ‚úÖ track if line already labeled

var float last_support_price      = na
var int   last_support_index      = na
var int   last_valid_bar_support  = na

// Tracks broken support (for regain logic)
var float most_recent_broken_support_price = na
var int   most_recent_broken_support_bar   = na
var bool  is_support_broken_label          = false   // ‚úÖ true only on break candle

// === üü• Resistance Line State ===
var array<line>  resistance_lines   = array.new_line()
var array<float> resistance_prices  = array.new_float()
var array<int>   resistance_indices = array.new_int()
var array<bool>  resistance_labeled = array.new_bool()   // ‚úÖ track if line already labeled

var float last_resistance_price     = na
var int   last_resistance_index     = na
var int   last_valid_bar_res        = na
var int   last_broke_res_bar        = na
var float last_broke_res_price      = na
line      new_resistance_line       = na

// ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
// ‚ïë                      üõ†Ô∏è Utility & Label Management Helpers
// ‚ï†‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// ‚ïë These functions support formatting, spacing, label text composition,
// ‚ïë and lifecycle management. They ensure consistent visuals across
// ‚ïë support/resistance labels, regain markers, and transitions.
// ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// ‚ú® Spacing & Text Helpers
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

// üîß Insert padding spaces (em-spaces for label alignment)
f_spacer(int _n) =>
    var string emSpace = "‚ÄÉ"
    string out = ""
    for i = 1 to _n
        out += emSpace
    out


// ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
// ‚ïë                  üìè Support & Resistance Extension Settings
// ‚ï†‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// ‚ïë Controls creation, styling, and visibility of Support (green) and Resistance
// ‚ïë (magenta) extension lines. Users can independently toggle visibility, labels,
// ‚ïë line thickness, and colors. Labels remain independent from line visibility.
// ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

group_snr = "üî∏SPRT & RES Extension Lines Settingsüî∏"

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üîπ Support Line Settings
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
string support_line_visibility       = input.string("Keep Visible", "Support Line Visibility", options=["Keep Visible", "Hide All"], inline="SupportVis", group=group_snr, tooltip="Choose whether to keep historical support lines visible or hide them completely.", display=_display)
bool   keep_support_lines_visible    = (support_line_visibility == "Keep Visible")
bool   show_support_labels           = input.bool(true, "Support Labels", inline="SupportVis", group=group_snr, display=_display)
int    support_line_width            = input.int(2, "Support Line Width", minval=1, maxval=5, inline="SupportVis", group=group_snr, display=_display)
int    max_support_lines             = input.int(10, "Max Support Lines", minval=0, maxval=50, inline="SupportVis", group=group_snr, display=_display)
color  support_line_color            = input.color(#367730, "Support Line Color", inline="SupportVis", group=group_snr, display=_display)

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üîπ Resistance Line Settings
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
string resistance_line_visibility    = input.string("Keep Visible", "Resistance Line Visibility", options=["Keep Visible", "Hide All"], inline="ResistanceVis", group=group_snr, tooltip="Choose whether to keep historical resistance lines visible or hide them completely.", display=_display)
bool   keep_resistance_lines_visible = (resistance_line_visibility == "Keep Visible")
bool   show_resistance_line_label_   = input.bool(true, "Resistance Labels", inline="ResistanceVis", group=group_snr, display=_display)
int    resistance_line_width         = input.int(2, "Resistance Line Width", minval=1, maxval=5, inline="ResistanceVis", group=group_snr, display=_display)
int    max_resistance_lines          = input.int(10, "Max Resistance Lines", minval=0, maxval=50, inline="ResistanceVis", group=group_snr, display=_display)
color  resistance_line_color         = input.color(color.rgb(188, 78, 153), "Resistance Line Color", inline="ResistanceVis", group=group_snr, display=_display)

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üîπ Shared Label Size
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
labelSizeInput_snr_labels = input.string("Tiny", "Label Size (üü¢SPRT & üî¥RES)", options=["Tiny", "Small", "Normal", "Large", "Huge"], inline="SNRLabelSize", group=group_snr, display=_display)

labelSize_snr_labels = switch labelSizeInput_snr_labels
    "Tiny"   => size.tiny
    "Small"  => size.small
    "Normal" => size.normal
    "Large"  => size.large
    "Huge"   => size.huge



// ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
// ‚ïë                         üè∑Ô∏è Support & Resistance Labels
// ‚ï†‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// ‚ïë Shared function to place SPRT (up) and RES (down) labels. Uses independent
// ‚ïë toggles for support/resistance labels and respects user-selected colors + size.
// ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

// --- Unified Label Management Function ---
f_manage_snr_label(_isSupport, _cond, _bar, _price, _txt, _isBullish) =>
    if _isSupport and _cond and show_support_labels
        label.new(
             _bar,
             _price,
             _txt,
             style     = label.style_label_up,
             textcolor = _isBullish ? color.green : color.gray,    // üü¢ SPRT vs failed reclaim
             color     = #ffffff00,                                // transparent background
             size      = labelSize_snr_labels
          )
    if not _isSupport and _cond and show_resistance_line_label_
        label.new(
             _bar,
             _price,
             _txt,
             style     = label.style_label_down,
             textcolor = _isBullish ? na : #d630f3,
             color     = #ffffff00,
             size      = labelSize_snr_labels
          )


// ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
// ‚ïë                             üõ† Additional Helper Functions
// ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
f_extend_line(_line, _y) =>
    line.set_xy2(_line, bar_index, _y)

f_new_support_line(_index, _price) =>
    line l = line.new(x1=_index, y1=_price, x2=bar_index + 100, y2=_price, color=support_line_color, width=support_line_width, extend = extend.none)
    array.push(support_lines, l)
    array.push(support_prices, _price)
    array.push(support_indices, _index)
    array.push(support_labeled, false)   // ‚úÖ mark as not labeled yet
    // enforce max count here only
    while array.size(support_lines) > max_support_lines
        line oldest = array.shift(support_lines)
        array.shift(support_prices)
        array.shift(support_indices)
        array.shift(support_labeled)     // ‚úÖ keep arrays in sync
        line.delete(oldest)


// ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
// ‚ïë                         ‚ûï Create New Support Lines
// ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
if bottom_line_color == color_bullish_resistance_state and not na(bearish_stack_price)
    last_support_price := bearish_stack_price
    last_support_index := bar_index

bool is_support_transition =
     bottom_line_color == color_bearish_price_state and
     bottom_line_color[1] == color_bullish_resistance_state and
     not na(last_support_price) and
     not na(last_support_index) and
     close > last_support_price

if is_support_transition and not na(last_support_price) and last_support_price > 0
    f_new_support_line(last_support_index, last_support_price)
    f_manage_snr_label(true, show_support_labels, bar_index - 1, last_support_price, "üü¢\nSPRT", true)


// ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
// ‚ïë                          ‚öôÔ∏è Support Line Handling
// ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
if array.size(support_lines) > 0
    for i = array.size(support_lines) - 1 to 0
        line  l     = array.get(support_lines, i)
        float price = array.get(support_prices, i)
        int   idx   = array.get(support_indices, i)

        if close < price and close[1] >= price
            last_valid_bar_support := bar_index

        if keep_support_lines_visible
            // --- Normal visible behavior ---
            if close < price
                int breakdown_bar = nz(last_valid_bar_support, idx)
                line.set_xy2(l, breakdown_bar, price)
                array.remove(support_lines, i)
                array.remove(support_prices, i)
                array.remove(support_indices, i)
                array.remove(support_labeled, i)  // ‚úÖ keep arrays in sync
            else
                f_extend_line(l, price)
        else
            // --- Hide All: delete line but keep arrays intact for regain labels ---
            line.delete(l)


// ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
// ‚ïë                         ‚ûï Create New Resistance Lines
// ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
if top_line_color == color_bearish_support_state and not na(bullish_stack_price)
    last_resistance_price := bullish_stack_price
    last_resistance_index := bar_index

bool is_resistance_transition =
     top_line_color == color_bullish_price_state and
     top_line_color[1] == color_bearish_support_state and
     not na(last_resistance_price) and
     not na(last_resistance_index) and
     close < last_resistance_price

if is_resistance_transition and not na(last_resistance_price) and last_resistance_price > 0
    line new_res_line = line.new(last_resistance_index, last_resistance_price, bar_index, last_resistance_price,
                                 color=resistance_line_color, width=resistance_line_width, extend=extend.none)
    array.push(resistance_lines, new_res_line)
    array.push(resistance_prices, last_resistance_price)
    array.push(resistance_indices, last_resistance_index)
    array.push(resistance_labeled, false)  // ‚úÖ not labeled yet

    f_manage_snr_label(false, show_resistance_line_label_, bar_index - 1, last_resistance_price, "üî¥\nRES", false)


    while array.size(resistance_lines) > max_resistance_lines
        line oldest = array.shift(resistance_lines)
        array.shift(resistance_prices)
        array.shift(resistance_indices)
        array.shift(resistance_labeled)    // ‚úÖ keep in sync
        line.delete(oldest)


// ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
// ‚ïë                          ‚öôÔ∏è Resistance Line Handling (Dropdown Mode)
// ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
if array.size(resistance_lines) > 0
    for i = array.size(resistance_lines) - 1 to 0
        line  l     = array.get(resistance_lines, i)
        float price = array.get(resistance_prices, i)
        int   idx   = array.get(resistance_indices, i)

        // --- Track breakout bar for extension ---
        if close > price and close[1] <= price
            last_valid_bar_res := bar_index

        if keep_resistance_lines_visible
            if close > price
                int breakout_bar = nz(last_valid_bar_res, idx)
                line.set_xy2(l, breakout_bar, price)
                array.remove(resistance_lines, i)
                array.remove(resistance_prices, i)
                array.remove(resistance_indices, i)
                array.remove(resistance_labeled, i)   // ‚úÖ keep in sync
            else
                line.set_xy2(l, bar_index, price)
        // else ‚Üí do nothing (lines hidden), arrays intact so labels still fire


// ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
// üìå Pivot-Based Projection Lines ‚Äî via Left/Right Bar Logic
//
// üîπ What This Block Does:
// --------------------------------------------------------------------------------
// Dynamically draws **horizontal support/resistance lines** at candidate pivot high/low levels
// using a classic **Left/Right bar structure** for pivot detection (default left 21, right 5)
//
// üß† Pivot Logic Explained:
// --------------------------------------------------------------------------------
// ‚Ä¢ A **Pivot High** is detected when the current bar's high is greater than all
//   highs in the last `Left Bars` - You can look at this as a lookback window
//
// ‚Ä¢ A **Pivot Low** is detected when the current bar's low is lower than all lows
//   in the last `Left Bars`
//
// ‚Ä¢ These pivot candidates are **early-stage**, and aren't confirmed by Right Bars
//   ‚Äî but are **visually projected forward** as structural clues.
//
// üìà Projection Line Behavior:
// --------------------------------------------------------------------------------
// ‚Ä¢ Once a pivot is detected, a horizontal line is drawn at that bar
// ‚Ä¢ The line **extends forward** on each bar until a new pivot of the same type
//   replaces it
// ‚Ä¢ The source used (Wicks vs Closes) can be toggled to adjust sensitivity
//
// üîç Use Case Examples:
// --------------------------------------------------------------------------------
// ‚úÖ Visualize where structure may form before full confirmation
// ‚úÖ Track local highs/lows in real time
// ‚úÖ Combine with your existing EMA stack logic for confluence
// ‚úÖ Useful in scalping or reversal-based strategies
//
// üõ† Configurable via:
// --------------------------------------------------------------------------------
// - Left/Right bar settings
// - Source selection (Wicks vs Closes)
// - Line colors and visibility toggles
// ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

group_pivotProj = "üî∏Pivot-Based S/R Settingsüî∏"

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üîπ Pivot-Based SPRT/RES Lines Settings
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
showProjLines = input.bool(true, "Show SPRT/RES Lines (Pivot-Based)", tooltip="Enable/Disable support/resistance lines that project early pivot levels.\n\nThese are **pre-confirmation support/resistance** levels drawn using Left/Right bar logic:\n‚Ä¢ Pivot High = High is higher than last N left bars\n‚Ä¢ Pivot Low = Low is lower than last N left bars\n\nLines extend forward until replaced, giving real-time structure insight.\n\nUseful for scalping, reversal setups, or structure mapping.", inline="PivotProj", group=group_pivotProj, display=_display)

in_leftBars_proj = input.int(21, "Left Bars", tooltip="Number of bars to the left required to qualify a pivot.\n\nüîπ A Pivot High must be higher than all highs in this left-side window.\n\nFor example, with Left Bars = 21:\n‚Üí A Pivot High forms only if the current bar's high is greater than the highs of the **previous 21 bars**.\n\nThis acts like a lookback buffer ‚Äî increasing it reduces noise and creates more reliable but less frequent pivots.", inline="PivotProj", group=group_pivotProj, display=_display)

in_rightBars_proj = input.int(5, "Right Bars", tooltip="Number of bars to the right required to **confirm** the pivot.\n\nThis script projects levels *before* confirmation, but right bars help contextualize how early the structure forms.\n\nIncrease for slower but more confirmed levels. For instant (much quicker) confirmation, use 1 or 2.", inline="PivotProj", group=group_pivotProj, display=_display)

projSrcMode = input.string("Closes", "Pivot Source", options=["Wicks","Closes"], tooltip="Choose the price point used to evaluate pivots:\n‚Ä¢ Wicks: Uses Highs/Lows (more sensitive)\n‚Ä¢ Closes: Uses Close prices (less noisy, more conservative)", inline="PivotProj", group=group_pivotProj, display=_display)


projHighSrc = projSrcMode == "Wicks" ? high : close
projLowSrc  = projSrcMode == "Wicks" ? low  : close

// projHighLoc = projHighSrc[1] + projHighSrc[1] * 0.25// 1% below the candle low
// projLowLoc = projLowSrc[1] - projLowSrc[1] * 0.65  // 1% below the candle low


// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Pivot Calculation ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
projHighVal    = ta.highest(projHighSrc[1], in_leftBars_proj)
projHighOffset = ta.highestbars(projHighSrc[1], in_leftBars_proj)
//projHighIdx    = bar_index - 1 - projHighOffset

projLowVal     = ta.lowest(projLowSrc[1], in_leftBars_proj)
projLowOffset  = ta.lowestbars(projLowSrc[1], in_leftBars_proj)
projLowIdx     = bar_index - 1 - projLowOffset

isProjHigh = projHighSrc > projHighVal
isProjLow  = projLowSrc  < projLowVal


// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Persistent Line Handles ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
var line projHighLine = na
var line projLowLine  = na

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Draw New Lines ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
if showProjLines and isProjHigh
    line.delete(projHighLine)
    projHighLine := line.new(
         x1 = bar_index, y1 = projHighSrc,
         x2 = bar_index + 1, y2 = projHighSrc,
         color=#f51673, style=line.style_dotted, width=10
     )
if showProjLines and isProjLow
    line.delete(projLowLine)
    projLowLine := line.new(x1=bar_index, y1=projLowSrc, x2=bar_index+1, y2=projLowSrc, color=color.rgb(1, 255, 255), style=line.style_dotted, width=10)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Extend Active Lines ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
if showProjLines and barstate.islast
    if not na(projHighLine)
        line.set_x2(projHighLine, bar_index)
    if not na(projLowLine)
        line.set_x2(projLowLine, bar_index)


// ==============================================================================
// üìå Real-time Close
// ==============================================================================
groupPriceFollowLine = "üî∏Real-time Close Line Settingsüî∏"

// --- Left Extension ---
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üîπ Price Follow Line Settings
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

// --- Left Extension ---
toggle_extend_left = input.bool(true, "Extend Line Left", inline="left", group=groupPriceFollowLine, display=_display)
extend_left_bars   = input.int(5, "Bars", minval=0, inline="left", group=groupPriceFollowLine, display=_display)
left_line_style    = input.string("Solid", "", options=["Solid","Dotted","Dashed"], inline="left", group=groupPriceFollowLine, display=_display)

// --- Right Extension ---
enable_right_line  = input.bool(true, "Extend Line Right", inline="right", group=groupPriceFollowLine, display=_display)
extend_right_bars  = input.int(5, "Bars", minval=0, inline="right", group=groupPriceFollowLine, display=_display)
right_line_style   = input.string("Solid", "", options=["Solid","Dotted","Dashed"], inline="right", group=groupPriceFollowLine, display=_display)

// --- General Style ---
line_width_close   = input.int(4, "Line Width", minval=1, maxval=10, group=groupPriceFollowLine, display=_display)


// Variable to store the line, initialized only once
var line priceline_left = na
var line priceline_right = na


// Convert string to line style
line_style_from_input(style) =>
    switch style
        "Dotted" => line.style_dotted
        "Dashed" => line.style_dashed
        "Solid" => line.style_solid
        => line.style_solid

//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Helper: create, update, or delete a line
//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
f_manageLine(_enabled, _line, _x1, _y1, _x2, _y2, _color, _width, _style) =>
    var line newLine = _line
    if _enabled
        if na(newLine)
            newLine := line.new(_x1, _y1, _x2, _y2, width=_width, color=_color, style=_style)
        else
            line.set_xy1(newLine, _x1, _y1)
            line.set_xy2(newLine, _x2, _y2)
            line.set_color(newLine, _color)
            line.set_width(newLine, _width)
            line.set_style(newLine, _style)
    else
        if not na(newLine)
            line.delete(newLine)
            newLine := na
    newLine


// Left line
int start_x = bar_index - extend_left_bars
priceline_left := f_manageLine(
     toggle_extend_left, priceline_left,
     bar_index, close, start_x, close,
     bar_color, line_width_close, line_style_from_input(left_line_style)
 )

// Right line
priceline_right := f_manageLine(
     enable_right_line, priceline_right,
     bar_index, close, bar_index + extend_right_bars, close,
     bar_color, line_width_close, line_style_from_input(right_line_style)
 )


// ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
// ‚ïë                 üìâ Bottom Line Tracker ‚Äì Real-Time Close Follower
// ‚ï†‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// ‚ïë This line ensures that a dynamic bottom line follows price in real-time.
// ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

bool is_bearish_support = bottom_line_color == color_bearish_support_state

color bearish_support_tracker_color =
  is_bearish_support
  ? color_bearish_support_state
  : color.new(color.white, 100)  // Fully transparent in other states

plot(
  show_bottom_line ? close : na,
  title="Bottom Line Close Tracker",
  color=bearish_support_tracker_color,
  linewidth=line_width
  )


// === Top Line Close Tracker (for Bullish Resistance state) ===
bool is_bullish_resistance = top_line_color == color_bullish_resistance_state

color bullish_resistance_tracker_color =
  is_bullish_resistance
  ? color_bullish_resistance_state
  : color.new(color.yellow, 100)  // Fully transparent in other states

plot(
  show_top_line ? close : na,
  title="Top Line Close Tracker - Bullish Resistance",
  color=bullish_resistance_tracker_color,
  linewidth=line_width
  )


plot(show_bottom_line ? bearish_stack_price : na, color=bottom_line_color, linewidth=line_width, title="Bottom Line")
plot(show_top_line ? bullish_stack_price : na, color=top_line_color, linewidth=line_width, title="Top Line")



// ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
// ‚ïë üïØÔ∏è Candle Plotting ‚Äì Matches Top Line Color States
// ‚ï†‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// ‚ïë Colors both candle bodies and wicks using bar_color.
// ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
// === Bar Color (if "Bar Color" is selected) ===
barcolor(candleOverlayMode == "Bar Color" ? bar_color : na, title="Bar Color")

// === Custom PlotCandles (if "PlotCandles" is selected) ===
plotcandle(
     open,
     high,
     low,
     close,
     color       = candleOverlayMode == "PlotCandles" ? bar_color : na,
     wickcolor   = candleOverlayMode == "PlotCandles" ? bar_color : na,
     bordercolor = candleOverlayMode == "PlotCandles" ? color.new(bar_color, 0) : na,
     title       = "Ribbon Candle Overlay"
  )








//=========================================================================================================================================================================================================
//üî¥üî¥üî¥üî¥üî¥üî¥üî¥üî¥üî¥üî¥üî¥üî¥üî¥üî¥üî¥üî¥üî¥üî¥üî¥üî¥üî¥üî¥üî¥üî¥üî¥üî¥üî¥üî¥üî¥üî¥üî¥üî¥ 3 touhid
//=========================================================================================================================================================================================================

// This work is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International
// https://creativecommons.org/licenses/by-nc-sa/4.0/
// ¬© BigBeluga


// //@version=6
// indicator("Wolfe Waves [BigBeluga]", overlay = true, max_labels_count = 500, max_lines_count = 500)
// plot(na, editable = false)

// Ôº©ÔºÆÔº∞ÔºµÔº¥Ôº≥ ‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï{
sensetivity_WolfeWaves = input.int(defval=10, title="Sensetivity", display=_display)
isbull_WolfeWaves      = input.string("Bullish", "Wave", options=["Bullish", "Bearish"], display=_display) == "Bullish"
bearCol_WolfeWaves     = input.color(defval=color.orange, title="Bearish Color", display=_display)
bullCol_WolfeWaves     = input.color(defval=color.lime, title="Bullish Color", display=_display)
line_width_WolfeWaves  = input.int(defval=3, title="Line Width", display=_display)

var int     index_low_WolfeWaves   = na
var float   loww_WolfeWaves        = na
var int     index_high_WolfeWaves  = na
var float   highh_WolfeWaves       = na
var bool    direction_WolfeWaves   = bool(na)
var         isPh_WolfeWaves = false


type pivot
    float val
    int indx
    bool isPh_WolfeWaves
var pivots_WolfeWaves = array.new<pivot>()


var lastIndex_WolfeWaves = 0

type wave
    array<label> lbls
    array<line> lines

var draws_WolfeWaves = array.new<wave>()
var duration_WolfeWaves = 0
var isdetected_WolfeWaves = false
var top_WolfeWaves = 0.0

atr = ta.atr(200)

// }


// Ôº£Ôº°Ôº¨Ôº£ÔºµÔº¨Ôº°Ôº¥Ôº©ÔºØÔºÆÔº≥‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï{
len_WolfeWaves = sensetivity_WolfeWaves
float highest_WolfeWaves = ta.highest(len_WolfeWaves)
float lowest_WolfeWaves  = ta.lowest(len_WolfeWaves)

if pivots_WolfeWaves.size() > 5
    pivots_WolfeWaves.shift()


stl1_WolfeWaves   = line.style_solid

if high == highest_WolfeWaves
    direction_WolfeWaves := true
if low  == lowest_WolfeWaves
    direction_WolfeWaves := false

if low[1] == lowest_WolfeWaves[1] and low > lowest_WolfeWaves
    index_low_WolfeWaves := bar_index[1]
    loww_WolfeWaves      := low[1]

if high[1] == highest_WolfeWaves[1] and high < highest_WolfeWaves
    index_high_WolfeWaves := bar_index[1]
    highh_WolfeWaves      := high[1]

if direction_WolfeWaves != direction_WolfeWaves[1] and direction_WolfeWaves
    pivots_WolfeWaves.push(pivot.new(loww_WolfeWaves, index_low_WolfeWaves, false))

if direction_WolfeWaves != direction_WolfeWaves[1] and not direction_WolfeWaves
    pivots_WolfeWaves.push(pivot.new(highh_WolfeWaves, index_high_WolfeWaves, true))


if pivots_WolfeWaves.size() == 5

    piv1 = pivots_WolfeWaves.get(0)
    piv2 = pivots_WolfeWaves.get(1)
    piv3 = pivots_WolfeWaves.get(2)
    piv4 = pivots_WolfeWaves.get(3)
    piv5 = pivots_WolfeWaves.get(4)

    isBearWWave = piv1.val > piv2.val and piv2.val < piv3.val and piv3.val > piv1.val and piv4.val > piv2.val and piv4.val < piv1.val and piv5.val > piv3.val
    isBullWWave = piv1.val < piv2.val and piv2.val > piv4.val and piv3.val < piv1.val and piv4.val > piv1.val and piv5.val < piv3.val

    cond = isbull_WolfeWaves ? isBullWWave : isBearWWave
// }

// Ôº∞Ôº¨ÔºØÔº¥ ‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï{
    if cond and not isdetected_WolfeWaves and (lastIndex_WolfeWaves != piv1.indx) and piv1.indx > lastIndex_WolfeWaves and barstate.isconfirmed

        labels = array.new<label>()
        lines = array.new<line>()

        lastIndex_WolfeWaves := piv5.indx
        for p in pivots_WolfeWaves
            index = str.tostring(pivots_WolfeWaves.indexof(p)+1)
            labels.push(label.new(p.indx, p.val, style = p.isPh_WolfeWaves ? "ldn" : "lup", color = color(na), text = index == "5" ? (isbull_WolfeWaves ? "\n5\nBULLISH" : "\nBEARISH\n5") : index))

        color = isbull_WolfeWaves ? bullCol_WolfeWaves : bearCol_WolfeWaves

        l1 = line.new(piv1.indx, piv1.val, piv2.indx, piv2.val, color = color, width = 4)
        l2 = line.new(piv2.indx, piv2.val, piv3.indx, piv3.val, color = color, width = 4)
        l3 = line.new(piv3.indx, piv3.val, piv4.indx, piv4.val, color = color, width = 4)
        l4 = line.new(piv4.indx, piv4.val, piv5.indx, piv5.val, color = color, width = 4)

        bars1 = piv4.indx - piv1.indx
        slope1 = (piv1.val-piv4.val)/bars1

        bars2 = piv3.indx - piv1.indx
        slope2 = (piv3.val-piv1.val)/bars2
        b2 = piv5.indx - piv3.indx

        bars3 = piv4.indx - piv2.indx
        slope3 = (piv4.val-piv2.val)/bars3
        b3 = piv5.indx - piv4.indx


        l5 = line.new(piv1.indx, piv1.val, piv4.indx+bars1, piv4.val-slope1*bars1, width = line_width_WolfeWaves, style = line.style_dashed, color = chart.fg_color)


        l6 = line.new(piv1.indx, piv1.val, piv3.indx+b2, piv3.val+slope2*b2, width = line_width_WolfeWaves, style = line.style_dotted, color = chart.fg_color)
        l7 = line.new(piv2.indx, piv2.val, piv4.indx+b3, piv4.val+slope3*b3, width = line_width_WolfeWaves, style = line.style_dotted, color = chart.fg_color)


        lines.push(l1)
        lines.push(l2)
        lines.push(l3)
        lines.push(l4)
        lines.push(l5)

        isdetected_WolfeWaves := true
        duration_WolfeWaves := 0
        top_WolfeWaves := piv5.val

        draws_WolfeWaves.push(wave.new(labels, lines))

if isdetected_WolfeWaves
    duration_WolfeWaves += 1

if duration_WolfeWaves == 50
    isdetected_WolfeWaves := false


crossUp_WolfeWaves = ta.crossunder(high, top_WolfeWaves)
crossDn_WolfeWaves = ta.crossover(low, top_WolfeWaves)

if duration_WolfeWaves < 15

    cond = isbull_WolfeWaves ? crossUp_WolfeWaves : crossDn_WolfeWaves

    if cond and top_WolfeWaves == top_WolfeWaves[1] and barstate.isconfirmed

        d = draws_WolfeWaves.last()
        for l in d.lines
            l.set_color(color.red)

        for l in d.lbls
            l.delete()
// }












//=========================================================================================================================================================================================================
//üî¥üî¥üî¥üî¥üî¥üî¥üî¥üî¥üî¥üî¥üî¥üî¥üî¥üî¥üî¥üî¥üî¥üî¥üî¥üî¥üî¥üî¥üî¥üî¥üî¥üî¥üî¥üî¥üî¥üî¥üî¥üî¥
//5 touhid
//=========================================================================================================================================================================================================

// // //touhid
// // //@version=6
// // indicator("TIM NEW PRO Scalper V1 NOV 2025",
// //      overlay=true, max_bars_back=1000, max_lines_count=500, max_labels_count=500, max_boxes_count=500)

// // // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê Core
// // _display = display.all - display.status_line
groupCore = "Core"
atrLen    = input.int(14, "ATR Len", minval=1, group=groupCore, display=_display)
atr_scalperpro       = ta.atr(atrLen)
showVWAP  = input.bool(false, "Show Session VWAP", group=groupCore, display=_display)
showOR    = input.bool(false, "Show Opening Range", group=groupCore, display=_display)
orAutoK   = input.float(3.0, "OR: Auto K √ó TF minutes", step=0.5, group=groupCore, display=_display)
orMin     = input.int(30, "OR: Manual minutes", minval=1, group=groupCore, display=_display)
orMode    = input.string("Auto", "", options=["Auto","Manual"], group=groupCore, display=_display)


tf_minutes() =>
    float m = na
    if timeframe.isseconds
        m := math.max(1.0, timeframe.multiplier) / 60.0
    else if timeframe.isminutes
        m := timeframe.multiplier
    else if timeframe.isdaily
        m := 1440.0 * timeframe.multiplier
    else if timeframe.isweekly
        m := 10080.0 * timeframe.multiplier
    else
        m := 43200.0 * timeframe.multiplier
    m

float tfMin = tf_minutes()

// ‚îÄ‚îÄ Session-anchored VWAP (–¥–Ω–µ–≤–Ω–æ–π —è–∫–æ—Ä—å)
var float cumPV = na
var float cumV  = na
var bool  newSess = false
newSess := ta.change(time("D")) != 0

if newSess or na(cumPV)
    cumPV := 0
    cumV  := 0
cumPV += hlc3 * volume
cumV  += volume
vwap = cumV > 0 ? cumPV / cumV : na

// ‚îÄ‚îÄ Opening Range
float orLenMin = orMode=="Auto" ? orAutoK*tfMin : orMin
int   orBars   = math.max(1, int(math.ceil(orLenMin / math.max(tfMin, 1))))

var float orH = na
var float orL = na
var int   bfo = 0

if newSess
    orH := na
    orL := na
    bfo := 0

if bfo < orBars
    orH := na(orH) ? high : math.max(orH, high)
    orL := na(orL) ? low  : math.min(orL, low)
    bfo += 1

plot(showVWAP ? vwap : na, "VWAP", color=color.new(color.yellow, 0), linewidth=2)
plot(showOR and bfo>0 ? orH : na, "OR High", color=color.new(color.orange, 60), linewidth=1, style=plot.style_linebr)
plot(showOR and bfo>0 ? orL : na, "OR Low",  color=color.new(color.orange, 60), linewidth=1, style=plot.style_linebr)

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê Trend Filter (EMA / EMA+ADX, HTF –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
groupTrend  = "Trend Filter"
trendMode   = input.string("Off", "Mode", options=["Off","EMA","EMA+ADX"], group=groupTrend, display=_display)
useHTF      = input.bool(true, "Use HTF for filter", group=groupTrend, display=_display)
tfHTF       = input.timeframe("60", "HTF timeframe", group=groupTrend, display=_display)
emaFastLen  = input.int(34, "EMA Fast", minval=1, group=groupTrend, display=_display)
emaSlowLen  = input.int(89, "EMA Slow", minval=2, group=groupTrend, display=_display)
adxLen      = input.int(14, "ADX Len", minval=1, group=groupTrend, display=_display)
adxThr      = input.float(18, "ADX ‚â•", step=0.5, group=groupTrend, display=_display)
showTrendPl = input.bool(false, "Plot EMA filter", group=groupTrend, display=_display)


// ‚Äî –±–µ–∑–æ–ø–∞—Å–Ω—ã–π ADX (Wilder), –±–µ–∑ ta.adx/ta.dx
adxCalc(_len) =>
    upMove   = high - high[1]
    downMove = low[1] - low
    plusDM   = (upMove > downMove and upMove > 0) ? upMove : 0.0
    minusDM  = (downMove > upMove and downMove > 0) ? downMove : 0.0
    tr   = math.max(high - low, math.max(math.abs(high - close[1]), math.abs(low - close[1])))
    smTR = ta.rma(tr, _len)
    smP  = ta.rma(plusDM, _len)
    smM  = ta.rma(minusDM, _len)
    plusDI  = smTR != 0 ? 100.0 * smP / smTR : 0.0
    minusDI = smTR != 0 ? 100.0 * smM / smTR : 0.0
    dx = (plusDI + minusDI != 0) ? 100.0 * math.abs(plusDI - minusDI) / (plusDI + minusDI) : 0.0
    ta.rma(dx, _len)

srcClose = useHTF ? request.security(syminfo.tickerid, tfHTF, close) : close
emaF     = ta.ema(srcClose, emaFastLen)
emaS     = ta.ema(srcClose, emaSlowLen)
trendUp  = emaF > emaS
adxTF    = useHTF ? request.security(syminfo.tickerid, tfHTF, adxCalc(adxLen)) : adxCalc(adxLen)

longOK  = trendMode=="Off" ? true : trendMode=="EMA" ? trendUp : (trendUp and adxTF >= adxThr)
shortOK = trendMode=="Off" ? true : trendMode=="EMA" ? not trendUp : ((not trendUp) and adxTF >= adxThr)

plot(showTrendPl ? emaF : na, "EMA F", color=color.new(color.teal, 0))
plot(showTrendPl ? emaS : na, "EMA S", color=color.new(color.orange, 0))

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê Delta proxy (–¥–ª—è –ø—É–∑—ã—Ä—å–∫–æ–≤/–ø–ª–æ—Ç–Ω–æ—Å—Ç–µ–π)
groupDelta = "Delta / Volume"
deltaMode  = input.string("RangeWeighted", "Delta proxy", options=["RangeWeighted","CloseVsPrev","CloseVsOpen"], group=groupDelta, display = _display)

rng = math.max(high - low, syminfo.mintick)
dRW = rng > 0 ? volume * (close - open) / rng : 0
dCP = close >= close[1] ? volume : -volume
dCO = close >= open     ? volume : -volume
delta = deltaMode=="RangeWeighted" ? dRW : deltaMode=="CloseVsOpen" ? dCO : dCP

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê Bubbles
groupBub = "Bubbles"
showBub  = input.bool(true, "Show Bubbles (abs delta)", group=groupBub, display=_display)
qbLen    = input.int(200, "Quantile lookback", minval=50, group=groupBub, display=_display)
qbPct    = input.float(85, "Quantile %", step=0.5, minval=50, maxval=99.9, group=groupBub, display=_display)
regColor_bubble_sale = input.color(color.new(#c2890d, 0), title = "Channel Lines", group=groupBub, display = _display)
absDel = math.abs(delta)
thrBub = ta.percentile_linear_interpolation(absDel, qbLen, qbPct)

bubbleSize(r)=>
    s = size.tiny
    if r >= 3
        s := size.huge
    else if r >= 2.25
        s := size.large
    else if r >= 1.6
        s := size.normal
    else if r >= 1.1
        s := size.small
    s

if showBub and absDel >= math.max(thrBub, 1)
    ratio = absDel / math.max(thrBub, 1)
    y  = delta>=0 ? low : high
    c0 = delta>=0 ? color.lime : regColor_bubble_sale
    c  = color.new(c0, 85 - int(math.min(60.0, (ratio-1.0)*30.0)))
    label.new(bar_index, y, "", xloc=xloc.bar_index, yloc=yloc.price, style=label.style_circle, color=c, textcolor=c, size=bubbleSize(ratio))

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê Zones x2 (midline + only-in-trend)
groupZ = "Zones (AI-style, 2 pairs)"
showZones      = input.bool(true, "Show Zones", group=groupZ, display=_display)
zDepth         = input.float(0.6, "Zone depth √ó ATR", step=0.05, group=groupZ, display=_display)
zExtend        = input.int(30, "Extend (bars)", minval=10, group=groupZ, display=_display)
L1             = input.int(10, "Pivot A Left",  minval=2, group=groupZ, display=_display)
R1             = input.int(10, "Pivot A Right", minval=2, group=groupZ, display=_display)
L2             = input.int(5,  "Pivot B Left",  minval=2, group=groupZ, display=_display)
R2             = input.int(5,  "Pivot B Right", minval=2, group=groupZ, display=_display)
showZoneMid    = input.bool(true,  "Show zone midline", group=groupZ, display=_display)
onlyTrendZone  = input.bool(false, "Show only in-trend zones", group=groupZ, display=_display)
labSize        = input.string("Small", "Label size", options=["Tiny","Small","Normal"], group=groupZ, display=_display)
_lsize  = labSize=="Tiny" ? size.tiny : labSize=="Small" ? size.small : size.normal

colSupIn  = color.new(#E57373, 76)
colSupOut = color.new(#E57373, 96)
colSupBrI = color.new(#E57373, 25)
colSupBrO = color.new(#E57373, 90)
colDemIn  = color.new(#81C784, 76)
colDemOut = color.new(#81C784, 96)
colDemBrI = color.new(#81C784, 25)
colDemBrO = color.new(#81C784, 90)
colHide   = color.new(color.white, 100)
midCol    = color.new(color.gray, 50)

mkZone(_left, _top, _bot, isSupply, _right, inTrend) =>
    color fill = isSupply ? (inTrend ? colSupIn : colSupOut) : (inTrend ? colDemIn : colDemOut)
    color brd  = isSupply ? (inTrend ? colSupBrI : colSupBrO) : (inTrend ? colDemBrI : colDemBrO)
    box.new(_left, _top, _right, _bot, xloc=xloc.bar_index, bgcolor=fill, border_color=brd)

type PairState
    box   sup
    float supTop
    float supBot
    line  supMid
    box   dem
    float demTop
    float demBot
    line  demMid
    int   supTouches
    int   demTouches
    bool  inSupPrev
    bool  inDemPrev
    label labSup
    label labDem

makeMidline(x0, mid) =>
    line.new(x0, mid, x0 + zExtend, mid, xloc=xloc.bar_index, extend=extend.none, style=line.style_dashed, color=midCol, width=2)

updatePair(ph, pl, R, PairState s, string tag) =>
    box supRet = s.sup
    float sTop = s.supTop
    float sBot = s.supBot
    line sMidL = s.supMid
    box demRet = s.dem
    float dTop = s.demTop
    float dBot = s.demBot
    line dMidL = s.demMid
    int  supT  = s.supTouches
    int  demT  = s.demTouches
    bool wasS  = s.inSupPrev
    bool wasD  = s.inDemPrev
    label lSup = s.labSup
    label lDem = s.labDem

    if showZones and not na(ph)
        sTop := ph
        sBot := ph - zDepth * atr_scalperpro
        int x0 = bar_index - R
        if not na(supRet)
            box.delete(supRet)
        if not na(sMidL)
            line.delete(sMidL)
        supRet := mkZone(x0, sTop, sBot, true, bar_index + zExtend, shortOK)
        if showZoneMid
            sMidL := makeMidline(x0, (sTop + sBot) * 0.5)
        supT := 0
        wasS := false
        if not na(lSup)
            label.delete(lSup)
        lSup := label.new(x0, sTop, "Supply " + tag + " (0)", xloc=xloc.bar_index, yloc=yloc.price, style=label.style_label_left, size=_lsize, color=color.new(color.black, 100), textcolor=color.white)

    if showZones and not na(pl)
        dBot := pl
        dTop := pl + zDepth * atr_scalperpro
        int x1 = bar_index - R
        if not na(demRet)
            box.delete(demRet)
        if not na(dMidL)
            line.delete(dMidL)
        demRet := mkZone(x1, dTop, dBot, false, bar_index + zExtend, longOK)
        if showZoneMid
            dMidL := makeMidline(x1, (dTop + dBot) * 0.5)
        demT := 0
        wasD := false
        if not na(lDem)
            label.delete(lDem)
        lDem := label.new(x1, dBot, "Demand " + tag + " (0)", xloc=xloc.bar_index, yloc=yloc.price, style=label.style_label_left, size=_lsize, color=color.new(color.black, 100), textcolor=color.white)

    bool supInTrend = shortOK
    bool demInTrend = longOK

    if not na(supRet)
        if onlyTrendZone and not supInTrend
            box.set_bgcolor(supRet, colHide), box.set_border_color(supRet, colHide)
            if not na(lSup)
                label.delete(lSup), lSup := na
            if not na(sMidL)
                line.delete(sMidL), sMidL := na
        else
            box.set_bgcolor(supRet, supInTrend ? colSupIn : colSupOut)
            box.set_border_color(supRet, supInTrend ? colSupBrI : colSupBrO)
            if showZoneMid and na(sMidL)
                sMidL := makeMidline(box.get_left(supRet), (sTop + sBot) * 0.5)
            if na(lSup)
                lSup := label.new(box.get_left(supRet), sTop, "Supply " + tag + " (" + str.tostring(supT) + ")", xloc=xloc.bar_index, yloc=yloc.price, style=label.style_label_left, size=_lsize, color=color.new(color.black, 100), textcolor=color.white)

    if not na(demRet)
        if onlyTrendZone and not demInTrend
            box.set_bgcolor(demRet, colHide), box.set_border_color(demRet, colHide)
            if not na(lDem)
                label.delete(lDem), lDem := na
            if not na(dMidL)
                line.delete(dMidL), dMidL := na
        else
            box.set_bgcolor(demRet, demInTrend ? colDemIn : colDemOut)
            box.set_border_color(demRet, demInTrend ? colDemBrI : colDemBrO)
            if showZoneMid and na(dMidL)
                dMidL := makeMidline(box.get_left(demRet), (dTop + dBot) * 0.5)
            if na(lDem)
                lDem := label.new(box.get_left(demRet), dBot, "Demand " + tag + " (" + str.tostring(demT) + ")", xloc=xloc.bar_index, yloc=yloc.price, style=label.style_label_left, size=_lsize, color=color.new(color.black, 100), textcolor=color.white)

    bool inS = not na(sTop) and not na(sBot) and high >= sBot and low <= sTop
    bool inD = not na(dTop) and not na(dBot) and high >= dBot and low <= dTop
    if inS and not wasS
        supT += 1
    wasS := inS
    if inD and not wasD
        demT += 1
    wasD := inD

    if not na(lSup)
        label.set_x(lSup, not na(supRet) ? box.get_left(supRet) : bar_index)
        label.set_y(lSup, sTop)
        label.set_text(lSup, "Supply " + tag + " (" + str.tostring(supT) + ")")
    if not na(lDem)
        label.set_x(lDem, not na(demRet) ? box.get_left(demRet) : bar_index)
        label.set_y(lDem, dBot)
        label.set_text(lDem, "Demand " + tag + " (" + str.tostring(demT) + ")")

    PairState.new(supRet, sTop, sBot, sMidL, demRet, dTop, dBot, dMidL, supT, demT, wasS, wasD, lSup, lDem)

// –ì–ª–æ–±–∞–ª—å–Ω—ã–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è –ø–∞—Ä
var PairState pairA = PairState.new(na, na, na, na, na, na, na, na, 0, 0, false, false, na, na)
var PairState pairB = PairState.new(na, na, na, na, na, na, na, na, 0, 0, false, false, na, na)

// –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–∞—Ä
phA = ta.pivothigh(high, L1, R1)
plA = ta.pivotlow(low,  L1, R1)
pairA := updatePair(phA, plA, R1, pairA, "A")

phB = ta.pivothigh(high, L2, R2)
plB = ta.pivotlow(low,  L2, R2)
pairB := updatePair(phB, plB, R2, pairB, "B")

// –ü—Ä–æ–¥–ª–µ–Ω–∏–µ –≤–ø—Ä–∞–≤–æ (–±–æ–∫—Å—ã + midlines)
extendBox(_b) =>
    if not na(_b)
        box.set_right(_b, bar_index + zExtend)
extendLine(_l, y) =>
    if not na(_l)
        line.set_x2(_l, bar_index + zExtend)
        if not na(y)
            line.set_y1(_l, y), line.set_y2(_l, y)

extendBox(pairA.sup), extendBox(pairA.dem), extendBox(pairB.sup), extendBox(pairB.dem)
extendLine(pairA.supMid, na(pairA.supTop) or na(pairA.supBot) ? na : (pairA.supTop + pairA.supBot)*0.5)
extendLine(pairA.demMid, na(pairA.demTop) or na(pairA.demBot) ? na : (pairA.demTop + pairA.demBot)*0.5)
extendLine(pairB.supMid, na(pairB.supTop) or na(pairB.supBot) ? na : (pairB.supTop + pairB.supBot)*0.5)
extendLine(pairB.demMid, na(pairB.demTop) or na(pairB.demBot) ? na : (pairB.demTop + pairB.demBot)*0.5)

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê Subtle Densities
groupDen     = "Densities (Subtle)"
showDen      = input.bool(false, "Show Densities", group=groupDen, display=_display)
denMetricSrc = input.string("AbsDelta", "Metric", options=["AbsDelta","Volume"], group=groupDen, display=_display)
qLen         = input.int(200, "Quantile lookback", minval=50, group=groupDen, display=_display)
qPct         = input.float(92, "Quantile %", step=0.5, minval=60, maxval=99.9, group=groupDen, display=_display)
denDepth     = input.float(0.45, "Depth √ó ATR", step=0.05, group=groupDen, display=_display)
denExtend    = input.int(150, "Extend (bars)", minval=10, group=groupDen, display=_display)
mergeX       = input.float(0.30, "Merge if |Œîprice| < √óATR", step=0.05, group=groupDen, display=_display)
volLen       = input.int(20, "Volume MA", group=groupDen, display=_display)
breakMult    = input.float(1.2, "Delete if break vol > MA√ó", step=0.1, group=groupDen, display=_display)
showMidLineD = input.bool(true, "Midline (dashed)", group=groupDen, display=_display)

denMetric = denMetricSrc=="AbsDelta" ? math.abs(delta) : volume
denThr    = ta.percentile_linear_interpolation(denMetric, qLen, qPct)
volMA     = ta.sma(volume, volLen)

var box[]  dBoxes = array.new_box()
var line[] dLines = array.new_line()
var float[] dTop  = array.new_float()
var float[] dBot  = array.new_float()
var float[] dMid  = array.new_float()
var int[]   dEnd  = array.new_int()
var int[]   dDir  = array.new_int()

newDensity(mid, isDemand) =>
    float half = atr_scalperpro * denDepth
    float top  = mid + half
    float bot  = mid - half
    color fillCol = isDemand ? color.new(#4CAF50, 90) : color.new(#F44336, 90)
    color brdCol  = isDemand ? color.new(#4CAF50, 60) : color.new(#F44336, 60)
    box b = box.new(bar_index, top, bar_index, bot, xloc=xloc.bar_index, bgcolor=fillCol, border_color=brdCol)
    line ln = na
    if showMidLineD
        ln := line.new(bar_index, mid, bar_index, mid, xloc=xloc.bar_index, extend=extend.right, color=color.new(color.gray, 50), style=line.style_dashed, width=1)
    array.push(dBoxes, b), array.push(dLines, ln), array.push(dTop, top), array.push(dBot, bot), array.push(dMid, mid)
    array.push(dEnd, bar_index + denExtend), array.push(dDir, isDemand ? 1 : -1)

if showDen and denMetric >= denThr
    mid = close
    bool merged = false
    sz = array.size(dBoxes)
    if sz > 0
        for i=0 to sz-1
            if not merged and math.abs(mid - array.get(dMid, i)) <= atr_scalperpro*mergeX
                array.set(dEnd, i, bar_index + denExtend)
                merged := true
    if not merged
        newDensity(mid, delta>=0)

sz2 = array.size(dBoxes)
if sz2 > 0
    for i = sz2-1 to 0
        b   = array.get(dBoxes, i)
        ln  = array.get(dLines, i)
        top = array.get(dTop, i)
        bot = array.get(dBot, i)
        mid = array.get(dMid, i)
        right = math.min(bar_index + 1, array.get(dEnd, i))
        box.set_right(b, right)
        if not na(ln)
            line.set_x2(ln, right)
            line.set_y1(ln, mid)
            line.set_y2(ln, mid)
        dir = array.get(dDir, i)
        bool breakUp   = close > top and volume > volMA*breakMult
        bool breakDown = close < bot and volume > volMA*breakMult
        bool eaten = (dir==1 and breakDown) or (dir==-1 and breakUp)
        if eaten or bar_index >= array.get(dEnd, i)
            box.delete(b)
            if not na(ln)
                line.delete(ln)
            array.remove(dBoxes, i), array.remove(dLines, i), array.remove(dTop, i), array.remove(dBot, i), array.remove(dMid, i), array.remove(dEnd, i), array.remove(dDir, i)















//https://www.tradingview.com/script/TMLC5Wma-Adaptive-Market-Profile-Auto-Detect-Dynamic-Activity-Zones/
// @ Julien_Eche
///*
//Adaptive Market Profile is an advanced indicator that automatically detects and displays the most relevant trend 
//channel and market profile for any asset and timeframe. Unlike standard regression channel tools, this script uses 
//a fully adaptive approach to identify the optimal period, providing you with the channel that best fits
// the current market dynamics. The calculation is based on maximizing the statistical significance of the 
//trend using Pearson‚Äôs R coefficient, ensuring that the most relevant trend is always selected.
//*/
//@version=6
// indicator('üî¥ TIM NEW Adaptive Market Profile', shorttitle = "üî¥ TIM NEW Adaptive Market Profile", overlay = true, max_bars_back = 5000)

// _display = display.none
useAdaptive_adaptive = input.bool(true, display = _display, title = "Automatic detection of optimal trend channel period")
pI_adaptive = input.int(200, display = _display, title = "Manual channel period (bars)", minval = 2)
devMultiplier_adaptive = input.float(2.1, display = _display, title = "Deviation Multiplier", minval = 0.1, step = 0.1)
uL_adaptive = input.bool(true, display = _display, title = "Enable if chart is in logarithmic scale")

regColor_adaptive = input.color(color.new(color.white, 0), display = _display, title = "Channel Lines", inline = "reg_channel")
regLineStyle_adaptive = input.string("Solid", display = _display, title = "", options = ["Solid", "Dotted", "Dashed"], inline = "reg_channel")
regLineWidth_adaptive = input.int(2, display = _display, title = "", minval = 1, maxval = 4, inline = "reg_channel")

fillColor_adaptive = input.color(color.new(color.white, 97), display = _display, title = "Channel Fill", inline = "channel_fill")

showRegLine_adaptive = input.bool(true, display = _display, title = "Show Mid Line", inline = "reg_line")
showMostActiveLines_adaptive = input.bool(true, display = _display, title = "", inline = "lvls")
numActivityLines_adaptive = input.int(3, display = _display, title = "Show Most Active Lines", minval = 1, maxval = 5, inline = "lvls")

showProfile_adaptive = input.bool(false, display = _display, title = "Show Profile", inline = "profile_labels")
showLabels_adaptive = input.bool(false, display = _display, title = "Show Labels", inline = "profile_labels")

activityMethod_adaptive = input.string("Volume", display = _display, title = "Calculation method", options = ["Touches", "Volume"])
nFills_adaptive = input.int(23, display = _display, title = "Number of Profile Sections", minval = 2, maxval = 25)

loActColor_adaptive = input.color(color.new(#00BBFF, 95), display = _display, title = "Low Activity", inline = "profile_color")
hiActColor_adaptive = input.color(color.new(#00BBFF, 25), display = _display, title = "High Activity", inline = "profile_color")

regLineColor_adaptive = input.color(color.new(color.white, 0), display = _display, title = "", inline = "reg_line")
regLineStyleOpt_adaptive = input.string("Dashed", display = _display, title = "", options = ["Solid", "Dotted", "Dashed"], inline = "reg_line")
regLineWidthOpt_adaptive = input.int(2, display = _display, title = "", minval = 1, maxval = 4, inline = "reg_line")

useCustomColor_adaptive = input.bool(true, display = _display, title = "", inline = "act_line")
customColor_adaptive = input.color(color.new(#00BBFF, 50), display = _display, title = "Custom Active Line Color", inline = "act_line")
actLineStyle_adaptive = input.string("Solid", display = _display, title = "", options = ["Solid", "Dotted", "Dashed"], inline = "act_line")
actLineWidth_adaptive = input.int(2, display = _display, title = "", minval = 1, maxval = 5, inline = "act_line")

maxProfileBars_adaptive = 25
effectiveProfileBars_adaptive = math.max(numActivityLines_adaptive, math.min(nFills_adaptive, math.max(maxProfileBars_adaptive - (numActivityLines_adaptive - 2), 2)))

srcATF_adaptive = close
devMultATF_adaptive = devMultiplier_adaptive
isLogATF_adaptive = uL_adaptive

calcDevATF_adaptive(src_adaptive, len_adaptive) =>
    float base_adaptive = isLogATF_adaptive ? math.log(src_adaptive) : src_adaptive
    var int n1_adaptive = len_adaptive - 1
    if barstate.islast
        float sumX_adaptive = 0.0, sumXX_adaptive = 0.0, sumYX_adaptive = 0.0, sumY_adaptive = 0.0
        for i_adaptive = 1 to len_adaptive by 1
            float val_adaptive = base_adaptive[i_adaptive - 1]
            sumX_adaptive += i_adaptive
            sumXX_adaptive += i_adaptive * i_adaptive
            sumYX_adaptive += i_adaptive * val_adaptive
            sumY_adaptive += val_adaptive
        float slope_adaptive = nz((len_adaptive * sumYX_adaptive - sumX_adaptive * sumY_adaptive) / (len_adaptive * sumXX_adaptive - sumX_adaptive * sumX_adaptive))
        float avg_adaptive = sumY_adaptive / len_adaptive
        float intercept_adaptive = avg_adaptive - slope_adaptive * sumX_adaptive / len_adaptive + slope_adaptive
        float sumDev_adaptive = 0.0, sumDxx_adaptive = 0.0, sumDyy_adaptive = 0.0, sumDyx_adaptive = 0.0
        float reg_adaptive = intercept_adaptive + slope_adaptive * n1_adaptive * 0.5
        float sumSlope_adaptive = intercept_adaptive
        for i_adaptive = 0 to n1_adaptive by 1
            float v_adaptive = base_adaptive[i_adaptive]
            float dxt_adaptive = v_adaptive - avg_adaptive
            float dyt_adaptive = sumSlope_adaptive - reg_adaptive
            v_adaptive := v_adaptive - sumSlope_adaptive
            sumSlope_adaptive += slope_adaptive
            sumDxx_adaptive += dxt_adaptive * dxt_adaptive
            sumDyy_adaptive += dyt_adaptive * dyt_adaptive
            sumDyx_adaptive += dxt_adaptive * dyt_adaptive
            sumDev_adaptive += v_adaptive * v_adaptive
        float unStdDev_adaptive = math.sqrt(sumDev_adaptive / n1_adaptive)
        float divisor_adaptive = sumDxx_adaptive * sumDyy_adaptive
        float r_adaptive = nz(sumDyx_adaptive / math.sqrt(divisor_adaptive))
        [unStdDev_adaptive, r_adaptive, slope_adaptive, intercept_adaptive]
    else
        [na, na, na, na]


[stdDev01_adaptive, pr01_adaptive, slope01_adaptive, int01_adaptive] = calcDevATF_adaptive(srcATF_adaptive, 50)
[stdDev02_adaptive, pr02_adaptive, slope02_adaptive, int02_adaptive] = calcDevATF_adaptive(srcATF_adaptive, 60)
[stdDev03_adaptive, pr03_adaptive, slope03_adaptive, int03_adaptive] = calcDevATF_adaptive(srcATF_adaptive, 70)
[stdDev04_adaptive, pr04_adaptive, slope04_adaptive, int04_adaptive] = calcDevATF_adaptive(srcATF_adaptive, 80)
[stdDev05_adaptive, pr05_adaptive, slope05_adaptive, int05_adaptive] = calcDevATF_adaptive(srcATF_adaptive, 90)
[stdDev06_adaptive, pr06_adaptive, slope06_adaptive, int06_adaptive] = calcDevATF_adaptive(srcATF_adaptive, 100)
[stdDev07_adaptive, pr07_adaptive, slope07_adaptive, int07_adaptive] = calcDevATF_adaptive(srcATF_adaptive, 115)
[stdDev08_adaptive, pr08_adaptive, slope08_adaptive, int08_adaptive] = calcDevATF_adaptive(srcATF_adaptive, 130)
[stdDev09_adaptive, pr09_adaptive, slope09_adaptive, int09_adaptive] = calcDevATF_adaptive(srcATF_adaptive, 145)
[stdDev10_adaptive, pr10_adaptive, slope10_adaptive, int10_adaptive] = calcDevATF_adaptive(srcATF_adaptive, 160)
[stdDev11_adaptive, pr11_adaptive, slope11_adaptive, int11_adaptive] = calcDevATF_adaptive(srcATF_adaptive, 180)
[stdDev12_adaptive, pr12_adaptive, slope12_adaptive, int12_adaptive] = calcDevATF_adaptive(srcATF_adaptive, 200)
[stdDev13_adaptive, pr13_adaptive, slope13_adaptive, int13_adaptive] = calcDevATF_adaptive(srcATF_adaptive, 220)
[stdDev14_adaptive, pr14_adaptive, slope14_adaptive, int14_adaptive] = calcDevATF_adaptive(srcATF_adaptive, 250)
[stdDev15_adaptive, pr15_adaptive, slope15_adaptive, int15_adaptive] = calcDevATF_adaptive(srcATF_adaptive, 280)
[stdDev16_adaptive, pr16_adaptive, slope16_adaptive, int16_adaptive] = calcDevATF_adaptive(srcATF_adaptive, 310)
[stdDev17_adaptive, pr17_adaptive, slope17_adaptive, int17_adaptive] = calcDevATF_adaptive(srcATF_adaptive, 340)
[stdDev18_adaptive, pr18_adaptive, slope18_adaptive, int18_adaptive] = calcDevATF_adaptive(srcATF_adaptive, 370)
[stdDev19_adaptive, pr19_adaptive, slope19_adaptive, int19_adaptive] = calcDevATF_adaptive(srcATF_adaptive, 400)



var int detectedLongPeriod_adaptive = na
var float detectedLongSlope_adaptive = na
var float detectedLongIntercept_adaptive = na
var float detectedLongStdDev_adaptive = na
var float detectedLongPearson_adaptive = na

if barstate.islast
    float highestLong_adaptive = math.max(pr01_adaptive, pr02_adaptive, pr03_adaptive, pr04_adaptive, pr05_adaptive, pr06_adaptive, pr07_adaptive, pr08_adaptive, pr09_adaptive, pr10_adaptive, pr11_adaptive, pr12_adaptive, pr13_adaptive, pr14_adaptive, pr15_adaptive, pr16_adaptive, pr17_adaptive, pr18_adaptive, pr19_adaptive)

    if highestLong_adaptive == pr01_adaptive
        detectedLongPeriod_adaptive := 50
        detectedLongSlope_adaptive := slope01_adaptive
        detectedLongIntercept_adaptive := int01_adaptive
        detectedLongStdDev_adaptive := stdDev01_adaptive
        detectedLongPearson_adaptive := pr01_adaptive
    else if highestLong_adaptive == pr02_adaptive
        detectedLongPeriod_adaptive := 60
        detectedLongSlope_adaptive := slope02_adaptive
        detectedLongIntercept_adaptive := int02_adaptive
        detectedLongStdDev_adaptive := stdDev02_adaptive
        detectedLongPearson_adaptive := pr02_adaptive
    else if highestLong_adaptive == pr03_adaptive
        detectedLongPeriod_adaptive := 70
        detectedLongSlope_adaptive := slope03_adaptive
        detectedLongIntercept_adaptive := int03_adaptive
        detectedLongStdDev_adaptive := stdDev03_adaptive
        detectedLongPearson_adaptive := pr03_adaptive
    else if highestLong_adaptive == pr04_adaptive
        detectedLongPeriod_adaptive := 80
        detectedLongSlope_adaptive := slope04_adaptive
        detectedLongIntercept_adaptive := int04_adaptive
        detectedLongStdDev_adaptive := stdDev04_adaptive
        detectedLongPearson_adaptive := pr04_adaptive
    else if highestLong_adaptive == pr05_adaptive
        detectedLongPeriod_adaptive := 90
        detectedLongSlope_adaptive := slope05_adaptive
        detectedLongIntercept_adaptive := int05_adaptive
        detectedLongStdDev_adaptive := stdDev05_adaptive
        detectedLongPearson_adaptive := pr05_adaptive
    else if highestLong_adaptive == pr06_adaptive
        detectedLongPeriod_adaptive := 100
        detectedLongSlope_adaptive := slope06_adaptive
        detectedLongIntercept_adaptive := int06_adaptive
        detectedLongStdDev_adaptive := stdDev06_adaptive
        detectedLongPearson_adaptive := pr06_adaptive
    else if highestLong_adaptive == pr07_adaptive
        detectedLongPeriod_adaptive := 115
        detectedLongSlope_adaptive := slope07_adaptive
        detectedLongIntercept_adaptive := int07_adaptive
        detectedLongStdDev_adaptive := stdDev07_adaptive
        detectedLongPearson_adaptive := pr07_adaptive
    else if highestLong_adaptive == pr08_adaptive
        detectedLongPeriod_adaptive := 130
        detectedLongSlope_adaptive := slope08_adaptive
        detectedLongIntercept_adaptive := int08_adaptive
        detectedLongStdDev_adaptive := stdDev08_adaptive
        detectedLongPearson_adaptive := pr08_adaptive
    else if highestLong_adaptive == pr09_adaptive
        detectedLongPeriod_adaptive := 145
        detectedLongSlope_adaptive := slope09_adaptive
        detectedLongIntercept_adaptive := int09_adaptive
        detectedLongStdDev_adaptive := stdDev09_adaptive
        detectedLongPearson_adaptive := pr09_adaptive
    else if highestLong_adaptive == pr10_adaptive
        detectedLongPeriod_adaptive := 160
        detectedLongSlope_adaptive := slope10_adaptive
        detectedLongIntercept_adaptive := int10_adaptive
        detectedLongStdDev_adaptive := stdDev10_adaptive
        detectedLongPearson_adaptive := pr10_adaptive
    else if highestLong_adaptive == pr11_adaptive
        detectedLongPeriod_adaptive := 180
        detectedLongSlope_adaptive := slope11_adaptive
        detectedLongIntercept_adaptive := int11_adaptive
        detectedLongStdDev_adaptive := stdDev11_adaptive
        detectedLongPearson_adaptive := pr11_adaptive
    else if highestLong_adaptive == pr12_adaptive
        detectedLongPeriod_adaptive := 200
        detectedLongSlope_adaptive := slope12_adaptive
        detectedLongIntercept_adaptive := int12_adaptive
        detectedLongStdDev_adaptive := stdDev12_adaptive
        detectedLongPearson_adaptive := pr12_adaptive
    else if highestLong_adaptive == pr13_adaptive
        detectedLongPeriod_adaptive := 220
        detectedLongSlope_adaptive := slope13_adaptive
        detectedLongIntercept_adaptive := int13_adaptive
        detectedLongStdDev_adaptive := stdDev13_adaptive
        detectedLongPearson_adaptive := pr13_adaptive
    else if highestLong_adaptive == pr14_adaptive
        detectedLongPeriod_adaptive := 250
        detectedLongSlope_adaptive := slope14_adaptive
        detectedLongIntercept_adaptive := int14_adaptive
        detectedLongStdDev_adaptive := stdDev14_adaptive
        detectedLongPearson_adaptive := pr14_adaptive
    else if highestLong_adaptive == pr15_adaptive
        detectedLongPeriod_adaptive := 280
        detectedLongSlope_adaptive := slope15_adaptive
        detectedLongIntercept_adaptive := int15_adaptive
        detectedLongStdDev_adaptive := stdDev15_adaptive
        detectedLongPearson_adaptive := pr15_adaptive
    else if highestLong_adaptive == pr16_adaptive
        detectedLongPeriod_adaptive := 310
        detectedLongSlope_adaptive := slope16_adaptive
        detectedLongIntercept_adaptive := int16_adaptive
        detectedLongStdDev_adaptive := stdDev16_adaptive
        detectedLongPearson_adaptive := pr16_adaptive
    else if highestLong_adaptive == pr17_adaptive
        detectedLongPeriod_adaptive := 340
        detectedLongSlope_adaptive := slope17_adaptive
        detectedLongIntercept_adaptive := int17_adaptive
        detectedLongStdDev_adaptive := stdDev17_adaptive
        detectedLongPearson_adaptive := pr17_adaptive
    else if highestLong_adaptive == pr18_adaptive
        detectedLongPeriod_adaptive := 370
        detectedLongSlope_adaptive := slope18_adaptive
        detectedLongIntercept_adaptive := int18_adaptive
        detectedLongStdDev_adaptive := stdDev18_adaptive
        detectedLongPearson_adaptive := pr18_adaptive
    else
        detectedLongPeriod_adaptive := 400
        detectedLongSlope_adaptive := slope19_adaptive
        detectedLongIntercept_adaptive := int19_adaptive
        detectedLongStdDev_adaptive := stdDev19_adaptive
        detectedLongPearson_adaptive := pr19_adaptive
finalPeriod_adaptive = useAdaptive_adaptive ? detectedLongPeriod_adaptive : pI_adaptive


eS_adaptive = extend.right
lI_adaptive = math.min(bar_index + 1, finalPeriod_adaptive)

formatNumber_adaptive(num_adaptive) =>
    if num_adaptive >= 1000000
        str.tostring(math.round(num_adaptive / 1000000, 2)) + 'M'
    else if num_adaptive >= 1000
        str.tostring(math.round(num_adaptive / 1000, 2)) + 'K'
    else
        str.tostring(num_adaptive)

f_adjust_adaptive(p_adaptive) =>
    uL_adaptive ? math.log(p_adaptive) : p_adaptive

f_unadjust_adaptive(p_adaptive) =>
    uL_adaptive ? math.exp(p_adaptive) : p_adaptive

cS_adaptive(len_adaptive) =>
    if not barstate.islast or len_adaptive <= 1
        [float(na), float(na), float(na)]
    else
        sX_adaptive = 0.0
        sY_adaptive = 0.0
        sXS_adaptive = 0.0
        sXY_adaptive = 0.0
        for i_adaptive = 0 to len_adaptive - 1 by 1
            v_adaptive = f_adjust_adaptive(close[i_adaptive])
            p_adaptive = i_adaptive + 1.0
            sX_adaptive := sX_adaptive + p_adaptive
            sY_adaptive := sY_adaptive + v_adaptive
            sXS_adaptive := sXS_adaptive + p_adaptive * p_adaptive
            sXY_adaptive := sXY_adaptive + v_adaptive * p_adaptive
            sXY_adaptive
        sl_adaptive = (len_adaptive * sXY_adaptive - sX_adaptive * sY_adaptive) / (len_adaptive * sXS_adaptive - sX_adaptive * sX_adaptive)
        av_adaptive = sY_adaptive / len_adaptive
        ic_adaptive = av_adaptive - sl_adaptive * sX_adaptive / len_adaptive + sl_adaptive
        [sl_adaptive, av_adaptive, ic_adaptive]


[s_adaptive, a_adaptive, i_adaptive] = cS_adaptive(lI_adaptive)
sP_adaptive = f_unadjust_adaptive(i_adaptive + s_adaptive * (lI_adaptive - 1))
eP_adaptive = f_unadjust_adaptive(i_adaptive)

var float uSP_adaptive = na
var float uEP_adaptive = na
var float lSP_adaptive = na
var float lEP_adaptive = na
var line bL_adaptive = na

if showRegLine_adaptive
    if na(bL_adaptive) and not na(sP_adaptive)
        bL_adaptive := line.new(bar_index - lI_adaptive + 1, sP_adaptive, bar_index, eP_adaptive, width = regLineWidthOpt_adaptive, extend = eS_adaptive, color = regLineColor_adaptive, style = regLineStyleOpt_adaptive == 'Solid' ? line.style_solid : regLineStyleOpt_adaptive == 'Dotted' ? line.style_dotted : line.style_dashed)
        bL_adaptive
    else
        line.set_xy1(bL_adaptive, bar_index - lI_adaptive + 1, sP_adaptive)
        line.set_xy2(bL_adaptive, bar_index, eP_adaptive)
        line.set_color(bL_adaptive, regLineColor_adaptive)
        line.set_style(bL_adaptive, regLineStyleOpt_adaptive == 'Solid' ? line.style_solid : regLineStyleOpt_adaptive == 'Dotted' ? line.style_dotted : line.style_dashed)
        line.set_width(bL_adaptive, regLineWidthOpt_adaptive)
else
    line.delete(bL_adaptive)


cD_adaptive(len_adaptive, sl_adaptive, av_adaptive, ic_adaptive) =>
    uD_adaptive = 0.0
    dD_adaptive = 0.0
    sDA_adaptive = 0.0
    dxx_adaptive = 0.0
    dyy_adaptive = 0.0
    dxy_adaptive = 0.0
    per_adaptive = len_adaptive - 1
    dY_adaptive = ic_adaptive + sl_adaptive * per_adaptive / 2
    v_adaptive = ic_adaptive
    for j_adaptive = 0 to per_adaptive by 1
        pr_adaptive = f_adjust_adaptive(high[j_adaptive]) - v_adaptive
        if pr_adaptive > uD_adaptive
            uD_adaptive := pr_adaptive
            uD_adaptive
        pr_adaptive := v_adaptive - f_adjust_adaptive(low[j_adaptive])
        if pr_adaptive > dD_adaptive
            dD_adaptive := pr_adaptive
            dD_adaptive
        pr_adaptive := f_adjust_adaptive(close[j_adaptive])
        dx_adaptive = pr_adaptive - av_adaptive
        dy_adaptive = v_adaptive - dY_adaptive
        pr_adaptive := pr_adaptive - v_adaptive
        sDA_adaptive := sDA_adaptive + pr_adaptive * pr_adaptive
        dxx_adaptive := dxx_adaptive + dx_adaptive * dx_adaptive
        dyy_adaptive := dyy_adaptive + dy_adaptive * dy_adaptive
        dxy_adaptive := dxy_adaptive + dx_adaptive * dy_adaptive
        v_adaptive := v_adaptive + sl_adaptive
        v_adaptive
    sD_adaptive = math.sqrt(sDA_adaptive / (per_adaptive == 0 ? 1 : per_adaptive))
    pR_adaptive = dxx_adaptive == 0 or dyy_adaptive == 0 ? 0 : dxy_adaptive / math.sqrt(dxx_adaptive * dyy_adaptive)
    [sD_adaptive, pR_adaptive, uD_adaptive, dD_adaptive]

[sD_adaptive, pR_adaptive, uD_adaptive, dD_adaptive] = cD_adaptive(lI_adaptive, s_adaptive, a_adaptive, i_adaptive)

applyDeviation_adaptive(baseValue_adaptive, deviation_adaptive) =>
    f_unadjust_adaptive(f_adjust_adaptive(baseValue_adaptive) + deviation_adaptive)

uSP_adaptive := applyDeviation_adaptive(sP_adaptive, devMultiplier_adaptive * sD_adaptive)
uEP_adaptive := applyDeviation_adaptive(eP_adaptive, devMultiplier_adaptive * sD_adaptive)
lSP_adaptive := applyDeviation_adaptive(sP_adaptive, -devMultiplier_adaptive * sD_adaptive)
lEP_adaptive := applyDeviation_adaptive(eP_adaptive, -devMultiplier_adaptive * sD_adaptive)

var line u_adaptive = na
var line l_adaptive = na

if na(u_adaptive) and not na(uSP_adaptive)
    u_adaptive := line.new(bar_index - lI_adaptive + 1, uSP_adaptive, bar_index, uEP_adaptive, width = regLineWidth_adaptive, extend = eS_adaptive, color = regColor_adaptive, style = regLineStyle_adaptive == 'Solid' ? line.style_solid : regLineStyle_adaptive == 'Dotted' ? line.style_dotted : line.style_dashed)
    u_adaptive
else
    line.set_xy1(u_adaptive, bar_index - lI_adaptive + 1, uSP_adaptive)
    line.set_xy2(u_adaptive, bar_index, uEP_adaptive)
    line.set_color(u_adaptive, regColor_adaptive)
    line.set_style(u_adaptive, regLineStyle_adaptive == 'Solid' ? line.style_solid : regLineStyle_adaptive == 'Dotted' ? line.style_dotted : line.style_dashed)
    line.set_width(u_adaptive, regLineWidth_adaptive)

if na(l_adaptive) and not na(lSP_adaptive)
    l_adaptive := line.new(bar_index - lI_adaptive + 1, lSP_adaptive, bar_index, lEP_adaptive, width = regLineWidth_adaptive, extend = eS_adaptive, color = regColor_adaptive, style = regLineStyle_adaptive == 'Solid' ? line.style_solid : regLineStyle_adaptive == 'Dotted' ? line.style_dotted : line.style_dashed)
    l_adaptive
else
    line.set_xy1(l_adaptive, bar_index - lI_adaptive + 1, lSP_adaptive)
    line.set_xy2(l_adaptive, bar_index, lEP_adaptive)
    line.set_color(l_adaptive, regColor_adaptive)
    line.set_style(l_adaptive, regLineStyle_adaptive == 'Solid' ? line.style_solid : regLineStyle_adaptive == 'Dotted' ? line.style_dotted : line.style_dashed)
    line.set_width(l_adaptive, regLineWidth_adaptive)

linefill.new(u_adaptive, showRegLine_adaptive ? bL_adaptive : l_adaptive, color = fillColor_adaptive)
if showRegLine_adaptive
    linefill.new(bL_adaptive, l_adaptive, color = fillColor_adaptive)

var label pL_adaptive = na
label.delete(pL_adaptive[1])
if not na(pR_adaptive)
    pL_adaptive := label.new(bar_index - lI_adaptive + 1, lSP_adaptive, str.tostring(pR_adaptive, '#.###'), color = color.new(color.white, 100), textcolor = color.gray, size = size.normal, style = label.style_label_up)
    pL_adaptive

calcLineValue_adaptive(startY_adaptive, endY_adaptive, currentBar_adaptive, totalBars_adaptive) =>
    f_unadjust_adaptive(f_adjust_adaptive(startY_adaptive) + (f_adjust_adaptive(endY_adaptive) - f_adjust_adaptive(startY_adaptive)) * currentBar_adaptive / totalBars_adaptive)

color_from_gradient_adaptive(percent_adaptive, color1_adaptive, color2_adaptive) =>
    r_adaptive = color.r(color1_adaptive) + (color.r(color2_adaptive) - color.r(color1_adaptive)) * percent_adaptive
    g_adaptive = color.g(color1_adaptive) + (color.g(color2_adaptive) - color.g(color1_adaptive)) * percent_adaptive
    b_adaptive = color.b(color1_adaptive) + (color.b(color2_adaptive) - color.b(color1_adaptive)) * percent_adaptive
    t_adaptive = color.t(color1_adaptive) + (color.t(color2_adaptive) - color.t(color1_adaptive)) * percent_adaptive
    color.rgb(r_adaptive, g_adaptive, b_adaptive, t_adaptive)

var counts_adaptive = array.new_float(nFills_adaptive, 0.0)
var activityLines_adaptive = array.new_line(numActivityLines_adaptive)
var profileFills_adaptive = array.new_linefill(nFills_adaptive)
var countLabels_adaptive = array.new_label(numActivityLines_adaptive)


if barstate.islast
    array.clear(counts_adaptive)

    for actLine_adaptive in activityLines_adaptive
        line.delete(actLine_adaptive)
    array.clear(activityLines_adaptive)

    for cl_adaptive in countLabels_adaptive
        label.delete(cl_adaptive)
    array.clear(countLabels_adaptive)

    for pf_adaptive in profileFills_adaptive
        linefill.delete(pf_adaptive)
    array.clear(profileFills_adaptive)

    for idx1_adaptive = 0 to nFills_adaptive - 1 by 1
        y1_top_adaptive = calcLineValue_adaptive(lSP_adaptive, uSP_adaptive, idx1_adaptive, nFills_adaptive)
        y1_bottom_adaptive = calcLineValue_adaptive(lSP_adaptive, uSP_adaptive, idx1_adaptive + 1, nFills_adaptive)
        y2_top_adaptive = calcLineValue_adaptive(lEP_adaptive, uEP_adaptive, idx1_adaptive, nFills_adaptive)
        y2_bottom_adaptive = calcLineValue_adaptive(lEP_adaptive, uEP_adaptive, idx1_adaptive + 1, nFills_adaptive)
        y1_mid_adaptive = (y1_top_adaptive + y1_bottom_adaptive) / 2
        y2_mid_adaptive = (y2_top_adaptive + y2_bottom_adaptive) / 2
        count_adaptive = 0.0

        for j_adaptive = 0 to lI_adaptive - 1 by 1
            lineValue_adaptive = calcLineValue_adaptive(y1_mid_adaptive, y2_mid_adaptive, j_adaptive, lI_adaptive - 1)
            if activityMethod_adaptive == 'Touches'
                if low[lI_adaptive - 1 - j_adaptive] <= lineValue_adaptive and high[lI_adaptive - 1 - j_adaptive] >= lineValue_adaptive
                    count_adaptive := count_adaptive + 1.0
                    count_adaptive
            else
                if low[lI_adaptive - 1 - j_adaptive] <= lineValue_adaptive and high[lI_adaptive - 1 - j_adaptive] >= lineValue_adaptive
                    count_adaptive := count_adaptive + volume[lI_adaptive - 1 - j_adaptive]
                    count_adaptive
        array.push(counts_adaptive, count_adaptive)

    maxCount_adaptive = array.max(counts_adaptive)
    sortedIndices_adaptive = array.sort_indices(counts_adaptive, order.descending)
    var float activitySlope_adaptive = 0.0
    minActivityThreshold_adaptive = maxCount_adaptive * 0.1
    displayedActivityLines_adaptive = 0


    index_adaptive = array.get(sortedIndices_adaptive, 0)
    actY1_adaptive = calcLineValue_adaptive(lSP_adaptive, uSP_adaptive, index_adaptive + 0.5, nFills_adaptive)
    actY2_adaptive = calcLineValue_adaptive(lEP_adaptive, uEP_adaptive, index_adaptive + 0.5, nFills_adaptive)
    activitySlope_adaptive := (f_adjust_adaptive(actY2_adaptive) - f_adjust_adaptive(actY1_adaptive)) / (bar_index - (bar_index - lI_adaptive + 1))

    if showMostActiveLines_adaptive
        for idx2_adaptive = 0 to nFills_adaptive - 1 by 1
            if displayedActivityLines_adaptive >= numActivityLines_adaptive
                break
            index_adaptive := array.get(sortedIndices_adaptive, idx2_adaptive)
            count_adaptive = array.get(counts_adaptive, index_adaptive)
            if count_adaptive >= minActivityThreshold_adaptive
                actY1_adaptive := calcLineValue_adaptive(lSP_adaptive, uSP_adaptive, index_adaptive + 0.5, nFills_adaptive)
                actY2_adaptive := calcLineValue_adaptive(lEP_adaptive, uEP_adaptive, index_adaptive + 0.5, nFills_adaptive)
                percent_adaptive = count_adaptive / maxCount_adaptive
                lineColor_adaptive = useCustomColor_adaptive ? customColor_adaptive : color_from_gradient_adaptive(percent_adaptive, loActColor_adaptive, hiActColor_adaptive)
                lineStyle_adaptive = actLineStyle_adaptive == 'Solid' ? line.style_solid : actLineStyle_adaptive == 'Dotted' ? line.style_dotted : line.style_dashed
                startX_adaptive = showProfile_adaptive ? math.min(bar_index, bar_index - lI_adaptive + 1 + math.round(count_adaptive / maxCount_adaptive * math.round(lI_adaptive / 5))) : bar_index - lI_adaptive + 1
                startY_adaptive = showProfile_adaptive ? f_unadjust_adaptive(f_adjust_adaptive(actY1_adaptive) + activitySlope_adaptive * (startX_adaptive - (bar_index - lI_adaptive + 1))) : actY1_adaptive
                actLine_adaptive = line.new(startX_adaptive, startY_adaptive, bar_index, actY2_adaptive, color = lineColor_adaptive, width = actLineWidth_adaptive, style = lineStyle_adaptive, extend = extend.right)
                array.push(activityLines_adaptive, actLine_adaptive)

                if showLabels_adaptive
                    labelOffsetX_adaptive = 5
                    labelOffsetY_adaptive = activitySlope_adaptive * labelOffsetX_adaptive
                    labelX_adaptive = bar_index + labelOffsetX_adaptive
                    labelY_adaptive = f_unadjust_adaptive(f_adjust_adaptive(actY2_adaptive) + labelOffsetY_adaptive)
                    countLabel_adaptive = label.new(x = labelX_adaptive, y = labelY_adaptive, text = formatNumber_adaptive(count_adaptive), color = color.new(color.white, 100), textcolor = lineColor_adaptive, size = size.small, style = label.style_label_left)
                    array.push(countLabels_adaptive, countLabel_adaptive)

                displayedActivityLines_adaptive := displayedActivityLines_adaptive + 1
                displayedActivityLines_adaptive


    if showProfile_adaptive
        profileLength_adaptive = math.round(lI_adaptive / 5)
        sortedProfileIndices_adaptive = array.sort_indices(counts_adaptive, order.descending)
        for idx3_adaptive = 0 to effectiveProfileBars_adaptive - 1 by 1
            profileIndex_adaptive = array.get(sortedProfileIndices_adaptive, idx3_adaptive)
            y1_top_adaptive = calcLineValue_adaptive(lSP_adaptive, uSP_adaptive, profileIndex_adaptive, nFills_adaptive)
            y1_bottom_adaptive = calcLineValue_adaptive(lSP_adaptive, uSP_adaptive, profileIndex_adaptive + 1, nFills_adaptive)
            y2_top_adaptive = calcLineValue_adaptive(lEP_adaptive, uEP_adaptive, profileIndex_adaptive, nFills_adaptive)
            y2_bottom_adaptive = calcLineValue_adaptive(lEP_adaptive, uEP_adaptive, profileIndex_adaptive + 1, nFills_adaptive)
            count_adaptive = array.get(counts_adaptive, profileIndex_adaptive)
            percent_adaptive = count_adaptive / maxCount_adaptive
            fillColor_adaptive := color_from_gradient_adaptive(percent_adaptive, loActColor_adaptive, hiActColor_adaptive)
            lineLength_adaptive = math.round(count_adaptive / maxCount_adaptive * profileLength_adaptive)
            x2_adaptive = math.min(bar_index, bar_index - lI_adaptive + 1 + lineLength_adaptive)
            topLine_adaptive = line.new(bar_index - lI_adaptive + 1, y1_top_adaptive, x2_adaptive, f_unadjust_adaptive(f_adjust_adaptive(y1_top_adaptive) + activitySlope_adaptive * lineLength_adaptive), color = color.new(fillColor_adaptive, 100))
            bottomLine_adaptive = line.new(bar_index - lI_adaptive + 1, y1_bottom_adaptive, x2_adaptive, f_unadjust_adaptive(f_adjust_adaptive(y1_bottom_adaptive) + activitySlope_adaptive * lineLength_adaptive), color = color.new(fillColor_adaptive, 100))
            profileFill_adaptive = linefill.new(topLine_adaptive, bottomLine_adaptive, color = fillColor_adaptive)
            array.push(profileFills_adaptive, profileFill_adaptive)










// This work is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License (CC BY-NC-SA 4.0) https://creativecommons.org/licenses/by-nc-sa/4.0/
// ¬© Trendoscope Pty Ltd, Trendoscope¬Æ
//                                       ‚ñë‚ñí             
//                                  ‚ñí‚ñí‚ñí   ‚ñí‚ñí      
//                              ‚ñí‚ñí‚ñí‚ñí‚ñí     ‚ñí‚ñí      
//                      ‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñë     ‚ñí     ‚ñí‚ñí          
//                  ‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí           ‚ñí     ‚ñí‚ñí          
//             ‚ñì‚ñí‚ñí‚ñí       ‚ñí        ‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí  
//   ‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí ‚ñí        ‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí         
//   ‚ñí  ‚ñí       ‚ñë‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñë        
//   ‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñë‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí         
//   ‚ñì‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí ‚ñí‚ñí                       
//    ‚ñí‚ñí‚ñí‚ñí‚ñí         ‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí                            
//                 ‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí                           
//                ‚ñí‚ñí‚ñí‚ñí‚ñí ‚ñí‚ñí‚ñí‚ñí‚ñí                          
//               ‚ñë‚ñí‚ñí‚ñí‚ñí   ‚ñí‚ñí‚ñí‚ñí‚ñì      ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó
//              ‚ñì‚ñí‚ñí‚ñí‚ñí     ‚ñí‚ñí‚ñí‚ñí      ‚ïö‚ïê‚ïê‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù
//              ‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí        ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïî‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó 
//             ‚ñí‚ñí‚ñí‚ñí‚ñí       ‚ñí‚ñí‚ñí‚ñí‚ñí       ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïù ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  
//            ‚ñí‚ñí‚ñí‚ñí‚ñí         ‚ñí‚ñí‚ñí‚ñí‚ñí      ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó
//             ‚ñí‚ñí             ‚ñí                        
////@version=6
import Trendoscope/Drawing/2 as dr_wave_scanner
import Trendoscope/Zigzag/10 as zg_wave_scanner
import Trendoscope/utils/2 as ut_wave_scanner
import Trendoscope/Waves/3 as w_wave_scanner

//indicator('Motive Wave Scanner [Trendoscope¬Æ]', 'MW[Trendoscope¬Æ]', overlay = true, max_lines_count = 500, max_labels_count = 500, max_bars_back = 1000)
theme = input.enum(ut_wave_scanner.Theme.DARK, title = 'Theme', group = 'Generic Settings', tooltip = 'Chart theme settings. Line and label colors are generted based on the theme settings. If dark theme is selected, ' + 'lighter colors are used and if light theme is selected, darker colors are used.', display = display.none)

zigzagLength_wave_scanner = input.int(5, step = 5, minval = 3, title = 'Length', group = 'Zigzag', tooltip = 'Zigzag length for level 0 zigzag', display = display.none)
depth_wave_scanner = input.int(200, 'Depth', step = 25, maxval = 500, group = 'Zigzag', tooltip = 'Max number of zigzag swings to consider for recursive calculation', display = display.none)

levelType = input.string('Minimum', 'Level', ['Minimum', 'Absolute'], group = 'Waves', inline = 'l', display = display.none)
level = input.int(1, '', group = 'Waves', minval = 1, inline = 'l', tooltip = 'Zigzag Level to consider for scanning waves', display = display.none)
limitSubwaves = input.bool(true, 'Draw only first subwave', group = 'Waves', tooltip = 'If there are multiple subwave combinations, draw only the first so that chart will look cleaner', display = display.none)
repaint = input.bool(true, 'Rapaint', group = 'Waves', inline = 'r', display = display.none, tooltip = 'If selected, waves are identified immediately, but the formations can repaint. If repaint is not selected,  then the waves are only presented after the confirmation. This means, there may be delay in printing the formation. Please note that, due to some internal pine issues, if repaint is selected, the indicator may throw some runtime error when running through the alerts')

useRealTimeBars = true

allowedTypes = array.from(w_wave_scanner.WaveType.ContractingDiagonal, w_wave_scanner.WaveType.ExpandingDiagonal, w_wave_scanner.WaveType.ImpulseWave)
offset_wave_scanner = useRealTimeBars ? 0 : 1

indicators = matrix.new<float>()
indicatorNames = array.new<string>()

var themeColors = theme.getColors()
var zg_wave_scanner.Zigzag zigzag = zg_wave_scanner.Zigzag.new(zigzagLength_wave_scanner, depth_wave_scanner, offset_wave_scanner)
zigzag.calculate(array.from(high, low), indicators, indicatorNames)

var array<w_wave_scanner.Wave> motiveWaves = array.new<w_wave_scanner.Wave>()

if zigzag.flags.newPivot and (repaint or not zigzag.flags.updateLastPivot)
    mlzigzag = zigzag
    rowNum = 0
    while mlzigzag.zigzagPivots.size() >= (repaint ? 3 : 4)
        if levelType == 'Minimum' ? mlzigzag.level >= level : mlzigzag.level == level
            pivot = repaint ? mlzigzag.zigzagPivots.first() : mlzigzag.zigzagPivots.get(1)
            lastPivot = repaint ? mlzigzag.zigzagPivots.get(1) : mlzigzag.zigzagPivots.get(2)
            llastPivot = repaint ? mlzigzag.zigzagPivots.get(2) : mlzigzag.zigzagPivots.get(3)

            motiveSubwaveIndices = lastPivot.scanMotiveWave(llastPivot, motiveWaves, allowedTypes)
            if motiveSubwaveIndices.size() > 0
                alert('New Motive wave detected')
                if barstate.islast and barstate.isrealtime
                    log.info('New ImpuMotivelse wave detected')
                labelColor = themeColors.shift()
                themeColors.push(labelColor)

                motiveWave = lastPivot.createWave(labelColor, motiveWaves).createSubWaves(motiveSubwaveIndices).draw(limitSubwaves)
                motiveWave
        mlzigzag := mlzigzag.nextlevel()
        rowNum := rowNum + 1
        rowNum




// This Pine Script¬Æ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// ¬© WhiteStone_Ibrahim

//@version=6
//indicator('Ultimate Regression Channel v5.0 [WhiteStone_Ibrahim]', overlay = true, max_bars_back = 1000)

// --- INPUTS (Restructured) ---
string grp_channel = '1. Basic Channel Settings'
// --- GROUP 1: Length and Model ---
string length_mode = input.string('Numerical (Manual)', 'Length Mode', options = ['Numerical (Manual)', 'Automatic (Based on Market Structure)'], group = grp_channel, inline = 'g1')
int manual_length = input.int(200, 'Manual Length', group = grp_channel, minval = 10, inline = 'g1')
string model_type = input.string('Logarithmic', 'Regression Model', options = ['Logarithmic', 'Linear'], group = grp_channel)
int auto_scan_period = input.int(300, 'Auto Scan Period', group = grp_channel, minval = 20, tooltip = 'Determines how far back the automatic mode will look to find the highest/lowest point.')
// --- GROUP 2: Channel Widths ---
float channel_width_0 = input.float(0.5, '0 (Inner)', step = 0.1, group = grp_channel, minval = 0, inline = 'g2_w')
float channel_width_1 = input.float(1.0, '1 (Middle)', step = 0.1, group = grp_channel, minval = 0, inline = 'g2_w')
float channel_width_2 = input.float(1.5, '2 (Outer)', step = 0.1, group = grp_channel, minval = 0, inline = 'g2_w')

string grp_line = '2. Line Appearance Settings'
// --- Center Line ---
bool mid_disp = input.bool(true, 'Center Line', group = grp_line, inline = 'mid')
color col_mid = input.color(color.new(#d8dcec, 0), '', group = grp_line, inline = 'mid')
int width_mid = input.int(2, 'Thickness', minval = 1, group = grp_line, inline = 'mid')
string style_mid = input.string(line.style_dashed, 'Style', options = [line.style_solid, line.style_dashed, line.style_dotted], group = grp_line, inline = 'mid')
// --- Inner Channels ---
color col_up0 = input.color(color.new(color.orange, 80), 'Inner Channel | Upper Color', group = grp_line, inline = 'ch0c')
color col_low0 = input.color(color.new(color.orange, 80), 'Lower Color', group = grp_line, inline = 'ch0c')
int width_ch0 = input.int(2, '           | Thickness', minval = 1, group = grp_line, inline = 'ch0p')
string style_ch0 = input.string(line.style_solid, 'Style', options = [line.style_solid, line.style_dashed, line.style_dotted], group = grp_line, inline = 'ch0p')
// --- Middle Channels ---
color col_up1 = input.color(color.new(color.white, 80), 'Middle Channel | Upper Color', group = grp_line, inline = 'ch1c')
color col_low1 = input.color(color.new(color.white, 80), 'Lower Color', group = grp_line, inline = 'ch1c')
int width_ch1 = input.int(2, '           | Thickness', minval = 1, group = grp_line, inline = 'ch1p')
string style_ch1 = input.string(line.style_solid, 'Style', options = [line.style_solid, line.style_dashed, line.style_dotted], group = grp_line, inline = 'ch1p')
// --- Outer Channels ---
color col_up2 = input.color(color.new(color.blue, 20), 'Outer Channel  | Upper Color', group = grp_line, inline = 'ch2c')
color col_low2 = input.color(color.new(color.blue, 20), 'Lower Color', group = grp_line, inline = 'ch2c')
int width_ch2 = input.int(2, '           | Thickness', minval = 1, group = grp_line, inline = 'ch2p')
string style_ch2 = input.string(line.style_solid, 'Style', options = [line.style_solid, line.style_dashed, line.style_dotted], group = grp_line, inline = 'ch2p')

string grp_extras = '3. Visual Extras'
// --- GROUP 1: Fills and Breakout ---
bool fill_ch01 = input.bool(true, 'Fill Inner-Middle', group = grp_extras, inline = 'g3_f')
bool fill_ch12 = input.bool(true, 'Fill Middle-Outer', group = grp_extras, inline = 'g3_f')
string breakout_style = input.string('Arrow Mark', 'Breakout Style', options = ['Arrow Mark', 'Background Color', 'Off'], group = grp_extras)
// --- GROUP 2: Info Label ---
bool show_label = input.bool(false, 'Info Label', group = grp_extras, inline = 'g3_l')
float horizontal_threshold = input.float(0.0, 'Horizontal Threshold', group = grp_extras, step = 0.00001, inline = 'g3_l')
string label_color_mode = input.string('Dynamic by Trend', 'Label Color', options = ['Dynamic by Trend', 'Fixed Color'], group = grp_extras, inline = 'g3_lc')
color label_bg_color = input.color(color.new(color.gray, 20), '', group = grp_extras, inline = 'g3_lc')
color label_text_color = input.color(color.new(color.white, 0), 'Text Color', group = grp_extras, inline = 'g3_lt')
string label_size = input.string(size.normal, 'Size', options = [size.tiny, size.small, size.normal, size.large, size.huge], group = grp_extras, inline = 'g3_lt')
int label_x_offset = input.int(10, 'Offset', group = grp_extras, inline = 'g3_lt')

string grp_alert = '4. Alert Settings'
string alert_source = input.string('Outer Channels', 'Alert Source', options = ['Off', 'Any Line', 'Outer Channels', 'Middle Channels', 'Inner Channels', 'Center Line'], group = grp_alert)

// --- CALCULATION FUNCTIONS (No changes) ---
f_lin_regression(src, length) =>
    float sumX = 0.0
    float sumY = 0.0
    float sumXSqr = 0.0
    float sumXY = 0.0
    float slope = na
    float intercept = na
    for i = 0 to length - 1 by 1
        val = src[i]
        per = i + 1.0
        sumX := sumX + per
        sumY := sumY + val
        sumXSqr := sumXSqr + per * per
        sumXY := sumXY + val * per
        sumXY
    denominator = length * sumXSqr - sumX * sumX
    if denominator != 0
        slope := (length * sumXY - sumX * sumY) / denominator
        intercept := (sumY - slope * sumX) / length
        intercept
    [slope, intercept]
f_log_regression(src, length) =>
    float sumX = 0.0
    float sumY = 0.0
    float sumXSqr = 0.0
    float sumXY = 0.0
    float slope = na
    float intercept = na
    for i = 0 to length - 1 by 1
        val = math.log(src[i])
        per = i + 1.0
        sumX := sumX + per
        sumY := sumY + val
        sumXSqr := sumXSqr + per * per
        sumXY := sumXY + val * per
        sumXY
    denominator = length * sumXSqr - sumX * sumX
    if denominator != 0
        slope := (length * sumXY - sumX * sumY) / denominator
        intercept := (sumY - slope * sumX) / length
        intercept
    [slope, intercept]

// --- MAIN CALCULATION BLOCK (No changes) ---
bars_since_high = ta.highestbars(high, auto_scan_period)
bars_since_low = ta.lowestbars(low, auto_scan_period)
auto_length = nz(math.max(bars_since_high, bars_since_low)) + 1
auto_length := math.max(auto_length, auto_scan_period)
final_length = length_mode == 'Numerical (Manual)' ? manual_length : auto_length

var color plot_bgcolor = na
var float plot_up_arrow = na
var float plot_down_arrow = na

if bar_index >= final_length - 1
    float slope = na
    float intercept = na
    float reg_start = na
    float reg_end = na
    if model_type == 'Logarithmic'
        [l_slope, l_intercept] = f_log_regression(close, final_length)
        slope := l_slope
        intercept := l_intercept
        reg_start := na(intercept) ? na : math.exp(intercept + slope * final_length)
        reg_end := na(intercept) ? na : math.exp(intercept)
        reg_end
    else
        [l_slope, l_intercept] = f_lin_regression(close, final_length)
        slope := l_slope
        intercept := l_intercept
        reg_start := na(intercept) ? na : intercept + slope * final_length
        reg_end := na(intercept) ? na : intercept
        reg_end

    if not na(reg_end)
        float deviation = ta.stdev(close, final_length)
        float upper0_start = reg_start + deviation * channel_width_0
        float upper0_end = reg_end + deviation * channel_width_0
        float lower0_start = reg_start - deviation * channel_width_0
        float lower0_end = reg_end - deviation * channel_width_0
        float upper1_start = reg_start + deviation * channel_width_1
        float upper1_end = reg_end + deviation * channel_width_1
        float lower1_start = reg_start - deviation * channel_width_1
        float lower1_end = reg_end - deviation * channel_width_1
        float upper2_start = reg_start + deviation * channel_width_2
        float upper2_end = reg_end + deviation * channel_width_2
        float lower2_start = reg_start - deviation * channel_width_2
        float lower2_end = reg_end - deviation * channel_width_2

        var line mid_line = na
        var line upper_line0 = na
        var line lower_line0 = na
        var line upper_line1 = na
        var line lower_line1 = na
        var line upper_line2 = na
        var line lower_line2 = na

        if mid_disp
            if na(mid_line)
                mid_line := line.new(bar_index[final_length - 1], reg_start, bar_index, reg_end, color = col_mid, style = style_mid, width = width_mid)
                mid_line
            else
                line.set_xy1(mid_line, bar_index[final_length - 1], reg_start)
                line.set_xy2(mid_line, bar_index, reg_end)
                line.set_color(mid_line, col_mid)
                line.set_width(mid_line, width_mid)
                line.set_style(mid_line, style_mid)
        else
            line.delete(mid_line)

        if na(upper_line0)
            upper_line0 := line.new(bar_index[final_length - 1], upper0_start, bar_index, upper0_end, width = width_ch0, color = col_up0, style = style_ch0)
            upper_line0
        else
            line.set_xy1(upper_line0, bar_index[final_length - 1], upper0_start)
            line.set_xy2(upper_line0, bar_index, upper0_end)
            line.set_color(upper_line0, col_up0)
            line.set_width(upper_line0, width_ch0)
            line.set_style(upper_line0, style_ch0)
        if na(lower_line0)
            lower_line0 := line.new(bar_index[final_length - 1], lower0_start, bar_index, lower0_end, width = width_ch0, color = col_low0, style = style_ch0)
            lower_line0
        else
            line.set_xy1(lower_line0, bar_index[final_length - 1], lower0_start)
            line.set_xy2(lower_line0, bar_index, lower0_end)
            line.set_color(lower_line0, col_low0)
            line.set_width(lower_line0, width_ch0)
            line.set_style(lower_line0, style_ch0)

        if na(upper_line1)
            upper_line1 := line.new(bar_index[final_length - 1], upper1_start, bar_index, upper1_end, width = width_ch1, color = col_up1, style = style_ch1)
            upper_line1
        else
            line.set_xy1(upper_line1, bar_index[final_length - 1], upper1_start)
            line.set_xy2(upper_line1, bar_index, upper1_end)
            line.set_color(upper_line1, col_up1)
            line.set_width(upper_line1, width_ch1)
            line.set_style(upper_line1, style_ch1)
        if na(lower_line1)
            lower_line1 := line.new(bar_index[final_length - 1], lower1_start, bar_index, lower1_end, width = width_ch1, color = col_low1, style = style_ch1)
            lower_line1
        else
            line.set_xy1(lower_line1, bar_index[final_length - 1], lower1_start)
            line.set_xy2(lower_line1, bar_index, lower1_end)
            line.set_color(lower_line1, col_low1)
            line.set_width(lower_line1, width_ch1)
            line.set_style(lower_line1, style_ch1)

        if na(upper_line2)
            upper_line2 := line.new(bar_index[final_length - 1], upper2_start, bar_index, upper2_end, width = width_ch2, color = col_up2, style = style_ch2)
            upper_line2
        else
            line.set_xy1(upper_line2, bar_index[final_length - 1], upper2_start)
            line.set_xy2(upper_line2, bar_index, upper2_end)
            line.set_color(upper_line2, col_up2)
            line.set_width(upper_line2, width_ch2)
            line.set_style(upper_line2, style_ch2)
        if na(lower_line2)
            lower_line2 := line.new(bar_index[final_length - 1], lower2_start, bar_index, lower2_end, width = width_ch2, color = col_low2, style = style_ch2)
            lower_line2
        else
            line.set_xy1(lower_line2, bar_index[final_length - 1], lower2_start)
            line.set_xy2(lower_line2, bar_index, lower2_end)
            line.set_color(lower_line2, col_low2)
            line.set_width(lower_line2, width_ch2)
            line.set_style(lower_line2, style_ch2)

        if fill_ch01
            linefill.new(upper_line1, upper_line0, color.new(col_up1, 85))
            linefill.new(lower_line1, lower_line0, color.new(col_low1, 85))
        if fill_ch12
            linefill.new(upper_line2, upper_line1, color.new(col_up2, 90))
            linefill.new(lower_line2, lower_line1, color.new(col_low2, 90))

        bool bull_breakout_trigger = ta.crossover(close, upper2_end)
        bool bear_breakout_trigger = ta.crossunder(close, lower2_end)

        color breakout_marker_color = bull_breakout_trigger ? color.new(color.green, 85) : bear_breakout_trigger ? color.new(color.red, 85) : na
        plot_bgcolor := breakout_style == 'Background Color' ? breakout_marker_color : na
        plot_up_arrow := breakout_style == 'Arrow Mark' and bull_breakout_trigger ? low * 0.99 : na
        plot_down_arrow := breakout_style == 'Arrow Mark' and bear_breakout_trigger ? high * 1.01 : na


        var label info_label = na
        if show_label and barstate.islast
            float slope_val = (reg_end - reg_start) / final_length
            string trend_status = na
            color trend_color = na
            if slope_val > horizontal_threshold
                trend_status := 'Uptrend'
                trend_color := color.new(color.green, 25)
                trend_color
            else if slope_val < -horizontal_threshold
                trend_status := 'Downtrend'
                trend_color := color.new(color.red, 25)
                trend_color
            else
                trend_status := 'Sideways'
                trend_color := color.new(color.gray, 25)
                trend_color
            float channel_width_val = upper2_end - lower2_end
            string length_text = length_mode == 'Numerical (Manual)' ? str.tostring(final_length) : 'Automatic (' + str.tostring(final_length) + ')'
            string labelText = 'Trend Status: ' + trend_status + '\nRegression Model: ' + model_type + '\nLength: ' + length_text + '\nTrend Slope: ' + str.tostring(slope_val, '#.#####') + '\nChannel Width: ' + str.tostring(channel_width_val, format.mintick)
            color final_label_bg = label_color_mode == 'Dynamic by Trend' ? trend_color : label_bg_color
            label.delete(info_label[1])
            info_label := label.new(bar_index + label_x_offset, reg_end, text = labelText, color = final_label_bg, textcolor = label_text_color, style = label.style_label_left, textalign = text.align_left, size = label_size)
            info_label

        cross_up2 = ta.cross(close, upper2_end)
        cross_low2 = ta.cross(close, lower2_end)
        cross_up1 = ta.cross(close, upper1_end)
        cross_low1 = ta.cross(close, lower1_end)
        cross_up0 = ta.cross(close, upper0_end)
        cross_low0 = ta.cross(close, lower0_end)
        cross_mid = ta.cross(close, reg_end)
        bool fire_alert = false
        if alert_source != 'Off'
            switch alert_source
                'Any Line' => 
            	    fire_alert := cross_up2 or cross_low2 or cross_up1 or cross_low1 or cross_up0 or cross_low0 or cross_mid
            	    fire_alert
                'Outer Channels' => 
            	    fire_alert := cross_up2 or cross_low2
            	    fire_alert
                'Middle Channels' => 
            	    fire_alert := cross_up1 or cross_low1
            	    fire_alert
                'Inner Channels' => 
            	    fire_alert := cross_up0 or cross_low0
            	    fire_alert
                'Center Line' => 
            	    fire_alert := cross_mid
            	    fire_alert
        var string alert_message = ''
        if cross_up2
            alert_message := 'Price crossed the UPPER OUTER CHANNEL. Level: ' + str.tostring(upper2_end, format.mintick)
            alert_message
        if cross_low2
            alert_message := 'Price crossed the LOWER OUTER CHANNEL. Level: ' + str.tostring(lower2_end, format.mintick)
            alert_message
        if cross_up1
            alert_message := 'Price crossed the UPPER MIDDLE CHANNEL. Level: ' + str.tostring(upper1_end, format.mintick)
            alert_message
        if cross_low1
            alert_message := 'Price crossed the LOWER MIDDLE CHANNEL. Level: ' + str.tostring(lower1_end, format.mintick)
            alert_message
        if cross_up0
            alert_message := 'Price crossed the UPPER INNER CHANNEL. Level: ' + str.tostring(upper0_end, format.mintick)
            alert_message
        if cross_low0
            alert_message := 'Price crossed the LOWER INNER CHANNEL. Level: ' + str.tostring(lower0_end, format.mintick)
            alert_message
        if cross_mid
            alert_message := 'Price crossed the CENTER LINE. Level: ' + str.tostring(reg_end, format.mintick)
            alert_message
        if fire_alert
            alert(alert_message, freq = alert.freq_once_per_bar_close)
else
    plot_bgcolor := na
    plot_up_arrow := na
    plot_down_arrow := na
    plot_down_arrow

// --- GLOBAL SCOPE PLOTTING FUNCTIONS (No changes) ---
bgcolor(plot_bgcolor, title = 'Breakout Background Color')
plotarrow(series = plot_up_arrow, title = 'Up Breakout Arrow', colorup = color.rgb(37, 249, 44), offset = -1, minheight = 35, maxheight = 35)
plotarrow(series = plot_down_arrow, title = 'Down Breakout Arrow', colordown = color.new(color.red,0), offset = -1, minheight =35, maxheight = 35)






// This work is licensed under a Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) https://creativecommons.org/licenses/by-nc-sa/4.0/
// ¬© LuxAlgo

//@version=6
//indicator('‚ù§Ô∏èÔ∏è‚ù§Ô∏èÔ∏èTrendlines with Breaks [LuxAlgo]', '‚ù§Ô∏èÔ∏è‚ù§Ô∏èÔ∏èLuxAlgo - Trendlines with Breaks', overlay = true)
//------------------------------------------------------------------------------
//Settings
//-----------------------------------------------------------------------------{
length = input.int(14, 'Swing Detection Lookback')
mult = input.float(1., 'Slope', minval = 0, step = .1)
calcMethod = input.string('Atr', 'Slope Calculation Method', options = ['Atr', 'Stdev', 'Linreg'])
backpaint = input(true, tooltip = 'Backpainting offset displayed elements in the past. Disable backpainting to see real time information returned by the indicator.')

//Style
upCss = input.color(color.teal, 'Up Trendline Color', group = 'Style')
dnCss = input.color(color.red, 'Down Trendline Color', group = 'Style')
showExt = input(true, 'Show Extended Lines')

//-----------------------------------------------------------------------------}
//Calculations
//-----------------------------------------------------------------------------{
var upper = 0.
var lower = 0.
var slope_ph = 0.
var slope_pl = 0.

var offset_swing = backpaint ? length : 0

n = bar_index
src = close

ph = ta.pivothigh(length, length)
pl = ta.pivotlow(length, length)

//Slope Calculation Method
slope = switch calcMethod
    'Atr' => ta.atr(length) / length * mult
    'Stdev' => ta.stdev(src, length) / length * mult
    'Linreg' => math.abs(ta.sma(src * n, length) - ta.sma(src, length) * ta.sma(n, length)) / ta.variance(n, length) / 2 * mult

//Get slopes and calculate trendlines
slope_ph := bool(ph) ? slope : slope_ph
slope_pl := bool(pl) ? slope : slope_pl

upper := bool(ph) ? ph : upper - slope_ph
lower := bool(pl) ? pl : lower + slope_pl

var upos = 0
var dnos = 0
upos := bool(ph) ? 0 : close > upper - slope_ph * length ? 1 : upos
dnos := bool(pl) ? 0 : close < lower + slope_pl * length ? 1 : dnos

//-----------------------------------------------------------------------------}
//Extended Lines
//-----------------------------------------------------------------------------{
var uptl = line.new(na, na, na, na, color = upCss, style = line.style_dashed, extend = extend.right, width = 4)
var dntl = line.new(na, na, na, na, color = dnCss, style = line.style_dashed, extend = extend.right, width = 4)

if bool(ph) and showExt
    uptl.set_xy1(n - offset_swing, backpaint ? ph : upper - slope_ph * length)
    uptl.set_xy2(n - offset_swing + 1, backpaint ? ph - slope : upper - slope_ph * (length + 1))

if bool(pl) and showExt
    dntl.set_xy1(n - offset_swing, backpaint ? pl : lower + slope_pl * length)
    dntl.set_xy2(n - offset_swing + 1, backpaint ? pl + slope : lower + slope_pl * (length + 1))

//-----------------------------------------------------------------------------}
//Plots
//-----------------------------------------------------------------------------{
plot(backpaint ? upper : upper - slope_ph * length, 'Upper', color = bool(ph) ? na : upCss, offset = -offset_swing)
plot(backpaint ? lower : lower + slope_pl * length, 'Lower', color = bool(pl) ? na : dnCss, offset = -offset_swing)

//Breakouts
plotshape(upos > upos[1] ? low : na, 'Upper Break', shape.labelup, location.absolute, upCss, text = 'B', textcolor = color.white, size = size.tiny)

plotshape(dnos > dnos[1] ? high : na, 'Lower Break', shape.labeldown, location.absolute, dnCss, text = 'B', textcolor = color.white, size = size.tiny)

//-----------------------------------------------------------------------------}
//Alerts
//-----------------------------------------------------------------------------{
// alertcondition(upos > upos[1], 'Upward Breakout', 'Price broke the down-trendline upward')
// alertcondition(dnos > dnos[1], 'Downward Breakout', 'Price broke the up-trendline downward')

//-----------------------------------------------------------------------------}








//@version=6
//indicator("üî¥ 5/15-Min-ORB-Trend-Finder-WiP", overlay = true)
//Updated notes 10-19-2025
//Updated 10-30-2025: added EMA 20 (thick yellow), EMA 50 (thick blue), and EMA 200 (thick orange) lines to enable tracking trending Bull or Bear market

// Ôº©ÔºÆÔº∞ÔºµÔº¥Ôº≥
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Group Names
group_main = "Main Settings"
group_ema = "EMA Settings"
group_timeframe = "Timeframe Settings"
group_color = "Color Settings"
group_label = "Label Settings"
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

// Ôº©ÔºÆÔº∞ÔºµÔº¥S ‚îÄ‚îÄ Main Settings
alpha = input.float(0.10, minval=0.01, maxval=1.0, display=_display, title="Alpha", group=group_main)
source = input.source(close, display=_display, title="Source", group=group_main)
offset_timeframe = 3  // Static value, no input needed

// EMA Inputs ‚îÄ‚îÄ EMA Settings
show_ema2050200_length = input.bool(false, display=_display, title="EMA 20 Length", group=group_ema)
ema20_length = input.int(20, minval=1, display=_display, title="EMA 20 Length", group=group_ema)
ema50_length = input.int(50, minval=1, display=_display, title="EMA 50 Length", group=group_ema)
ema200_length = input.int(200, minval=1, display=_display, title="EMA 200 Length", group=group_ema)
ema_offset = input.int(0, minval=-500, maxval=500, display=_display, title="EMA Offset", group=group_ema)

// Timeframes ‚îÄ‚îÄ Timeframe Settings
tf1 = input.timeframe("60", display=_display, title="Timeframe1", group=group_timeframe)
tf2 = input.timeframe("120", display=_display, title="Timeframe2", group=group_timeframe)
tf3 = input.timeframe("240", display=_display, title="Timeframe3", group=group_timeframe)
tf4 = input.timeframe("D", display=_display, title="Timeframe4", group=group_timeframe)
tf5 = input.timeframe("7D", display=_display, title="Timeframe5", group=group_timeframe)

// Colors ‚îÄ‚îÄ Color Settings
c_up = input.color(#00b8a5, display=_display, title="", group=group_color)
c_dn = input.color(color.rgb(214, 14, 0), display=_display, title="", group=group_color)

// Toggles ‚îÄ‚îÄ Label Settings
show_5min_labels = input.bool(false, display=_display, title="Show 5-Min High/Low Labels", group=group_label)
show_15min_labels = input.bool(false, display=_display, title="Show 15-Min High/Low Labels", group=group_label)
show_open_label = input.bool(false, display=_display, title="Show Open Label", group=group_label)


// EMA Calculations
var ema20 = ta.ema(source, ema20_length)
var ema50 = ta.ema(source, ema50_length)
var ema200 = ta.ema(source, ema200_length)

var float f = na
var float f_prev1 = na
var float f_prev2 = na

// Ôº£Ôº°Ôº¨Ôº£ÔºµÔº¨Ôº°Ôº¥Ôº©ÔºØÔºÆÔº≥
if bar_index >= 2
    f := math.pow(alpha, 2) * source + 2 * (1 - alpha) * f_prev1 - math.pow(1 - alpha, 2) * f_prev2
else
    f := source

f_prev2 := f_prev1
f_prev1 := f

tp1 = request.security("", tf1, f_prev1 > f_prev1[offset_timeframe])
tp2 = request.security("", tf2, f_prev1 > f_prev1[offset_timeframe])
tp3 = request.security("", tf3, f_prev1 > f_prev1[offset_timeframe])
tp4 = request.security("", tf4, f_prev1 > f_prev1[offset_timeframe])
tp5 = request.security("", tf5, f_prev1 > f_prev1[offset_timeframe])

avg = math.avg(tp1 ? 1 : 0, tp2 ? 1 : 0, tp3 ? 1 : 0, tp4 ? 1 : 0, tp5 ? 1 : 0)

dash = table.new(position.bottom_right, 100, 100)
if barstate.islast
    dash.merge_cells(0, 0, 8, 0)
    dash.cell(0, 0, str.tostring(syminfo.basecurrency) + (avg > 0.5 ? " ü¢Å" : " ü¢É"), text_color=avg > 0.5 ? c_up : c_dn, tooltip="Average Trend")

draw_gauge(col, tf, trend)=>
    if barstate.islast
        s = timeframe.in_seconds(tf)
        m = timeframe.in_seconds(tf) / 60
        h = timeframe.in_seconds(tf) / 60 / 60
        d = timeframe.in_seconds(tf) / 60 / 60 / 24

        tff = h < 24 and h >= 1 ? str.tostring(h) + "H" : m >= 1440 ? str.tostring(d) + "D" : m < 60 and m > 1 ? str.tostring(m) + "M" : m < 1 ? str.tostring(s) + "S" : tf 
        color = trend ? c_up : c_dn

        dash.cell(col, 1, "", bgcolor=color)
        dash.cell(col, 2, tff, text_color=chart.fg_color, text_size=size.normal)
        dash.cell(col+1, 1, "", bgcolor=color(na), width=1)

// Ôº∞Ôº¨ÔºØÔº¥
draw_gauge(0, tf1, tp1)
draw_gauge(2, tf2, tp2)
draw_gauge(4, tf3, tp3)
draw_gauge(6, tf4, tp4)
draw_gauge(8, tf5, tp5)

// plot(f_prev1, "1", color=f_prev1 > f_prev1[offset_timeframe] ? c_up : c_dn, linewidth=3)
// plot(f_prev1, "2", color=color.new(f_prev1 > f_prev1[offset_timeframe] ? c_up : c_dn, 80), linewidth=25)

// EMA Plots

// plot(ema20, "EMA 20", color=color.yellow, offset=ema_offset, linewidth=3)
// plot(ema50, "EMA 50", color=color.blue, offset=ema_offset, linewidth=3)
plot(ema200, "EMA 200", color=color.orange, offset=ema_offset, linewidth=3)

// 5-Min ORB Labels
timezonePT = "America/Los_Angeles"
targetHours = array.from(6)
targetMinutes = array.from(30)
lineColor = color.blue

var float orbHigh_5min = na
var float orbLow_5min = na
var line hiLine_5min = na
var line loLine_5min = na
var label hiLabel_5min = na
var label loLabel_5min = na

sessStart_5min = timestamp(timezonePT, year, month, dayofmonth, 6, 30)
sessEnd_5min = timestamp(timezonePT, year, month, dayofmonth, 6, 35)

if dayofmonth != dayofmonth[1]
    orbHigh_5min := na
    orbLow_5min := na
    if not na(hiLine_5min)
        line.delete(hiLine_5min)
        hiLine_5min := na
    if not na(loLine_5min)
        line.delete(loLine_5min)
        loLine_5min := na
    if not na(hiLabel_5min)
        label.delete(hiLabel_5min)
        hiLabel_5min := na
    if not na(loLabel_5min)
        label.delete(loLabel_5min)
        loLabel_5min := na
tf_current = timeframe.period
inSession_5min = time >= sessStart_5min and time < sessEnd_5min
if inSession_5min
    orbHigh_5min := na(orbHigh_5min) ? high : math.max(orbHigh_5min, high)
    orbLow_5min := na(orbLow_5min) ? low : math.min(orbLow_5min, low)

if time >= sessEnd_5min and show_5min_labels and tf_current == "5"
    if na(hiLine_5min) and not na(orbHigh_5min)
        hiLine_5min := line.new(bar_index[1], orbHigh_5min, bar_index, orbHigh_5min, xloc=xloc.bar_index, extend=extend.right, color=color.green, width=1)
        hiLabel_5min := label.new(bar_index, orbHigh_5min, "5-Min High", color=color.green, style=label.style_label_left, textcolor=color.white, size=size.small)
    if na(loLine_5min) and not na(orbLow_5min)
        loLine_5min := line.new(bar_index[1], orbLow_5min, bar_index, orbLow_5min, xloc=xloc.bar_index, extend=extend.right, color=color.red, width=1)
        loLabel_5min := label.new(bar_index, orbLow_5min, "5-Min Low", color=color.red, style=label.style_label_left, textcolor=color.white, size=size.small)

if not na(hiLabel_5min)
    label.set_x(hiLabel_5min, bar_index)
if not na(loLabel_5min)
    label.set_x(loLabel_5min, bar_index)

// 15-Min ORB Labels
var float orbHigh = na
var float orbLow = na
var line hiLine = na
var line loLine = na
var label hiLabel = na
var label loLabel = na

sessStart = timestamp(timezonePT, year, month, dayofmonth, 6, 30)
sessEnd = timestamp(timezonePT, year, month, dayofmonth, 6, 45)

if dayofmonth != dayofmonth[1]
    orbHigh := na
    orbLow := na
    if not na(hiLine)
        line.delete(hiLine)
        hiLine := na
    if not na(loLine)
        line.delete(loLine)
        loLine := na
    if not na(hiLabel)
        label.delete(hiLabel)
        hiLabel := na
    if not na(loLabel)
        label.delete(loLabel)
        loLabel := na

inSession = time >= sessStart and time < sessEnd
if inSession
    orbHigh := na(orbHigh) ? high : math.max(orbHigh, high)
    orbLow := na(orbLow) ? low : math.min(orbLow, low)

if time >= sessEnd and show_15min_labels and tf_current == "15"
    if na(hiLine) and not na(orbHigh)
        hiLine := line.new(bar_index[1], orbHigh, bar_index, orbHigh, xloc=xloc.bar_index, extend=extend.right, color=color.green, width=1)
        hiLabel := label.new(bar_index, orbHigh, "15-Min High", color=color.green, style=label.style_label_left, textcolor=color.white, size=size.small)
    if na(loLine) and not na(orbLow)
        loLine := line.new(bar_index[1], orbLow, bar_index, orbLow, xloc=xloc.bar_index, extend=extend.right, color=color.red, width=1)
        loLabel := label.new(bar_index, orbLow, "15-Min Low", color=color.red, style=label.style_label_left, textcolor=color.white, size=size.small)

if not na(hiLabel)
    label.set_x(hiLabel, bar_index)
if not na(loLabel)
    label.set_x(loLabel, bar_index)

// Open Label
bar_hour = hour(time, timezonePT)
bar_minute = minute(time, timezonePT)
if show_open_label
    for i = 0 to array.size(targetHours)-1
        th = array.get(targetHours, i)
        tm = array.get(targetMinutes, i)
        if bar_hour == th and bar_minute == tm
            labelText = th == 6 and tm == 30 ? "Open" : str.tostring(th, "00") + ":" + str.tostring(tm, "00")
            label.new(bar_index, high, text=labelText, color=color.new(lineColor, 0), style=label.style_label_down, textcolor=color.white, size=size.normal)

// Pivot S/R
leftBars = 15
rightBars = 15
highUsePivot = fixnan(ta.pivothigh(high, leftBars, rightBars)[1])
lowUsePivot = fixnan(ta.pivotlow(low, leftBars, rightBars)[1])

plot(highUsePivot, color=ta.change(highUsePivot) != 0 ? na : #FF0000, linewidth=3, title="Resistance")
plot(lowUsePivot, color=ta.change(lowUsePivot) != 0 ? na : #233dee, linewidth=3, title="Support")

// ATR-based Support/Resistance Boxes
lengthBox = input.int(130, title="ATR S/R Length")
extendBox = input.int(35, title="ATR S/R Extend")
t_col_resistance = input.color(color.red, title="Resistance Box Color")
b_col_support = input.color(color.rgb(4, 55, 71), title="Support Box Color")

float atr_orb_trend_finder = ta.atr(200) * 0.5

var box resBox = na
var box supBox = na

// Find high/low over lengthBox
boxHigh = ta.highest(high, lengthBox)
boxLow = ta.lowest(low, lengthBox)

if barstate.islast
    if not na(resBox)
        box.delete(resBox)
    if not na(supBox)
        box.delete(supBox)

    resBox := box.new(bar_index - lengthBox, boxHigh + atr_orb_trend_finder, bar_index + extendBox, boxHigh - atr_orb_trend_finder, border_color=color.new(color.white, 80), bgcolor=color.new(t_col_resistance, 30), border_width = 3)
    supBox := box.new(bar_index - lengthBox, boxLow + atr_orb_trend_finder, bar_index + extendBox, boxLow - atr_orb_trend_finder, border_color=color.new(color.white, 80), bgcolor=color.new(b_col_support, 30), border_width = 3)








//@version=6
//indicator("üî¥üî¥ TIM V2 15 MIN BOT BUY SEL ALERT FINAL", shorttitle = "üî¥üî¥ 15 MIN BOT", overlay = true, max_bars_back = 5000, max_labels_count = 64, max_boxes_count = 64, max_polylines_count = 100, max_lines_count = 500)
import TradingView/ta/10
//_display = display.none

laguerre_src = input(defval=hlc3, title="Source", display = display.all-display.status_line)
laguerre_mode = input.int(defval=1, minval=1, maxval=2, title="Mode Selection (1 = Ribbon Mode, 2 = Band Mode)", display = display.all-display.status_line)
laguerre_rbc = input.int(defval=21, minval=1, maxval=21, title="Ribbon Mode Bar Color (0-19 = Corresponding Filter Color, 19 = Average Filter Based Color)", display = display.all-display.status_line)
laguerre_eares   = input.bool(defval=false, title="Enable Alternate Resolution", display = display.all-display.status_line)
laguerre_altres  = input.string(defval="D",   title="Alternate Resolution", display = display.all-display.status_line)


//Gamma Inputs
laguerre_gamma0  = input.float(display = display.all-display.status_line, defval=0.03,  step=0.01, title="Gamma 0")
laguerre_gamma1  = input.float(display = display.all-display.status_line, defval=0.05,  step=0.01, title="Gamma 1")
laguerre_gamma2  = input.float(display = display.all-display.status_line, defval=0.1, step=0.01, title="Gamma 2")
laguerre_gamma3  = input.float(display = display.all-display.status_line, defval=0.15,  step=0.01, title="Gamma 3")
laguerre_gamma4  = input.float(display = display.all-display.status_line, defval=0.2, step=0.01, title="Gamma 4")
laguerre_gamma5  = input.float(display = display.all-display.status_line, defval=0.25,  step=0.01, title="Gamma 5")
laguerre_gamma6  = input.float(display = display.all-display.status_line, defval=0.3, step=0.01, title="Gamma 6")
laguerre_gamma7  = input.float(display = display.all-display.status_line, defval=0.35,  step=0.01, title="Gamma 7")
laguerre_gamma8  = input.float(display = display.all-display.status_line, defval=0.4, step=0.01, title="Gamma 8")
laguerre_gamma9  = input.float(display = display.all-display.status_line, defval=0.45,  step=0.01, title="Gamma 9")
laguerre_gamma10 = input.float(display = display.all-display.status_line, defval=0.5, step=0.01, title="Gamma 10")
laguerre_gamma11 = input.float(display = display.all-display.status_line, defval=0.55,  step=0.01, title="Gamma 11")
laguerre_gamma12 = input.float(display = display.all-display.status_line, defval=0.6, step=0.01, title="Gamma 12")
laguerre_gamma13 = input.float(display = display.all-display.status_line, defval=0.65,  step=0.01, title="Gamma 13")
laguerre_gamma14 = input.float(display = display.all-display.status_line, defval=0.7, step=0.01, title="Gamma 14")
laguerre_gamma15 = input.float(display = display.all-display.status_line, defval=0.75,  step=0.01, title="Gamma 15")
laguerre_gamma16 = input.float(display = display.all-display.status_line, defval=0.8, step=0.01, title="Gamma 16")
laguerre_gamma17 = input.float(display = display.all-display.status_line, defval=0.85,  step=0.01, title="Gamma 17")
laguerre_gamma18 = input.float(display = display.all-display.status_line, defval=0.90, step=0.01, title="Gamma 18")
laguerre_gamma19 = input.float(display = display.all-display.status_line, defval=0.95, step=0.01, title="Gamma 19")


laguerre_laguerre (src, gamma) =>
    L0 = 0.0
    L0 := (1-gamma) * src + gamma * nz(L0[1])

    L1 = 0.0
    L1 := -gamma * L0 + nz(L0[1]) + gamma * nz(L1[1])

    L2 = 0.0
    L2 := -gamma * L1 + nz(L1[1]) + gamma * nz(L2[1])

    L3 = 0.0
    L3 := -gamma * L2 + nz(L2[1]) + gamma * nz(L3[1])

    laguerre_laguerre = (L0 + 2 * L1 + 2 * L2 + L3) / 6

//Filter Values
laguerre_lag0  = laguerre_laguerre(laguerre_src, laguerre_gamma0)
laguerre_lag1  = laguerre_laguerre(laguerre_src, laguerre_gamma1)
laguerre_lag2  = laguerre_laguerre(laguerre_src, laguerre_gamma2)
laguerre_lag3  = laguerre_laguerre(laguerre_src, laguerre_gamma3)
laguerre_lag4  = laguerre_laguerre(laguerre_src, laguerre_gamma4)
laguerre_lag5  = laguerre_laguerre(laguerre_src, laguerre_gamma5)
laguerre_lag6  = laguerre_laguerre(laguerre_src, laguerre_gamma6)
laguerre_lag7  = laguerre_laguerre(laguerre_src, laguerre_gamma7)
laguerre_lag8  = laguerre_laguerre(laguerre_src, laguerre_gamma8)
laguerre_lag9  = laguerre_laguerre(laguerre_src, laguerre_gamma9)
laguerre_lag10 = laguerre_laguerre(laguerre_src, laguerre_gamma10)
laguerre_lag11 = laguerre_laguerre(laguerre_src, laguerre_gamma11)
laguerre_lag12 = laguerre_laguerre(laguerre_src, laguerre_gamma12)
laguerre_lag13 = laguerre_laguerre(laguerre_src, laguerre_gamma13)
laguerre_lag14 = laguerre_laguerre(laguerre_src, laguerre_gamma14)
laguerre_lag15 = laguerre_laguerre(laguerre_src, laguerre_gamma15)
laguerre_lag16 = laguerre_laguerre(laguerre_src, laguerre_gamma16)
laguerre_lag17 = laguerre_laguerre(laguerre_src, laguerre_gamma17)
laguerre_lag18 = laguerre_laguerre(laguerre_src, laguerre_gamma18)
laguerre_lag19 = laguerre_laguerre(laguerre_src, laguerre_gamma19)

//Multi-Resolution Filter Values
laguerre_mlag0   = laguerre_eares ? request.security(syminfo.tickerid, laguerre_altres, laguerre_lag0) : laguerre_lag0
laguerre_mlag1   = laguerre_eares ? request.security(syminfo.tickerid, laguerre_altres, laguerre_lag1) : laguerre_lag1
laguerre_mlag2   = laguerre_eares ? request.security(syminfo.tickerid, laguerre_altres, laguerre_lag2) : laguerre_lag2
laguerre_mlag3   = laguerre_eares ? request.security(syminfo.tickerid, laguerre_altres, laguerre_lag3) : laguerre_lag3
laguerre_mlag4   = laguerre_eares ? request.security(syminfo.tickerid, laguerre_altres, laguerre_lag4) : laguerre_lag4
laguerre_mlag5   = laguerre_eares ? request.security(syminfo.tickerid, laguerre_altres, laguerre_lag5) : laguerre_lag5
laguerre_mlag6   = laguerre_eares ? request.security(syminfo.tickerid, laguerre_altres, laguerre_lag6) : laguerre_lag6
laguerre_mlag7   = laguerre_eares ? request.security(syminfo.tickerid, laguerre_altres, laguerre_lag7) : laguerre_lag7
laguerre_mlag8   = laguerre_eares ? request.security(syminfo.tickerid, laguerre_altres, laguerre_lag8) : laguerre_lag8
laguerre_mlag9   = laguerre_eares ? request.security(syminfo.tickerid, laguerre_altres, laguerre_lag9) : laguerre_lag9
laguerre_mlag10  = laguerre_eares ? request.security(syminfo.tickerid, laguerre_altres, laguerre_lag10) : laguerre_lag10
laguerre_mlag11  = laguerre_eares ? request.security(syminfo.tickerid, laguerre_altres, laguerre_lag11) : laguerre_lag11
laguerre_mlag12  = laguerre_eares ? request.security(syminfo.tickerid, laguerre_altres, laguerre_lag12) : laguerre_lag12
laguerre_mlag13  = laguerre_eares ? request.security(syminfo.tickerid, laguerre_altres, laguerre_lag13) : laguerre_lag13
laguerre_mlag14  = laguerre_eares ? request.security(syminfo.tickerid, laguerre_altres, laguerre_lag14) : laguerre_lag14
laguerre_mlag15  = laguerre_eares ? request.security(syminfo.tickerid, laguerre_altres, laguerre_lag15) : laguerre_lag15
laguerre_mlag16  = laguerre_eares ? request.security(syminfo.tickerid, laguerre_altres, laguerre_lag16) : laguerre_lag16
laguerre_mlag17  = laguerre_eares ? request.security(syminfo.tickerid, laguerre_altres, laguerre_lag17) : laguerre_lag17
laguerre_mlag18  = laguerre_eares ? request.security(syminfo.tickerid, laguerre_altres, laguerre_lag18) : laguerre_lag18
laguerre_mlag19  = laguerre_eares ? request.security(syminfo.tickerid, laguerre_altres, laguerre_lag19) : laguerre_lag19


//Multi-Resolution Previous Filter Values
laguerre_mlag0prev   = laguerre_eares ? request.security(syminfo.tickerid, laguerre_altres, laguerre_lag0[1]) : laguerre_lag0[1]
laguerre_mlag1prev   = laguerre_eares ? request.security(syminfo.tickerid, laguerre_altres, laguerre_lag1[1]) : laguerre_lag1[1]
laguerre_mlag2prev   = laguerre_eares ? request.security(syminfo.tickerid, laguerre_altres, laguerre_lag2[1]) : laguerre_lag2[1]
laguerre_mlag3prev   = laguerre_eares ? request.security(syminfo.tickerid, laguerre_altres, laguerre_lag3[1]) : laguerre_lag3[1]
laguerre_mlag4prev   = laguerre_eares ? request.security(syminfo.tickerid, laguerre_altres, laguerre_lag4[1]) : laguerre_lag4[1]
laguerre_mlag5prev   = laguerre_eares ? request.security(syminfo.tickerid, laguerre_altres, laguerre_lag5[1]) : laguerre_lag5[1]
laguerre_mlag6prev   = laguerre_eares ? request.security(syminfo.tickerid, laguerre_altres, laguerre_lag6[1]) : laguerre_lag6[1]
laguerre_mlag7prev   = laguerre_eares ? request.security(syminfo.tickerid, laguerre_altres, laguerre_lag7[1]) : laguerre_lag7[1]
laguerre_mlag8prev   = laguerre_eares ? request.security(syminfo.tickerid, laguerre_altres, laguerre_lag8[1]) : laguerre_lag8[1]
laguerre_mlag9prev   = laguerre_eares ? request.security(syminfo.tickerid, laguerre_altres, laguerre_lag9[1]) : laguerre_lag9[1]
laguerre_mlag10prev  = laguerre_eares ? request.security(syminfo.tickerid, laguerre_altres, laguerre_lag10[1]) : laguerre_lag10[1]
laguerre_mlag11prev  = laguerre_eares ? request.security(syminfo.tickerid, laguerre_altres, laguerre_lag11[1]) : laguerre_lag11[1]
laguerre_mlag12prev  = laguerre_eares ? request.security(syminfo.tickerid, laguerre_altres, laguerre_lag12[1]) : laguerre_lag12[1]
laguerre_mlag13prev  = laguerre_eares ? request.security(syminfo.tickerid, laguerre_altres, laguerre_lag13[1]) : laguerre_lag13[1]
laguerre_mlag14prev  = laguerre_eares ? request.security(syminfo.tickerid, laguerre_altres, laguerre_lag14[1]) : laguerre_lag14[1]
laguerre_mlag15prev  = laguerre_eares ? request.security(syminfo.tickerid, laguerre_altres, laguerre_lag15[1]) : laguerre_lag15[1]
laguerre_mlag16prev  = laguerre_eares ? request.security(syminfo.tickerid, laguerre_altres, laguerre_lag16[1]) : laguerre_lag16[1]
laguerre_mlag17prev  = laguerre_eares ? request.security(syminfo.tickerid, laguerre_altres, laguerre_lag17[1]) : laguerre_lag17[1]
laguerre_mlag18prev  = laguerre_eares ? request.security(syminfo.tickerid, laguerre_altres, laguerre_lag18[1]) : laguerre_lag18[1]
laguerre_mlag19prev  = laguerre_eares ? request.security(syminfo.tickerid, laguerre_altres, laguerre_lag19[1]) : laguerre_lag19[1]


//Multi-Resolution Average Laguerre Filter
laguerre_amlag     = (laguerre_mlag0 + laguerre_mlag1 + laguerre_mlag2 + laguerre_mlag3 + laguerre_mlag4 + laguerre_mlag5 + laguerre_mlag6 + laguerre_mlag7 + laguerre_mlag8 + laguerre_mlag9 + laguerre_mlag10 + laguerre_mlag11 + laguerre_mlag12 + laguerre_mlag13 + laguerre_mlag14 + laguerre_mlag15 + laguerre_mlag16 + laguerre_mlag17 + laguerre_mlag18 + laguerre_mlag19)/19
laguerre_amlagprev = (laguerre_mlag0prev + laguerre_mlag1prev + laguerre_mlag2prev + laguerre_mlag3prev + laguerre_mlag4prev + laguerre_mlag5prev + laguerre_mlag6prev + laguerre_mlag7prev + laguerre_mlag8prev + laguerre_mlag9prev + laguerre_mlag10prev + laguerre_mlag11prev + laguerre_mlag12prev + laguerre_mlag13prev + laguerre_mlag14prev + laguerre_mlag15prev + laguerre_mlag16prev + laguerre_mlag17prev + laguerre_mlag18prev+ laguerre_mlag19prev)/19

//Average Laguerre True Range
laguerre_altr      = (laguerre_laguerre(ta.tr, laguerre_gamma0) + laguerre_laguerre(ta.tr, laguerre_gamma1) + laguerre_laguerre(ta.tr, laguerre_gamma2) + laguerre_laguerre(ta.tr, laguerre_gamma3) + laguerre_laguerre(ta.tr, laguerre_gamma4) + laguerre_laguerre(ta.tr, laguerre_gamma5) + laguerre_laguerre(ta.tr, laguerre_gamma6) + laguerre_laguerre(ta.tr, laguerre_gamma7) + laguerre_laguerre(ta.tr, laguerre_gamma8) + laguerre_laguerre(ta.tr, laguerre_gamma9) + laguerre_laguerre(ta.tr, laguerre_gamma10) + laguerre_laguerre(ta.tr, laguerre_gamma11) + laguerre_laguerre(ta.tr, laguerre_gamma12) + laguerre_laguerre(ta.tr, laguerre_gamma13) + laguerre_laguerre(ta.tr, laguerre_gamma14) + laguerre_laguerre(ta.tr, laguerre_gamma15) + laguerre_laguerre(ta.tr, laguerre_gamma16) + laguerre_laguerre(ta.tr, laguerre_gamma17) + laguerre_laguerre(ta.tr, laguerre_gamma18)+ laguerre_laguerre(ta.tr, laguerre_gamma19))/19
laguerre_maltr     = laguerre_eares ? request.security(syminfo.tickerid, laguerre_altres, laguerre_altr) : laguerre_altr

//Bands
laguerre_hb1 = laguerre_amlag + laguerre_maltr*1.618
laguerre_hb2 = laguerre_amlag + 2*laguerre_maltr*1.618
laguerre_lb1 = laguerre_amlag - laguerre_maltr*1.618
laguerre_lb2 = laguerre_amlag - 2*laguerre_maltr*1.618


//Colors
laguerre_rcolor0   = laguerre_mlag0 > laguerre_mlag0prev ?   color.rgb(255, 255, 255) : laguerre_mlag0 <  laguerre_mlag0prev ?       #FF0000 : color.orange
laguerre_rcolor1   = laguerre_mlag1 > laguerre_mlag1prev ?   color.rgb(255, 198, 63)  : laguerre_mlag1 <  laguerre_mlag1prev ?      #FF0000 : color.orange
laguerre_rcolor2   = laguerre_mlag2 > laguerre_mlag2prev ?   color.rgb(255, 198, 63)  :   laguerre_mlag2 <  laguerre_mlag2prev ?    #FF0000 : color.orange
laguerre_rcolor3   = laguerre_mlag3 > laguerre_mlag3prev ?   color.rgb(255, 198, 63)  :   laguerre_mlag3 <  laguerre_mlag3prev ?    #FF0000 : color.orange
laguerre_rcolor4   = laguerre_mlag4 > laguerre_mlag4prev ?   color.rgb(255, 198, 63)  :   laguerre_mlag4 <  laguerre_mlag4prev ?    #FF0000 : color.orange
laguerre_rcolor5   = laguerre_mlag5 > laguerre_mlag5prev ?   color.rgb(255, 198, 63)  :   laguerre_mlag5 <  laguerre_mlag5prev ?    #FF0000 : color.orange
laguerre_rcolor6   = laguerre_mlag6 > laguerre_mlag6prev ?   color.rgb(255, 198, 63)  :   laguerre_mlag6 <  laguerre_mlag6prev ?    #FF0000 : color.orange
laguerre_rcolor7   = laguerre_mlag7 > laguerre_mlag7prev ?   color.rgb(255, 198, 63)  :   laguerre_mlag7 <  laguerre_mlag7prev ?    #FF0000 : color.orange
laguerre_rcolor8   = laguerre_mlag8 > laguerre_mlag8prev ?   color.rgb(255, 198, 63)  :   laguerre_mlag8 <  laguerre_mlag8prev ?    #FF0000 : color.orange
laguerre_rcolor9   = laguerre_mlag9 > laguerre_mlag9prev ?   color.rgb(255, 198, 63)  :   laguerre_mlag9 <  laguerre_mlag9prev ?    #FF0000 : color.orange
laguerre_rcolor10  = laguerre_mlag10 > laguerre_mlag10prev ? color.rgb(255, 198, 63)  :   laguerre_mlag10 < laguerre_mlag10prev ?   #FF0000 : color.orange
laguerre_rcolor11  = laguerre_mlag11 > laguerre_mlag11prev ? color.rgb(255, 198, 63)  :   laguerre_mlag11 < laguerre_mlag11prev ?   #FF0000 : color.orange
laguerre_rcolor12  = laguerre_mlag12 > laguerre_mlag12prev ? color.rgb(255, 198, 63)  :   laguerre_mlag12 < laguerre_mlag12prev ?   #FF0000 : color.orange
laguerre_rcolor13  = laguerre_mlag13 > laguerre_mlag13prev ? color.rgb(255, 198, 63)  :   laguerre_mlag13 < laguerre_mlag13prev ?   #FF0000 : color.orange
laguerre_rcolor14  = laguerre_mlag14 > laguerre_mlag14prev ? color.rgb(255, 198, 63)  :   laguerre_mlag14 < laguerre_mlag14prev ?   #FF0000 : color.orange
laguerre_rcolor15  = laguerre_mlag15 > laguerre_mlag15prev ? color.rgb(255, 198, 63)  :   laguerre_mlag15 < laguerre_mlag15prev ?   #FF0000 : color.orange
laguerre_rcolor16  = laguerre_mlag16 > laguerre_mlag16prev ? color.rgb(255, 198, 63)  :   laguerre_mlag16 < laguerre_mlag16prev ?   #FF0000 : color.orange
laguerre_rcolor17  = laguerre_mlag17 > laguerre_mlag17prev ? color.rgb(255, 198, 63)  :   laguerre_mlag17 < laguerre_mlag17prev ?   #FF0000 : color.orange
laguerre_rcolor18  = laguerre_mlag18 > laguerre_mlag18prev ? color.rgb(255, 198, 63)  :   laguerre_mlag18 < laguerre_mlag18prev ?   #FF0000 : color.orange
laguerre_rcolor19  = laguerre_mlag19 > laguerre_mlag19prev ? color.rgb(255, 198, 63)  :   laguerre_mlag19 < laguerre_mlag19prev ?   #FF0000 : color.orange

laguerre_bcolor    = laguerre_amlag > laguerre_amlagprev ? color.lime : laguerre_amlag < laguerre_amlagprev ? color.red : color.orange
laguerre_rbarcolor = laguerre_rbc==0 ? laguerre_rcolor0 : laguerre_rbc==1 ? laguerre_rcolor1 : laguerre_rbc==2 ? laguerre_rcolor2 : laguerre_rbc==3 ? laguerre_rcolor3 : laguerre_rbc==4 ? laguerre_rcolor4 : laguerre_rbc==5 ? laguerre_rcolor5 : laguerre_rbc==6 ? laguerre_rcolor6 : laguerre_rbc==7 ? laguerre_rcolor7 : laguerre_rbc==8 ? laguerre_rcolor8 : laguerre_rbc==9 ? laguerre_rcolor9 : laguerre_rbc==10 ? laguerre_rcolor10 : laguerre_rbc==11 ? laguerre_rcolor11 : laguerre_rbc==12 ? laguerre_rcolor12 : laguerre_rbc==13 ? laguerre_rcolor13 : laguerre_rbc==14 ? laguerre_rcolor14 : laguerre_rbc==15 ? laguerre_rcolor15 : laguerre_rbc==16 ? laguerre_rcolor16 : laguerre_rbc==17 ? laguerre_rcolor17 : laguerre_rbc==18 ? laguerre_rcolor18 : laguerre_rbc==19 ? laguerre_rcolor19: laguerre_bcolor
laguerre_barcolor  = laguerre_mode==1 ? laguerre_rbarcolor : laguerre_bcolor


//-----------------------------------------------------------------------------------------------------------------------------------------------------------------
//Plots
//-----------------------------------------------------------------------------------------------------------------------------------------------------------------

//Ribbon Plots
//plot(mode==1 ? mlag19 : na, color=rcolor19, linewidth=3, title="Laguerre Filter 19")
//plot(laguerre_mode==1 ? laguerre_mlag18 : na, color=laguerre_rcolor18, linewidth=2, display=display.all-display.status_line, title="Laguerre Filter 18")
//plot(laguerre_mode==1 ? laguerre_mlag16 : na, color=laguerre_rcolor16, linewidth=3, display=display.all-display.status_line, title="Laguerre Filter 16")
//plot(laguerre_mode==1 ? laguerre_mlag15 : na, color=laguerre_rcolor15, linewidth=3, display=display.all-display.status_line, title="Laguerre Filter 15")
// plot(laguerre_mode==1 ? laguerre_mlag14 : na, color=laguerre_rcolor14, linewidth=2, display=display.all-display.status_line, title="Laguerre Filter 14")
// plot(laguerre_mode==1 ? laguerre_mlag13 : na, color=laguerre_rcolor13, linewidth=1, display=display.all-display.status_line, title="Laguerre Filter 13")
// plot(laguerre_mode==1 ? laguerre_mlag12 : na, color=laguerre_rcolor12, linewidth=1, display=display.all-display.status_line, title="Laguerre Filter 12")
// plot(laguerre_mode==1 ? laguerre_mlag11 : na, color=laguerre_rcolor11, linewidth=1, display=display.all-display.status_line, title="Laguerre Filter 11")
//plot(laguerre_mode==1 ? laguerre_mlag10 : na, color=laguerre_rcolor10, linewidth=7, display=display.all-display.status_line, title="Laguerre Filter 10")
// plot(laguerre_mode==1 ? laguerre_mlag9 : na,  color=laguerre_rcolor9,  linewidth=1, display=display.all-display.status_line, title="Laguerre Filter 9")
// plot(laguerre_mode==1 ? laguerre_mlag8 : na,  color=laguerre_rcolor8,  linewidth=1, display=display.all-display.status_line, title="Laguerre Filter 8")
// plot(laguerre_mode==1 ? laguerre_mlag7 : na,  color=laguerre_rcolor7,  linewidth=1, display=display.all-display.status_line, title="Laguerre Filter 7")
//plot(laguerre_mode==1 ? laguerre_mlag6 : na,  color=laguerre_rcolor6,  linewidth=2, display=display.all-display.status_line, title="Laguerre Filter 6")
plot(laguerre_mode==1 ? laguerre_mlag5 : na,  color=laguerre_rcolor5,  linewidth=3, display=display.all-display.status_line, title="Laguerre Filter 5")
plot(laguerre_mode==1 ? laguerre_mlag4 : na,  color=laguerre_rcolor4,  linewidth=3, display=display.all-display.status_line, title="Laguerre Filter 4")
plot(laguerre_mode==1 ? laguerre_mlag3 : na,  color=laguerre_rcolor3,  linewidth=3, display=display.all-display.status_line, title="Laguerre Filter 3")
plot(laguerre_mode==1 ? laguerre_mlag2 : na,  color=laguerre_rcolor2,  linewidth=3, display=display.all-display.status_line, title="Laguerre Filter 2")
plot(laguerre_mode==1 ? laguerre_mlag1 : na,  color=laguerre_rcolor1,  linewidth=3, display=display.all-display.status_line, title="Laguerre Filter 1")
plot(laguerre_mode==1 ? laguerre_mlag0 : na,  color=laguerre_rcolor0,  linewidth=3, display=display.all-display.status_line, title="Laguerre Filter 0")


// //Band Plots
// laguerre_hplot2 = plot(laguerre_mode==2 ? laguerre_hb2 : na,   color=laguerre_bcolor, linewidth=1, title="High Band 2")
// laguerre_hplot1 = plot(laguerre_mode==2 ? laguerre_hb1 : na,   color=laguerre_bcolor, linewidth=1, title="High Band 1")
// laguerre_alplot = plot(laguerre_mode==2 ? laguerre_amlag : na, color=laguerre_bcolor, linewidth=3, title="Average Laguerre Filter")
// laguerre_lplot1 = plot(laguerre_mode==2 ? laguerre_lb1 : na,   color=laguerre_bcolor, linewidth=1, title="Low Band 1")
// laguerre_lplot2 = plot(laguerre_mode==2 ? laguerre_lb2 : na,   color=laguerre_bcolor, linewidth=1, title="Low Band 2")

//Band Fills
// fill(laguerre_hplot1, laguerre_hplot2, color=laguerre_bcolor, title="High Band Fill")
// fill(laguerre_lplot1, laguerre_lplot2, color=laguerre_bcolor, title="Low Band Fill")




// //touhid

// // This Pine Script‚Ñ¢ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// // ¬© ChartPrime

// // //@version=6
// // indicator("Fibonacci Trend [ChartPrime]", overlay = true, max_lines_count = 500)

// // --------------------------------------------------------------------------------------------------------------------
// // ùôêùôéùôÄùôç ùôÑùôâùôãùôêùôèùôé
// // --------------------------------------------------------------------------------------------------------------------

// // bool  trend_on_fibonanci_crtprime = input.bool(true, "Show Trend", inline = "trend", group = "Fibonacci Trend", display = _display)
// // float trend__fibonanci_crtprime   = input.float(4, "Trend", step = 0.01, inline = "trend", group = "Fibonacci Trend", display = _display)
// // color col1_fibonanci_crtprime     = input.color(#26905d, "", inline = "trend", group = "Fibonacci Trend", display = _display)
// // color col2_fibonanci_crtprime     = input.color(#74286d, "", inline = "trend", group = "Fibonacci Trend", display = _display)

// // int   extend_fibonanci_crtprime   = input.int(10, "Extend", group = "Fibonacci", inline = "1", display = _display)
// // color fill_col_fibonanci_crtprime = input.color(#2689901c, "", group = "Fibonacci", inline = "1", display = _display)

// // float v_236_fibonanci_crtprime = input.float(0.236, "1", display = _display) * 100
// // float v_382_fibonanci_crtprime = input.float(0.382, "2", display = _display) * 100
// // float v_618_fibonanci_crtprime = input.float(0.618, "3", display = _display) * 100
// // float v_786_fibonanci_crtprime = input.float(0.786, "4", display = _display) * 100
// // int   lienwidth_fibonanci_crtprime   = input.int(1, "Fibo Line Width", group = "Fibonacci Design", inline = "1", display = _display)
// // color   llabelback_fibonanci_crtprime   = input.color(#74286d, "Fibo Label Color", inline = "trend", group = "Fibonacci Design", display = _display)
// // // --------------------------------------------------------------------------------------------------------------------
// // // ùôêùòøùôè
// // // --------------------------------------------------------------------------------------------------------------------

// // type data_fibonanci_crtprime
// //     line fib05  = na
// //     line fib0   = na
// //     line fib236 = na
// //     line fib382 = na
// //     line fib618 = na
// //     line fib786 = na
// //     line fib_   = na
// //     line fib_di = na

// //     label H = na
// //     label L = na

// //     label L0   = na
// //     label L236 = na
// //     label L382 = na
// //     label L618 = na
// //     label L786 = na
// //     label L_   = na

// // var fib_d_fibonanci_crtprime = data_fibonanci_crtprime.new()

// // // --------------------------------------------------------------------------------------------------------------------
// // // ùôÑùôâùòøùôÑùòæùòºùôèùôäùôç ùòæùòºùôáùòæùôêùôáùòºùôèùôÑùôäùôâùôé
// // // --------------------------------------------------------------------------------------------------------------------

// // [supertrend_fibonanci_crtprime, direction_fibonanci_crtprime] = ta.supertrend(trend__fibonanci_crtprime, 25)

// // draw_fibb_fibonanci_crtprime(trend_fibonanci_crtprime)=>
// //     var h = float(na)
// //     var l = float(na)
// //     var hi = int(na)
// //     var li = int(na)

// //     var val_0 = float(na)
// //     var val_ = float(na)

// //     atr_fibonanci_crtprime = ta.atr(200)

// //     // delete previous fibb
// //     if trend_fibonanci_crtprime != trend_fibonanci_crtprime[1]
// //         line.delete(fib_d_fibonanci_crtprime.fib_)
// //         line.delete(fib_d_fibonanci_crtprime.fib0)
// //         line.delete(fib_d_fibonanci_crtprime.fib05)
// //         line.delete(fib_d_fibonanci_crtprime.fib_di)
// //         line.delete(fib_d_fibonanci_crtprime.fib236)
// //         line.delete(fib_d_fibonanci_crtprime.fib382)
// //         line.delete(fib_d_fibonanci_crtprime.fib618)
// //         line.delete(fib_d_fibonanci_crtprime.fib786)
// //         label.delete(fib_d_fibonanci_crtprime.H)
// //         label.delete(fib_d_fibonanci_crtprime.L)
// //         label.delete(fib_d_fibonanci_crtprime.L0)
// //         label.delete(fib_d_fibonanci_crtprime.L_)
// //         label.delete(fib_d_fibonanci_crtprime.L236)
// //         label.delete(fib_d_fibonanci_crtprime.L382)
// //         label.delete(fib_d_fibonanci_crtprime.L618)
// //         label.delete(fib_d_fibonanci_crtprime.L786)

// //     // Create Fib Lines
// //     if trend_fibonanci_crtprime != trend_fibonanci_crtprime[1] and trend_fibonanci_crtprime == -1
// //         fib_d_fibonanci_crtprime.fib_ := line.new(bar_index, low, bar_index, low, color = chart.fg_color, width = lienwidth_fibonanci_crtprime)
// //         fib_d_fibonanci_crtprime.fib0 := line.new(bar_index, high + atr_fibonanci_crtprime * 3, bar_index, high + atr_fibonanci_crtprime * 3, color = chart.fg_color, width = lienwidth_fibonanci_crtprime)

// //     if trend_fibonanci_crtprime != trend_fibonanci_crtprime[1] and trend_fibonanci_crtprime == 1
// //         fib_d_fibonanci_crtprime.fib_ := line.new(bar_index, high, bar_index, high, color = chart.fg_color, width = lienwidth_fibonanci_crtprime)
// //         fib_d_fibonanci_crtprime.fib0 := line.new(bar_index, low - atr_fibonanci_crtprime * 3, bar_index, low - atr_fibonanci_crtprime * 3, color = chart.fg_color, width = lienwidth_fibonanci_crtprime)
// //         fib_d_fibonanci_crtprime.fib_di := line.new(li, l, hi, h, style = line.style_dashed, color = chart.fg_color, width = lienwidth_fibonanci_crtprime)

// //     // Extend fibb lines
// //     if trend_fibonanci_crtprime == trend_fibonanci_crtprime[1]
// //         if low < fib_d_fibonanci_crtprime.fib_.get_y1()
// //             fib_d_fibonanci_crtprime.fib_.set_y1(low)
// //             fib_d_fibonanci_crtprime.fib_.set_y2(low)

// //         if high > fib_d_fibonanci_crtprime.fib0.get_y1()
// //             fib_d_fibonanci_crtprime.fib0.set_y1(high)
// //             fib_d_fibonanci_crtprime.fib0.set_y2(high)

// //         if high == fib_d_fibonanci_crtprime.fib0.get_y1()
// //             h := high
// //             hi := bar_index
// //             label.delete((fib_d_fibonanci_crtprime[1]).H)
// //             fib_d_fibonanci_crtprime.H := label.new(hi, h, str.tostring(h, "#,###.####"), color = #15373b)

// //         if low == fib_d_fibonanci_crtprime.fib_.get_y1()
// //             l := low
// //             li := bar_index
// //             label.delete((fib_d_fibonanci_crtprime[1]).L)
// //             fib_d_fibonanci_crtprime.L := label.new(li, l, str.tostring(l, "#,###.####"), style = label.style_label_up, color = #15373b)

// //         fib_d_fibonanci_crtprime.fib_.set_x2(bar_index + extend_fibonanci_crtprime)
// //         fib_d_fibonanci_crtprime.fib0.set_x2(bar_index + extend_fibonanci_crtprime)

// //         line.delete((fib_d_fibonanci_crtprime[1]).fib_di)
// //         fib_d_fibonanci_crtprime.fib_di := line.new(li, l, hi, h, style = line.style_dashed, color = chart.fg_color)

// //         if fib_d_fibonanci_crtprime.fib_di.get_x1() < fib_d_fibonanci_crtprime.fib0.get_x1() or fib_d_fibonanci_crtprime.fib_di.get_x2() < fib_d_fibonanci_crtprime.fib0.get_x1()
// //             line.delete(fib_d_fibonanci_crtprime.fib_di)

// //         size_step = (fib_d_fibonanci_crtprime.fib0.get_y1() - fib_d_fibonanci_crtprime.fib_.get_y1()) / 100

// //         line.delete((fib_d_fibonanci_crtprime[1]).fib05)
// //         line.delete((fib_d_fibonanci_crtprime[1]).fib382)
// //         line.delete((fib_d_fibonanci_crtprime[1]).fib236)
// //         line.delete((fib_d_fibonanci_crtprime[1]).fib618)
// //         line.delete((fib_d_fibonanci_crtprime[1]).fib786)

// //         if trend_fibonanci_crtprime == -1
// //             val_0 := fib_d_fibonanci_crtprime.fib0.get_y1()
// //             val_  := fib_d_fibonanci_crtprime.fib_.get_y1()

// //         if trend_fibonanci_crtprime == 1
// //             val_0 := fib_d_fibonanci_crtprime.fib_.get_y1()
// //             val_  := fib_d_fibonanci_crtprime.fib0.get_y1()

// //         fib_d_fibonanci_crtprime.fib236 := line.new(fib_d_fibonanci_crtprime.fib0.get_x1(), val_0 - size_step * v_236_fibonanci_crtprime * trend_fibonanci_crtprime * -1, fib_d_fibonanci_crtprime.fib0.get_x2(), val_0 - size_step * v_236_fibonanci_crtprime * trend_fibonanci_crtprime * -1, color = chart.fg_color, width =lienwidth_fibonanci_crtprime)
// //         fib_d_fibonanci_crtprime.fib382 := line.new(fib_d_fibonanci_crtprime.fib0.get_x1(), val_0 - size_step * v_382_fibonanci_crtprime * trend_fibonanci_crtprime * -1, fib_d_fibonanci_crtprime.fib0.get_x2(), val_0 - size_step * v_382_fibonanci_crtprime * trend_fibonanci_crtprime * -1, color = chart.fg_color, width = lienwidth_fibonanci_crtprime)
// //         fib_d_fibonanci_crtprime.fib05  := line.new(fib_d_fibonanci_crtprime.fib0.get_x1(), val_0 - size_step * 50 * trend_fibonanci_crtprime * -1, fib_d_fibonanci_crtprime.fib0.get_x2(), val_0 - size_step * 50 * trend_fibonanci_crtprime * -1, color = #FFD700, style = line.style_dotted, width = 6)
// //         fib_d_fibonanci_crtprime.fib618 := line.new(fib_d_fibonanci_crtprime.fib0.get_x1(), val_0 - size_step * v_618_fibonanci_crtprime * trend_fibonanci_crtprime * -1, fib_d_fibonanci_crtprime.fib0.get_x2(), val_0 - size_step * v_618_fibonanci_crtprime * trend_fibonanci_crtprime * -1, color = chart.fg_color, width = lienwidth_fibonanci_crtprime)
// //         fib_d_fibonanci_crtprime.fib786 := line.new(fib_d_fibonanci_crtprime.fib0.get_x1(), val_0 - size_step * v_786_fibonanci_crtprime * trend_fibonanci_crtprime * -1, fib_d_fibonanci_crtprime.fib0.get_x2(), val_0 - size_step * v_786_fibonanci_crtprime * trend_fibonanci_crtprime * -1, color = chart.fg_color, width = lienwidth_fibonanci_crtprime)

// //         label.delete((fib_d_fibonanci_crtprime[1]).L0)
// //         label.delete((fib_d_fibonanci_crtprime[1]).L_)
// //         label.delete((fib_d_fibonanci_crtprime[1]).L236)
// //         label.delete((fib_d_fibonanci_crtprime[1]).L382)
// //         label.delete((fib_d_fibonanci_crtprime[1]).L618)
// //         label.delete((fib_d_fibonanci_crtprime[1]).L786)

// //         fib_d_fibonanci_crtprime.L0 := label.new(bar_index + extend_fibonanci_crtprime, val_0,  text = "0 DN " + str.tostring(val_0, "(#,###.####)"), textcolor = chart.fg_color, color = llabelback_fibonanci_crtprime, style = label.style_label_left)
// //         fib_d_fibonanci_crtprime.L_ := label.new(bar_index + extend_fibonanci_crtprime, val_,   text = "1 UP " + str.tostring(val_, "(#,###.####)"), textcolor = chart.fg_color, color = llabelback_fibonanci_crtprime, style = label.style_label_left)
// //         fib_d_fibonanci_crtprime.L236 := label.new(bar_index + extend_fibonanci_crtprime, fib_d_fibonanci_crtprime.fib236.get_y1(), text = str.tostring(v_236_fibonanci_crtprime / 100) + str.tostring(fib_d_fibonanci_crtprime.fib236.get_y1(), " (#,###.####)"), textcolor = chart.fg_color, color = llabelback_fibonanci_crtprime, style = label.style_label_left)
// //         fib_d_fibonanci_crtprime.L382 := label.new(bar_index + extend_fibonanci_crtprime, fib_d_fibonanci_crtprime.fib382.get_y1(), text = str.tostring(v_382_fibonanci_crtprime / 100) + str.tostring(fib_d_fibonanci_crtprime.fib382.get_y1(), " (#,###.####)"), textcolor = chart.fg_color, color = llabelback_fibonanci_crtprime, style = label.style_label_left)
// //         fib_d_fibonanci_crtprime.L618 := label.new(bar_index + extend_fibonanci_crtprime, fib_d_fibonanci_crtprime.fib618.get_y1(), text = str.tostring(v_618_fibonanci_crtprime / 100) + str.tostring(fib_d_fibonanci_crtprime.fib618.get_y1(), " (#,###.####)"), textcolor = chart.fg_color, color = llabelback_fibonanci_crtprime, style = label.style_label_left)
// //         fib_d_fibonanci_crtprime.L786 := label.new(bar_index + extend_fibonanci_crtprime, fib_d_fibonanci_crtprime.fib786.get_y1(), text = str.tostring(v_786_fibonanci_crtprime / 100) + str.tostring(fib_d_fibonanci_crtprime.fib786.get_y1(), " (#,###.####)"), textcolor = chart.fg_color, color = llabelback_fibonanci_crtprime, style = label.style_label_left)

// //         // linefill.new(fib_d_fibonanci_crtprime.fib618, fib_d_fibonanci_crtprime.fib786, fill_col_fibonanci_crtprime)
// //         // linefill.new(fib_d_fibonanci_crtprime.fib05, fib_d_fibonanci_crtprime.fib786, fill_col_fibonanci_crtprime)

// // // --------------------------------------------------------------------------------------------------------------------
// // // ùôëùôÑùôéùôêùòºùôáùôÑùôïùòºùôèùôÑùôäùôâ
// // // --------------------------------------------------------------------------------------------------------------------

// // draw_fibb_fibonanci_crtprime(direction_fibonanci_crtprime)

// // //color_fibonanci_crtprime = trend_on_fibonanci_crtprime ? (direction_fibonanci_crtprime == 1 ? col2_fibonanci_crtprime : col1_fibonanci_crtprime) : na
// // //p1_fibonanci_crtprime = plot(supertrend_fibonanci_crtprime, "Trend", color = direction_fibonanci_crtprime != direction_fibonanci_crtprime[1] ? na : color_fibonanci_crtprime, style = plot.style_linebr)
// // //p2_fibonanci_crtprime = plot(hl2, display = display.none)

// // //fill(p1_fibonanci_crtprime, p2_fibonanci_crtprime, hl2, supertrend_fibonanci_crtprime, na, direction_fibonanci_crtprime != direction_fibonanci_crtprime[1] ? na : color.new(color_fibonanci_crtprime, 0))












// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// INPUT PARAMETERS
// Advanced Trend Momentum [Alpha Extract]
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// Trend Analysis Settings
// Trend Analysis Settings
trendGroup_momentum_alpha_extract = "‚ïê‚ïê‚ïê TREND ANALYSIS ‚ïê‚ïê‚ïê"

emaFastLen_momentum_alpha_extract = input.int(12, display=_display, title="Fast EMA Length", minval=1, group=trendGroup_momentum_alpha_extract)
emaSlowLen_momentum_alpha_extract = input.int(26, display=_display, title="Slow EMA Length", minval=1, group=trendGroup_momentum_alpha_extract)
trendStrength_momentum_alpha_extract = input.int(14, display=_display, title="Trend Strength Period", minval=1, group=trendGroup_momentum_alpha_extract)

srGroup_momentum_alpha_extract =  "‚ïê‚ïê‚ïê SUPPORT & RESISTANCE ‚ïê‚ïê‚ïê"
// Support & Resistance Settings
pivotLength_momentum_alpha_extract = input.int(10, display=_display, title="Pivot Length", minval=2, group=srGroup_momentum_alpha_extract)
maxLevels_momentum_alpha_extract = input.int(4, display=_display, title="Max S/R Levels", minval=1, maxval=5, group=srGroup_momentum_alpha_extract)
showSRLevels_momentum_alpha_extract = input.bool(true, display=_display, title="Show S/R Levels", group=srGroup_momentum_alpha_extract)

// Momentum Settings
// Momentum Settings
momentumGroup = "‚ïê‚ïê‚ïê MOMENTUM ‚ïê‚ïê‚ïê"

rsiLength_momentum_alpha_extract = input.int(14, display=_display, title="RSI Length", minval=1, group=momentumGroup)
oversoldLevel_momentum_alpha_extract = input.int(35, display=_display, title="Oversold Level", minval=1, maxval=49, group=momentumGroup)
overboughtLevel_momentum_alpha_extract = input.int(70, display=_display, title="Overbought Level", minval=51, maxval=99, group=momentumGroup)


// Visual Settings
visualGroup = "‚ïê‚ïê‚ïê VISUAL SETTINGS ‚ïê‚ïê‚ïê"

show_colored_candles_momentum_alpha_extract = input.bool(true, display=_display, title="Show Colored Candles", group=visualGroup)
bullColor_momentum_alpha_extract = input.color(#089981, display=_display, title="Bullish Color", group=visualGroup)
bearColor_momentum_alpha_extract = input.color(#FF6B6B, display=_display, title="Bearish Color", group=visualGroup)
neutralColor_momentum_alpha_extract = input.color(#95A5A6, display=_display, title="Neutral Color", group=visualGroup)
transparency_momentum_alpha_extract = input.int(80, display=_display, title="Fill Transparency", minval=0, maxval=100, group=visualGroup)


// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// CALCULATIONS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// EMAs for trend analysis
emaFast_momentum_alpha_extract = ta.ema(close, emaFastLen_momentum_alpha_extract)
emaSlow_momentum_alpha_extract = ta.ema(close, emaSlowLen_momentum_alpha_extract)

// Trend direction and strength
trendDirection_momentum_alpha_extract = emaFast_momentum_alpha_extract > emaSlow_momentum_alpha_extract ? 1 : -1
trendStrengthValue_momentum_alpha_extract = math.abs(emaFast_momentum_alpha_extract - emaSlow_momentum_alpha_extract) / ta.atr(trendStrength_momentum_alpha_extract) * 100

// RSI for momentum
rsi_momentum_alpha_extract = ta.rsi(close, rsiLength_momentum_alpha_extract)
rsiOverbought_momentum_alpha_extract = rsi_momentum_alpha_extract > overboughtLevel_momentum_alpha_extract
rsiOversold_momentum_alpha_extract = rsi_momentum_alpha_extract < oversoldLevel_momentum_alpha_extract

// Advanced momentum calculation
momentumValue_momentum_alpha_extract = ta.change(close, 5) / ta.atr(10) * 100

// Support and Resistance levels using pivot points
pivotHigh_momentum_alpha_extract = ta.pivothigh(high, pivotLength_momentum_alpha_extract, pivotLength_momentum_alpha_extract)
pivotLow_momentum_alpha_extract = ta.pivotlow(low, pivotLength_momentum_alpha_extract, pivotLength_momentum_alpha_extract)

// Store recent pivot levels
var float[] resistanceLevels_momentum_alpha_extract = array.new<float>()
var float[] supportLevels_momentum_alpha_extract = array.new<float>()

if not na(pivotHigh_momentum_alpha_extract)
    array.unshift(resistanceLevels_momentum_alpha_extract, pivotHigh_momentum_alpha_extract)
    if array.size(resistanceLevels_momentum_alpha_extract) > maxLevels_momentum_alpha_extract
        array.pop(resistanceLevels_momentum_alpha_extract)

if not na(pivotLow_momentum_alpha_extract)
    array.unshift(supportLevels_momentum_alpha_extract, pivotLow_momentum_alpha_extract)
    if array.size(supportLevels_momentum_alpha_extract) > maxLevels_momentum_alpha_extract
        array.pop(supportLevels_momentum_alpha_extract)

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// VISUAL ELEMENTS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// RSI VISUAL ENHANCEMENTS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

//// Plot RSI with enhanced visuals
// plotRSI_momentum_alpha_extract = plot(rsi_momentum_alpha_extract, 'Relative Strength Index', color=#95A5A6, linewidth=1)
// plotRSI2_momentum_alpha_extract = plot(rsi_momentum_alpha_extract*0.97, 'Relative Strength Index', color=#95A5A6, linewidth=1, display = display.pane) 
// fill(plotRSI_momentum_alpha_extract,plotRSI2_momentum_alpha_extract , color = color.new(#95A5A6,80))

//// Overbought and Oversold levels with better styling
// overboughtline_momentum_alpha_extract = hline(overboughtLevel_momentum_alpha_extract, 'RSI Overbought', color=color.new(bearColor_momentum_alpha_extract, 60), linewidth=1, linestyle=hline.style_dashed)
// overboughtline2_momentum_alpha_extract = hline(overboughtLevel_momentum_alpha_extract*1.02, 'RSI Overbought', color=color.new(bearColor_momentum_alpha_extract, 60), linewidth=1, linestyle=hline.style_dashed)

overboughtline2p_momentum_alpha_extract = plot(overboughtLevel_momentum_alpha_extract*1.02, 'RSI Overbought', color=color.new(bearColor_momentum_alpha_extract, 60), linewidth=1,display = display.none)
rsibc_momentum_alpha_extract = #ffffff00
if rsi_momentum_alpha_extract*0.97 > overboughtLevel_momentum_alpha_extract*1.02  
    rsibc_momentum_alpha_extract := color.new(bearColor_momentum_alpha_extract,80)
if rsi_momentum_alpha_extract*0.97 < overboughtLevel_momentum_alpha_extract*1.02  
    rsibc_momentum_alpha_extract := #ffffff00    

rsibc2_momentum_alpha_extract = #ffffff00
if rsi_momentum_alpha_extract > oversoldLevel_momentum_alpha_extract*0.95 
    rsibc2_momentum_alpha_extract := #ffffff00
if rsi_momentum_alpha_extract < oversoldLevel_momentum_alpha_extract*0.95 
    rsibc2_momentum_alpha_extract := color.new(bullColor_momentum_alpha_extract,80)

//fill(plotRSI2_momentum_alpha_extract,overboughtline2p_momentum_alpha_extract,color = rsibc_momentum_alpha_extract)
//fill(overboughtline_momentum_alpha_extract,overboughtline2_momentum_alpha_extract , color = color.new(bearColor_momentum_alpha_extract,80))
//oversoldline_momentum_alpha_extract = hline(oversoldLevel_momentum_alpha_extract, 'RSI Oversold', color=color.new(bullColor_momentum_alpha_extract, 60), linewidth=1, linestyle=hline.style_dashed)
//oversoldline2_momentum_alpha_extract = hline(oversoldLevel_momentum_alpha_extract*0.95, 'RSI Oversold', color=color.new(bullColor_momentum_alpha_extract, 60), linewidth=1, linestyle=hline.style_dashed)

//oversoldline2p_momentum_alpha_extract = plot(oversoldLevel_momentum_alpha_extract*0.95, 'RSI Oversold', color=color.new(bullColor_momentum_alpha_extract, 60), linewidth=1,display = display.none)
// fill(plotRSI_momentum_alpha_extract,oversoldline2p_momentum_alpha_extract,color = rsibc2_momentum_alpha_extract)
//fill(oversoldline_momentum_alpha_extract,oversoldline2_momentum_alpha_extract , color = color.new(bullColor_momentum_alpha_extract,80))

// Midline for reference
// hline(50, 'RSI Midline', color=color.new(neutralColor_momentum_alpha_extract, 50), linewidth=1, linestyle=hline.style_dotted)
// m1_momentum_alpha_extract = hline(48, 'RSI Midline', color=color.new(neutralColor_momentum_alpha_extract, 70), linewidth=1, linestyle=hline.style_dotted)
// m2_momentum_alpha_extract = hline(52, 'RSI Midline', color=color.new(neutralColor_momentum_alpha_extract, 70), linewidth=1, linestyle=hline.style_dotted)
// fill(m1_momentum_alpha_extract,m2_momentum_alpha_extract,color = color.new(neutralColor_momentum_alpha_extract,80))

// Plot EMAs with dynamic colors
emaFastColor_momentum_alpha_extract = trendDirection_momentum_alpha_extract > 0 ? bullColor_momentum_alpha_extract : bearColor_momentum_alpha_extract
emaSlowColor_momentum_alpha_extract = trendDirection_momentum_alpha_extract > 0 ? color.new(bullColor_momentum_alpha_extract, 40) : color.new(bearColor_momentum_alpha_extract, 40)

// plotEmaFast_momentum_alpha_extract = plot(emaFast_momentum_alpha_extract, "Fast EMA", color=emaFastColor_momentum_alpha_extract, linewidth=2,force_overlay = true)
// plotEmaSlow_momentum_alpha_extract = plot(emaSlow_momentum_alpha_extract, "Slow EMA", color=emaSlowColor_momentum_alpha_extract, linewidth=2,force_overlay = true)

// // Trend fill between EMAs
// fillColor_momentum_alpha_extract = trendDirection_momentum_alpha_extract > 0 ? 
//      color.new(bullColor_momentum_alpha_extract, transparency_momentum_alpha_extract) : 
//      color.new(bearColor_momentum_alpha_extract, transparency_momentum_alpha_extract)


// fill(plotEmaFast_momentum_alpha_extract, plotEmaSlow_momentum_alpha_extract, color=fillColor_momentum_alpha_extract, title="Trend Fill")

// Support and Resistance levels
if showSRLevels_momentum_alpha_extract and barstate.islast
    if array.size(resistanceLevels_momentum_alpha_extract) > 0
        for i = 0 to math.min(array.size(resistanceLevels_momentum_alpha_extract) - 1, maxLevels_momentum_alpha_extract - 1)
            if i < array.size(resistanceLevels_momentum_alpha_extract)
                level = array.get(resistanceLevels_momentum_alpha_extract, i)
                line.new(bar_index - 100, level, bar_index, level, 
                         color=color.new(bearColor_momentum_alpha_extract, 30), style=line.style_dashed, width=1, extend=extend.both,force_overlay = true)
    
    // Plot support levels  
    if array.size(supportLevels_momentum_alpha_extract) > 0
        for i = 0 to math.min(array.size(supportLevels_momentum_alpha_extract) - 1, maxLevels_momentum_alpha_extract - 1)
            if i < array.size(supportLevels_momentum_alpha_extract)
                level = array.get(supportLevels_momentum_alpha_extract, i)
                line.new(bar_index - 100, level, bar_index, level, 
                         color=color.new(bullColor_momentum_alpha_extract, 30), style=line.style_dashed, width=1, extend=extend.both,force_overlay = true)

// Momentum-based bar coloring
barColor_momentum_alpha_extract = if show_colored_candles_momentum_alpha_extract
    if rsiOverbought_momentum_alpha_extract and momentumValue_momentum_alpha_extract < 0
        bearColor_momentum_alpha_extract
    else if rsiOversold_momentum_alpha_extract and momentumValue_momentum_alpha_extract > 0
        bullColor_momentum_alpha_extract
    else if trendDirection_momentum_alpha_extract > 0 and momentumValue_momentum_alpha_extract > 0
        bullColor_momentum_alpha_extract
    else if trendDirection_momentum_alpha_extract < 0 and momentumValue_momentum_alpha_extract < 0
        bearColor_momentum_alpha_extract
    else
        neutralColor_momentum_alpha_extract
else
    na

//plotcandle(open, high, low, close, title="Trend Strength Candles", color=barColor_momentum_alpha_extract, wickcolor=barColor_momentum_alpha_extract, bordercolor=barColor_momentum_alpha_extract, force_overlay=true, display=show_colored_candles_momentum_alpha_extract  ? display.pane : display.none)

// SIGNALS AND ALERTS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// Trend change signals
trendChange_momentum_alpha_extract = ta.change(trendDirection_momentum_alpha_extract)
bullishSignal_momentum_alpha_extract = trendChange_momentum_alpha_extract > 0 and trendStrengthValue_momentum_alpha_extract > 1
bearishSignal_momentum_alpha_extract = trendChange_momentum_alpha_extract < 0 and trendStrengthValue_momentum_alpha_extract > 1

// Plot signals

// Momentum divergence signals
bullishDivergence_momentum_alpha_extract = rsiOversold_momentum_alpha_extract and momentumValue_momentum_alpha_extract > momentumValue_momentum_alpha_extract[1] and close < close[1]
bearishDivergence_momentum_alpha_extract = rsiOverbought_momentum_alpha_extract and momentumValue_momentum_alpha_extract < momentumValue_momentum_alpha_extract[1] and close > close[1]

// plotshape(bullishDivergence_momentum_alpha_extract, "Bullish Divergence", shape.diamond, location.belowbar, 
//           color=color.new(bullColor_momentum_alpha_extract, 30), size=size.small,force_overlay = true)
// plotshape(bearishDivergence_momentum_alpha_extract, "Bearish Divergence", shape.diamond, location.abovebar, 
//           color=color.new(bearColor_momentum_alpha_extract, 30), size=size.small,force_overlay = true)

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// TABLE DISPLAY
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// // Create info table
// if barstate.islast
//     var infoTable = table.new(position.top_right, 2, 5, bgcolor=color.rgb(0, 0, 0), 
//                                border_width=1, border_color=color.rgb(255, 255, 255))
    
//     // Table headers and data
//     table.cell(infoTable, 0, 0, "Metric", text_color=color.rgb(255, 255, 255), text_size=size.normal, bgcolor=color.new(color.gray, 80))
//     table.cell(infoTable, 1, 0, "Value", text_color=color.rgb(255, 255, 255), text_size=size.normal, bgcolor=color.new(color.gray, 80))
    
//     // Trend direction
//     trendText = trendDirection_momentum_alpha_extract > 0 ? "BULLISH" : "BEARISH"
//     trendTextColor = trendDirection_momentum_alpha_extract > 0 ? bullColor_momentum_alpha_extract : bearColor_momentum_alpha_extract
//     table.cell(infoTable, 0, 1, "Trend", text_color=color.rgb(255, 255, 255), text_size=size.normal)
//     table.cell(infoTable, 1, 1, trendText, text_color=trendTextColor, text_size=size.normal)
    
//     // Trend strength
//     strengthText = str.tostring(math.round(trendStrengthValue_momentum_alpha_extract, 2)) + "%"
//     table.cell(infoTable, 0, 2, "Strength", text_color=color.rgb(255, 255, 255), text_size=size.normal)
//     table.cell(infoTable, 1, 2, strengthText, text_color=color.rgb(255, 255, 255), text_size=size.normal)
    
//     // RSI
//     rsiText = str.tostring(math.round(rsi_momentum_alpha_extract, 1))
//     rsiColor = rsiOverbought_momentum_alpha_extract ? bearColor_momentum_alpha_extract : rsiOversold_momentum_alpha_extract ? bullColor_momentum_alpha_extract : color.rgb(255, 255, 255)
//     table.cell(infoTable, 0, 3, "RSI", text_color=color.rgb(255, 255, 255), text_size=size.normal)
//     table.cell(infoTable, 1, 3, rsiText, text_color=rsiColor, text_size=size.normal)
    
//     // Momentum
//     momentumText = str.tostring(math.round(momentumValue_momentum_alpha_extract, 1))
//     momentumColor = momentumValue_momentum_alpha_extract > 0 ? bullColor_momentum_alpha_extract : bearColor_momentum_alpha_extract
//     table.cell(infoTable, 0, 4, "Momentum", text_color=color.rgb(255, 255, 255), text_size=size.normal)
//     table.cell(infoTable, 1, 4, momentumText, text_color=momentumColor, text_size=size.normal)

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ALERTS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// // Alert conditions
// alertcondition(bullishSignal_momentum_alpha_extract, title="Bullish Trend Change", 
//                message="{{ticker}} - Bullish trend detected! Fast EMA crossed above Slow EMA with strong momentum.")
// alertcondition(bearishSignal_momentum_alpha_extract, title="Bearish Trend Change", 
//                message="{{ticker}} - Bearish trend detected! Fast EMA crossed below Slow EMA with strong momentum.")
// alertcondition(bullishDivergence_momentum_alpha_extract, title="Bullish Divergence", 
//                message="{{ticker}} - Potential bullish divergence detected in oversold conditions.")
// alertcondition(bearishDivergence_momentum_alpha_extract, title="Bearish Divergence", 
//                message="{{ticker}} - Potential bearish divergence detected in overbought conditions.")












// This Pine Script‚Ñ¢ code is subject to the terms of the Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) https://creativecommons.org/licenses/by-nc-sa/4.0/
// ¬© UAlgo
//@version=6
///indicator(title='Wave Surge [UAlgo]', shorttitle='Wave Surge [UAlgo]', overlay=true)

// Input Parameters
var string GROUP_NAME = "Wave Surge Settings"
wave_period = input(5, 'Wave Period', group=GROUP_NAME)
baseline_length = input(14, 'Baseline Length', group=GROUP_NAME)
baseline_type = input.string('ema', 'Baseline Type', options=['vwma', 'ema', 'sma', 'hma'], group=GROUP_NAME)
source_type = input.string('hlc3', 'Source Type', options=['close', 'hlc3', 'hl2'], group=GROUP_NAME)

// Threshold Settings
use_adaptive_threshold = input.bool(true, 'Use Adaptive Threshold', group=GROUP_NAME)
adaptive_period = input(500, 'Adaptive Period', group=GROUP_NAME)
sensitivity = input.float(0.001, 'Sensitivity Factor', group=GROUP_NAME)

// Volume Analysis
use_volume_analysis = input.bool(true, 'Use Volume Analysis', group=GROUP_NAME)
volume_scan_period = input.int(5, 'Volume Scan Period', group=GROUP_NAME)
volume_factor = input.float(1.0, 'Volume Factor', group=GROUP_NAME)

// Wave Calculations
waveH = ta.ema(high, wave_period)
waveL = ta.ema(low, wave_period)
waveC = ta.ema(close, wave_period)
priorWaveH = ta.valuewhen(true, waveH, 1)
priorWaveL = ta.valuewhen(true, waveL, 1)
priorWaveC = ta.valuewhen(true, waveC, 1)
deltaH = high - priorWaveH
deltaL = low - priorWaveL
deltaC = close - priorWaveC

// Volume Analysis Implementation
volume_average = ta.sma(volume, volume_scan_period)
volume_ratio = volume / ta.valuewhen(true, volume_average, 1)

// Adaptive Threshold Implementation
adaptive_level = use_adaptive_threshold ? ta.sma(hlc3, adaptive_period) * sensitivity : 0

// Signal Generation
threshold_prior = ta.valuewhen(true, adaptive_level, 1)
high_signal = deltaH > threshold_prior ? 1 : 0
low_signal = deltaL > threshold_prior ? 1 : 0
close_signal = deltaC > threshold_prior ? 1 : 0

wave_pattern = high_signal * 4 + low_signal * 2 + close_signal

final_pattern = use_volume_analysis ? volume_ratio > volume_factor ? wave_pattern : 0 : wave_pattern

// Baseline Calculation
var float baseline = na

if baseline_type == 'vwma'
    baseline := ta.vwma(source_type == 'close' ? close : source_type == 'hlc3' ? hlc3 : hl2, baseline_length)
else if baseline_type == 'ema'
    baseline := ta.ema(source_type == 'close' ? close : source_type == 'hlc3' ? hlc3 : hl2, baseline_length)
else if baseline_type == 'sma'
    baseline := ta.sma(source_type == 'close' ? close : source_type == 'hlc3' ? hlc3 : hl2, baseline_length)
else if baseline_type == 'hma'
    baseline := ta.hma(source_type == 'close' ? close : source_type == 'hlc3' ? hlc3 : hl2, baseline_length)

baseline_rising = baseline > baseline[1]
baseline_falling = baseline < baseline[1]

// // Visual Signals
// plotshape(final_pattern == 1 and baseline_falling ? low : na, title='Wave1', style=shape.labelup, location=location.absolute, text='ü°π', color=color(na), size=size.normal, textcolor=color.new(color.aqua, 10))
// plotshape(final_pattern == 3 and baseline_rising ? high : na, title='Wave3', style=shape.labeldown, location=location.absolute, text='ü°ª', color=color(na), size=size.normal, textcolor=color.new(color.red, 10))
// plotshape(final_pattern == 4 and baseline_rising ? high : na, title='Wave4', style=shape.labeldown, location=location.absolute, text='ü°ª', color=color(na), size=size.normal, textcolor=color.new(color.red, 10))
// plotshape(final_pattern == 5 and baseline_falling ? low : na, title='Wave5', style=shape.labelup, location=location.absolute, text='ü°π', color=color(na), size=size.normal, textcolor=color.new(color.aqua, 10))
// plotshape(final_pattern == 6 and baseline_rising ? high : na, title='Wave6', style=shape.labeldown, location=location.absolute, text='ü°ª', color=color(na), size=size.normal, textcolor=color.new(color.red, 10))

// Baseline Visualization
baseline_plot = plot(baseline, color=baseline_rising ? color.aqua : color.rgb(114, 0, 139), title='Baseline', linewidth=7)
price_plot = plot(hl2, display=display.none)
fill(baseline_plot, price_plot, baseline_rising ? color.new(color.aqua, 75) : color.new(color.red, 85))

// Alert Conditions
// alertcondition(final_pattern == 1 and baseline_falling, title="Bullish Wave 1", message="Bullish Wave 1 Signal Detected")
// alertcondition(final_pattern == 3 and baseline_rising, title="Bearish Wave 3", message="Bearish Wave 3 Signal Detected")
// alertcondition(final_pattern == 4 and baseline_rising, title="Bearish Wave 4", message="Bearish Wave 4 Signal Detected")
// alertcondition(final_pattern == 5 and baseline_falling, title="Bullish Wave 5", message="Bullish Wave 5 Signal Detected")
// alertcondition(final_pattern == 6 and baseline_rising, title="Bearish Wave 6", message="Bearish Wave 6 Signal Detected")












