// This work is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International  
// https://creativecommons.org/licenses/by-nc-sa/4.0/

// Â© Zeiierman {
//@version=6
indicator('ðŸ‘‘ðŸ‘‘ðŸ”´ [UST] Protein + TIM Dynamic Swing Anchored VWAP (Zeiierman)', shorttitle = "ðŸ‘‘ðŸ‘‘ðŸ”´ Swing VWAP + [UST] Protein+", overlay = true, max_bars_back = 5000, max_labels_count = 10, max_polylines_count = 100)
//~~}

// ~~ Tooltips {
var string t1_zeiierman = "Number of bars used to detect swing highs and lows. Larger values identify bigger, more significant swings but react slower. Smaller values detect more frequent swings but may produce more noise."
var string t2_zeiierman = "Controls how quickly the VWAP adjusts to new price action. Lower values make the VWAP react faster (tighter to price), higher values make it smoother and slower to change."
var string t3_zeiierman = "When enabled, the VWAP reaction speed changes automatically based on market volatility. High volatility shortens the tracking period (more responsive), low volatility lengthens it (smoother)."
var string t4_zeiierman = "Controls how strongly volatility influences the VWAP reaction speed. Values above 1 increase the effect of volatility changes; values below 1 make it less sensitive to volatility."
var string t5_zeiierman = "Color used for swing high/low labels drawn on the chart to indicate pivot points."
var string t6_zeiierman = "Color used for swing low labels when marking pivot points."
var string t7_zeiierman = "Color used for VWAP lines when in an uptrend."
var string t8_zeiierman = "Color used for VWAP lines when in a downtrend."
var string t9_zeiierman = "Width of the VWAP lines drawn on the chart. Larger values make the lines thicker and more visible."

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
_display = display.none
// ~~ Inputs {
prd_zeiierman      = input.int(50, display=_display, group='Swing Points', title='Swing Period', minval=2, tooltip=t1_zeiierman)
baseAPT_zeiierman  = input.float(20, display=_display, group='Swing Points', title='Adaptive Price Tracking', minval=1, step=1, tooltip=t2_zeiierman)
useAdapt_zeiierman = input.bool(false, display=_display, group='Swing Points', title='Adapt APT by ATR ratio', tooltip=t3_zeiierman)
volBias_zeiierman  = input.float(10.0, display=_display, group='Swing Points', title='Volatility Bias', minval=0.1, step=0.1, tooltip=t4_zeiierman)

highS_zeiierman = input.color(color.lime, display=_display, group="Style", title="Swing Labels", inline="Swing", tooltip=t5_zeiierman)
lowS_zeiierman  = input.color(color.red, display=_display, group="Style", title="", inline="Swing", tooltip=t6_zeiierman)
S_zeiierman     = input.color(color.lime, display=_display, group="Style", title="VWAP Lines", inline="VWAP", tooltip=t7_zeiierman)
R_zeiierman     = input.color(color.red, display=_display, group="Style", title="", inline="VWAP", tooltip=t8_zeiierman)
xx_zeiierman    = input.int(2, display=_display, group="Style", title="", inline="VWAP", minval=1, tooltip=t9_zeiierman)

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}

// ~~ Global Variable {
b_zeiierman = bar_index
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}

// ~~ PIVOTS Variables {
var ph_zeiierman   = float(na)
var pl_zeiierman   = float(na)
var phL_zeiierman  = b_zeiierman
var plL_zeiierman  = b_zeiierman
var lab_zeiierman  = label(na)
var prev_zeiierman = float(na)

ph_zeiierman  := ta.highestbars(high, prd_zeiierman) == 0 ? high : ph_zeiierman
pl_zeiierman  := ta.lowestbars(low, prd_zeiierman) == 0 ? low : pl_zeiierman
phL_zeiierman := ta.highestbars(high, prd_zeiierman) == 0 ? b_zeiierman : phL_zeiierman
plL_zeiierman := ta.lowestbars(low, prd_zeiierman) == 0 ? b_zeiierman : plL_zeiierman
dir_zeiierman = phL_zeiierman > plL_zeiierman ? 1 : -1

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}

// ~~ Adaptation {
atrLen_zeiierman = 50
atr_zeiierman    = ta.atr(atrLen_zeiierman)
atrAvg_zeiierman = ta.rma(atr_zeiierman, atrLen_zeiierman)
ratio_zeiierman  = atrAvg_zeiierman > 0 ? atr_zeiierman / atrAvg_zeiierman : 1.0

aptRaw     = useAdapt_zeiierman ? baseAPT_zeiierman / math.pow(ratio_zeiierman, volBias_zeiierman) : baseAPT_zeiierman
aptClamped = math.max(5.0, math.min(300.0, aptRaw))
aptSeries  = math.round(aptClamped)

// alpha from APT (half-life -> EWMA alpha)
alphaFromAPT(apt) =>
    decay = math.exp(-math.log(2.0) / math.max(1.0, apt))
    1.0 - decay
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}

// ~~ VWAP Variables {
var p_zeiierman   = hlc3 * volume 
var vol_zeiierman = volume      

type dataPoints
    array<chart.point> points
    polyline poly = na

var vwap_zeiierman = dataPoints.new(array.new<chart.point>())
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}

// ~~ Main {
if dir_zeiierman != dir_zeiierman[1]
    x_zeiierman   = dir_zeiierman > 0 ? plL_zeiierman : phL_zeiierman
    y_zeiierman   = dir_zeiierman > 0 ? pl_zeiierman  : ph_zeiierman
    loc_zeiierman = dir_zeiierman > 0 ? label.style_label_up : label.style_label_down
    col_zeiierman = dir_zeiierman > 0 ? highS_zeiierman : lowS_zeiierman
    txt_zeiierman = dir_zeiierman > 0 and pl_zeiierman < prev_zeiierman ? 'LL' : dir_zeiierman > 0 and pl_zeiierman > prev_zeiierman ? 'HL' : dir_zeiierman < 0 and ph_zeiierman < prev_zeiierman ? 'LH' : dir_zeiierman < 0 and ph_zeiierman > prev_zeiierman ? 'HH' : ''
    label.new(x_zeiierman, y_zeiierman, text=txt_zeiierman, style=loc_zeiierman, color=color.new(col_zeiierman, 20), textcolor=color.white)
    prev_zeiierman := dir_zeiierman > 0 ? ph_zeiierman[1] : pl_zeiierman[1]


    barsback_zeiierman = b_zeiierman - x_zeiierman
    p_zeiierman   := y_zeiierman * volume[barsback_zeiierman]
    vol_zeiierman := volume[barsback_zeiierman]
    vap_zeiierman = p_zeiierman / vol_zeiierman

    vwap_zeiierman.poly.delete()
    polyline.new(vwap_zeiierman.points, false, false, line_color = dir_zeiierman < 0 ? R_zeiierman : S_zeiierman, line_width = xx_zeiierman)
    vwap_zeiierman.points.clear()

    for i = barsback_zeiierman to 0 by 1
        apt_i = aptSeries[i]
        alpha = alphaFromAPT(apt_i)

        pxv   = hlc3[i] * volume[i]
        v_i   = volume[i]

        p_zeiierman     := (1.0 - alpha) * p_zeiierman + alpha * pxv
        vol_zeiierman   := (1.0 - alpha) * vol_zeiierman + alpha * v_i
        vappe_zeiierman = vol_zeiierman > 0 ? p_zeiierman / vol_zeiierman : na

        vwap_zeiierman.points.push(chart.point.from_index(b_zeiierman - i, vappe_zeiierman))

    vwap_zeiierman.poly := polyline.new(vwap_zeiierman.points, false, false, line_color = dir_zeiierman < 0 ? R_zeiierman : S_zeiierman, line_width = xx_zeiierman)

else
    apt_0 = aptSeries
    alpha = alphaFromAPT(apt_0)

    pxv = hlc3 * volume
    v0  = volume

    p_zeiierman   := (1.0 - alpha) * p_zeiierman + alpha * pxv
    vol_zeiierman := (1.0 - alpha) * vol_zeiierman + alpha * v0
    vap_zeiierman = vol_zeiierman > 0 ? p_zeiierman / vol_zeiierman : na

    vwap_zeiierman.poly.delete()
    vwap_zeiierman.points.push(chart.point.from_index(b_zeiierman, vap_zeiierman))
    vwap_zeiierman.poly := polyline.new(vwap_zeiierman.points, false, false, line_color = dir_zeiierman > 0 ? R_zeiierman : S_zeiierman, line_width = xx_zeiierman)
//~~ }










// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© Funded Coffee

//@version=6
//indicator('[UST] Protein+', max_lines_count = 500, max_labels_count = 500, overlay = true, max_bars_back = 1000)

show_current_sr = input.bool(true, title = 'Show Current TF S/R', group = 'Setting')
swing_length = input.int(10, title = 'Swing Length', group = 'Setting', minval = 1, maxval = 50)
history_of_demand_to_keep = input.int(20, title = 'Lookback', minval = 5, maxval = 50, group = 'Setting')
box_width = input.float(5, title = 'S/R Range', group = 'Setting', minval = 1, maxval = 10, step = 0.5)

// Body Type Selection
pivot_source = input.string('Close', title = 'Pivot Source', options = ['Close', 'Open'], group = 'Setting')

string group3 = 'TF Setting'
enableHtf1 = input.bool(false, group = group3, inline = 'htf1', title = '')
htf1 = input.timeframe('W', 'TF1', group = group3, inline = 'htf1')
enableHtf2 = input.bool(false, group = group3, inline = 'htf2', title = '')
htf2 = input.timeframe('D', 'TF2', group = group3, inline = 'htf2')
enableHtf3 = input.bool(false, group = group3, inline = 'htf3', title = '')
htf3 = input.timeframe('240', 'TF3', group = group3, inline = 'htf3')
enableHtf4 = input.bool(false, group = group3, inline = 'htf4', title = '')
htf4 = input.timeframe('180', 'TF4', group = group3, inline = 'htf4')
enableHtf5 = input.bool(false, group = group3, inline = 'htf5', title = '')
htf5 = input.timeframe('120', 'TF5', group = group3, inline = 'htf5')
enableHtf6 = input.bool(false, group = group3, inline = 'htf6', title = '')
htf6 = input.timeframe('60', 'TF6', group = group3, inline = 'htf6')
enableHtf7 = input.bool(false, group = group3, inline = 'htf7', title = '')
htf7 = input.timeframe('45', 'TF7', group = group3, inline = 'htf7')
enableHtf8 = input.bool(false, group = group3, inline = 'htf8', title = '')
htf8 = input.timeframe('30', 'TF8', group = group3, inline = 'htf8')
enableHtf9 = input.bool(false, group = group3, inline = 'htf9', title = '')
htf9 = input.timeframe('15', 'TF9', group = group3, inline = 'htf9')

supply_color = input.color(color.rgb(242, 54, 69, 0.9), title = 'Support Zone', group = 'Color Settings', inline = '3')
supply_outline_color = input.color(color.rgb(242, 54, 69, 0.9), title = 'BoS', group = 'Color Settings', inline = '3')

demand_color = input.color(color.rgb(41, 98, 255, 0.9), title = 'Resistance Zone', group = 'Color Settings', inline = '4')
demand_outline_color = input.color(color.rgb(41, 98, 255, 0.9), title = 'BoR', group = 'Color Settings', inline = '4')

// bos_label_color = input.color(color.white, title = 'Fracture Zone', group = 'Color Settings', inline = '5')
poi_label_color = input.color(color.white, title = 'S/R Zone Label', group = 'Color Settings', inline = '7')

type zone_with_strength
	box zone
	int count = 0
	string tf

//      FUNCTION TO ADD NEW AND REMOVE LAST IN ARRAY
array_add_pop(array, new_value_to_add) =>
    array.unshift(array, new_value_to_add)
    array.pop(array)

// FUNCTION MAKE SURE SUPPLY ISNT OVERLAPPING
check_overlapping(new_poi, box_array, atr) =>
    atr_threshold = atr * 2
    okay_to_draw = true

    for i = 0 to array.size(box_array) - 1 by 1
        zone_with_strength zws = array.get(box_array, i)
        if not na(zws)
            box b = zws.zone
            top = box.get_top(b)
            bottom = box.get_bottom(b)
            poi = (top + bottom) / 2

            upper_boundary = poi + atr_threshold
            lower_boundary = poi - atr_threshold

            if new_poi >= lower_boundary and new_poi <= upper_boundary
                okay_to_draw := false
                break
            else
                okay_to_draw := true
                okay_to_draw

    okay_to_draw

// FUNCTION TO DRAW SUPPLY OR DEMAND ZONE
support_resistance(value_array, bn_array, box_array, label_array, count_array, box_type, atr, tf_label, tfbarindex, is_htf) =>

    atr_buffer = atr * (box_width / 10)

    box_left = is_htf ? bar_index : array.get(bn_array, 0)
    box_right = bar_index

    var float box_top = 0.00
    var float box_bottom = 0.00
    var float poi = 0.00

    if box_type == 1
        box_bottom := array.get(value_array, 0)
        box_top := box_bottom + atr_buffer
        poi := (box_top + box_bottom) / 2
        poi
    else if box_type == -1
        box_top := array.get(value_array, 0)
        box_bottom := box_top - atr_buffer
        poi := (box_top + box_bottom) / 2
        poi

    okay_to_draw = check_overlapping(poi, box_array, atr)
    // okay_to_draw = true
    //delete oldest box, and then create a new box and add it to the array
    if box_type == 1 and okay_to_draw
        zone_with_strength last = array.get(box_array, array.size(box_array) - 1)
        if not na(last)
            box.delete(last.zone)
        box b = box.new(left = box_left, top = box_top, right = bar_index, bottom = box_bottom, border_color = supply_outline_color, bgcolor = color.new(supply_color, 80), extend = extend.none, text = tf_label, text_halign = text.align_right, text_valign = text.align_center, text_color = poi_label_color, text_size = size.small, xloc = xloc.bar_index)
        zone_with_strength zws = zone_with_strength.new(b, 0, tf_label)
        array_add_pop(box_array, zws)

    else if box_type == -1 and okay_to_draw
        zone_with_strength last = array.get(box_array, array.size(box_array) - 1)
        if not na(last)
            box.delete(last.zone)
        box b = box.new(left = box_left, top = box_top, right = bar_index, bottom = box_bottom, border_color = demand_outline_color, bgcolor = color.new(demand_color, 80), extend = extend.none, text = tf_label, text_halign = text.align_right, text_valign = text.align_center, text_color = poi_label_color, text_size = size.small, xloc = xloc.bar_index)
        zone_with_strength zws = zone_with_strength.new(b, 0, tf_label)
        array_add_pop(box_array, zws)

//      FUNCTION TO CHANGE SUPPLY/DEMAND TO A BOS IF BROKEN
sd_to_bos(box_array, bos_array, count_array, label_array, zone_type, tfclose, tfbarindex) =>
    for i = 0 to array.size(box_array) - 1 by 1
        zone_with_strength zws = array.get(box_array, i)
        if not na(zws)
            box b = zws.zone
            level_to_break_top = box.get_top(b)
            level_to_break_bottom = box.get_bottom(b)
            // if ta.crossover(close, level_to_break)
            if zone_type == 1 and close >= level_to_break_top or zone_type == -1 and close <= level_to_break_bottom
                copied_zone = zone_with_strength.copy(zws)
                box cz = copied_zone.zone
                mid = (box.get_top(b) + box.get_bottom(b)) / 2
                line bosline = line.new(box.get_left(cz), mid, bar_index, mid, xloc.bar_index, extend.none, zone_type == 1 ? supply_outline_color : demand_outline_color, line.style_dotted)
                array_add_pop(bos_array, bosline)
                // box bos = array.get(bos_array, 0)
                // box.set_top(bos, mid)
                // box.set_bottom(bos, mid)
                // box.set_right(bos, bar_index)
                // box.set_extend(bos, extend.none)
                // box.set_text(bos, '')
                // box.set_text_color( bos, bos_label_color)
                // box.set_text_size(bos, size.small)
                // box.set_text_halign(bos, text.align_center)
                // box.set_text_valign(bos, text.align_center)
                box.delete(b)
                array.set(box_array, i, na)
                // array.remove(box_array, i)
                // box.delete(array.get(label_array, i))

//      FUNCTION MANAGE CURRENT BOXES BY CHANGING ENDPOINT
extend_box_endpoint(box_array, count_array, tfbarindex, tfhigh, tflow) =>
    for i = 0 to array.size(box_array) - 1 by 1
        zone_with_strength zws = array.get(box_array, i)
        if not na(zws)
            box b = zws.zone
            top = box.get_top(b)
            bottom = box.get_bottom(b)
            count = zws.count
            if high[swing_length - 1] >= bottom and high[swing_length - 1] <= top or low[swing_length - 1] >= bottom and low[swing_length - 1] <= top
                count := count + 1
                zws.count := count
                zws.count
            // count := count + 1
            // zws.count := count
            box.set_right(b, bar_index + 40)
            box.set_text(b, str.format('{0} / {1}', count, zws.tf))
            zws.zone := b
            array.set(box_array, i, zws)

//
//END FUNCTIONS
//  

//
// CALCULATIONS FOR SUPPORT AND RESISTANCE
//
calculateSR(swing_high_values, swing_low_values, swing_high_bns, swing_low_bns, supply_zone, demand_zone, current_supply_touch_count, current_demand_touch_count, current_supply_poi, current_demand_poi, supply_bos, demand_bos, series1, series2, tf_label, tfbarindex, tfclose, atr, is_htf, swing_high, swing_low, swing_index) =>
    //      NEW SWING HIGH
    if not na(swing_high)

        //MANAGE SWING HIGH VALUES
        array_add_pop(swing_high_values, swing_high)
        array_add_pop(swing_high_bns, swing_index)

        support_resistance(swing_high_values, swing_high_bns, supply_zone, current_supply_poi, current_supply_touch_count, 1, atr, tf_label, tfbarindex, is_htf)

    //      NEW SWING LOW
    else if not na(swing_low)

        //MANAGE SWING LOW VALUES
        array_add_pop(swing_low_values, swing_low)
        array_add_pop(swing_low_bns, swing_index)

        support_resistance(swing_low_values, swing_low_bns, demand_zone, current_demand_poi, current_demand_touch_count, -1, atr, tf_label, tfbarindex, is_htf)


    sd_to_bos(supply_zone, supply_bos, current_supply_touch_count, current_supply_poi, 1, tfclose, tfbarindex)
    sd_to_bos(demand_zone, demand_bos, current_demand_touch_count, current_demand_poi, -1, tfclose, tfbarindex)

    extend_box_endpoint(supply_zone, current_supply_touch_count, tfbarindex, series1, series2)
    extend_box_endpoint(demand_zone, current_demand_touch_count, tfbarindex, series1, series2)

var swing_high_values = array.new_float(5, 0.00)
var swing_low_values = array.new_float(5, 0.00)

var swing_high_bns = array.new_int(5, 0)
var swing_low_bns = array.new_int(5, 0)

//      ARRAYS FOR SUPPORT / RESISTANCE POI LABELS
var current_supply_poi = array.new_box(history_of_demand_to_keep, na)
var current_demand_poi = array.new_box(history_of_demand_to_keep, na)

var supply_zones = array.new<zone_with_strength>(history_of_demand_to_keep, na)
var demand_zones = array.new<zone_with_strength>(history_of_demand_to_keep, na)

var touches_for_supply = array.new_int(history_of_demand_to_keep, 0)
var touches_for_demand = array.new_int(history_of_demand_to_keep, 0)

//      ARRAYS FOR BOS
var supply_bos = array.new_line(5, na)
var demand_bos = array.new_line(5, na)

var swing_high_values1 = array.new_float(5, 0.00)
var swing_low_values1 = array.new_float(5, 0.00)

var swing_high_bns1 = array.new_int(5, 0)
var swing_low_bns1 = array.new_int(5, 0)

//      ARRAYS FOR SUPPORT / RESISTANCE
var supply_zones1 = array.new<zone_with_strength>(history_of_demand_to_keep, na)
var demand_zones1 = array.new<zone_with_strength>(history_of_demand_to_keep, na)

var touches_for_supply1 = array.new_int(history_of_demand_to_keep, 0)
var touches_for_demand1 = array.new_int(history_of_demand_to_keep, 0)

//      ARRAYS FOR SUPPORT / RESISTANCE POI LABELS
var current_supply_poi1 = array.new_box(history_of_demand_to_keep, na)
var current_demand_poi1 = array.new_box(history_of_demand_to_keep, na)

//      ARRAYS FOR BOS
var supply_bos1 = array.new_line(5, na)
var demand_bos1 = array.new_line(5, na)

var swing_high_values2 = array.new_float(5, 0.00)
var swing_low_values2 = array.new_float(5, 0.00)

var swing_high_bns2 = array.new_int(5, 0)
var swing_low_bns2 = array.new_int(5, 0)

//      ARRAYS FOR SUPPORT / RESISTANCE
var supply_zones2 = array.new<zone_with_strength>(history_of_demand_to_keep, na)
var demand_zones2 = array.new<zone_with_strength>(history_of_demand_to_keep, na)

var touches_for_supply2 = array.new_int(history_of_demand_to_keep, 0)
var touches_for_demand2 = array.new_int(history_of_demand_to_keep, 0)

//      ARRAYS FOR SUPPORT / RESISTANCE POI LABELS
var current_supply_poi2 = array.new_box(history_of_demand_to_keep, na)
var current_demand_poi2 = array.new_box(history_of_demand_to_keep, na)

//      ARRAYS FOR BOS
var supply_bos2 = array.new_line(5, na)
var demand_bos2 = array.new_line(5, na)

var swing_high_values3 = array.new_float(5, 0.00)
var swing_low_values3 = array.new_float(5, 0.00)

var swing_high_bns3 = array.new_int(5, 0)
var swing_low_bns3 = array.new_int(5, 0)

//      ARRAYS FOR SUPPORT / RESISTANCE
var supply_zones3 = array.new<zone_with_strength>(history_of_demand_to_keep, na)
var demand_zones3 = array.new<zone_with_strength>(history_of_demand_to_keep, na)

var touches_for_supply3 = array.new_int(history_of_demand_to_keep, 0)
var touches_for_demand3 = array.new_int(history_of_demand_to_keep, 0)

//      ARRAYS FOR SUPPORT / RESISTANCE POI LABELS
var current_supply_poi3 = array.new_box(history_of_demand_to_keep, na)
var current_demand_poi3 = array.new_box(history_of_demand_to_keep, na)

//      ARRAYS FOR BOS
var supply_bos3 = array.new_line(5, na)
var demand_bos3 = array.new_line(5, na)

var swing_high_values4 = array.new_float(5, 0.00)
var swing_low_values4 = array.new_float(5, 0.00)

var swing_high_bns4 = array.new_int(5, 0)
var swing_low_bns4 = array.new_int(5, 0)

//      ARRAYS FOR SUPPORT / RESISTANCE
var supply_zones4 = array.new<zone_with_strength>(history_of_demand_to_keep, na)
var demand_zones4 = array.new<zone_with_strength>(history_of_demand_to_keep, na)

var touches_for_supply4 = array.new_int(history_of_demand_to_keep, 0)
var touches_for_demand4 = array.new_int(history_of_demand_to_keep, 0)

//      ARRAYS FOR SUPPORT / RESISTANCE POI LABELS
var current_supply_poi4 = array.new_box(history_of_demand_to_keep, na)
var current_demand_poi4 = array.new_box(history_of_demand_to_keep, na)

//      ARRAYS FOR BOS
var supply_bos4 = array.new_line(5, na)
var demand_bos4 = array.new_line(5, na)

var swing_high_values5 = array.new_float(5, 0.00)
var swing_low_values5 = array.new_float(5, 0.00)

var swing_high_bns5 = array.new_int(5, 0)
var swing_low_bns5 = array.new_int(5, 0)

//      ARRAYS FOR SUPPORT / RESISTANCE
var supply_zones5 = array.new<zone_with_strength>(history_of_demand_to_keep, na)
var demand_zones5 = array.new<zone_with_strength>(history_of_demand_to_keep, na)

var touches_for_supply5 = array.new_int(history_of_demand_to_keep, 0)
var touches_for_demand5 = array.new_int(history_of_demand_to_keep, 0)

//      ARRAYS FOR SUPPORT / RESISTANCE POI LABELS
var current_supply_poi5 = array.new_box(history_of_demand_to_keep, na)
var current_demand_poi5 = array.new_box(history_of_demand_to_keep, na)

//      ARRAYS FOR BOS
var supply_bos5 = array.new_line(5, na)
var demand_bos5 = array.new_line(5, na)

var swing_high_values6 = array.new_float(5, 0.00)
var swing_low_values6 = array.new_float(5, 0.00)

var swing_high_bns6 = array.new_int(5, 0)
var swing_low_bns6 = array.new_int(5, 0)

//      ARRAYS FOR SUPPORT / RESISTANCE
var supply_zones6 = array.new<zone_with_strength>(history_of_demand_to_keep, na)
var demand_zones6 = array.new<zone_with_strength>(history_of_demand_to_keep, na)

var touches_for_supply6 = array.new_int(history_of_demand_to_keep, 0)
var touches_for_demand6 = array.new_int(history_of_demand_to_keep, 0)

//      ARRAYS FOR SUPPORT / RESISTANCE POI LABELS
var current_supply_poi6 = array.new_box(history_of_demand_to_keep, na)
var current_demand_poi6 = array.new_box(history_of_demand_to_keep, na)

//      ARRAYS FOR BOS
var supply_bos6 = array.new_line(5, na)
var demand_bos6 = array.new_line(5, na)

var swing_high_values7 = array.new_float(5, 0.00)
var swing_low_values7 = array.new_float(5, 0.00)

var swing_high_bns7 = array.new_int(5, 0)
var swing_low_bns7 = array.new_int(5, 0)

//      ARRAYS FOR SUPPORT / RESISTANCE
var supply_zones7 = array.new<zone_with_strength>(history_of_demand_to_keep, na)
var demand_zones7 = array.new<zone_with_strength>(history_of_demand_to_keep, na)

var touches_for_supply7 = array.new_int(history_of_demand_to_keep, 0)
var touches_for_demand7 = array.new_int(history_of_demand_to_keep, 0)

//      ARRAYS FOR SUPPORT / RESISTANCE POI LABELS
var current_supply_poi7 = array.new_box(history_of_demand_to_keep, na)
var current_demand_poi7 = array.new_box(history_of_demand_to_keep, na)

//      ARRAYS FOR BOS
var supply_bos7 = array.new_line(5, na)
var demand_bos7 = array.new_line(5, na)

var swing_high_values8 = array.new_float(5, 0.00)
var swing_low_values8 = array.new_float(5, 0.00)

var swing_high_bns8 = array.new_int(5, 0)
var swing_low_bns8 = array.new_int(5, 0)

//      ARRAYS FOR SUPPORT / RESISTANCE
var supply_zones8 = array.new<zone_with_strength>(history_of_demand_to_keep, na)
var demand_zones8 = array.new<zone_with_strength>(history_of_demand_to_keep, na)

var touches_for_supply8 = array.new_int(history_of_demand_to_keep, 0)
var touches_for_demand8 = array.new_int(history_of_demand_to_keep, 0)

//      ARRAYS FOR SUPPORT / RESISTANCE POI LABELS
var current_supply_poi8 = array.new_box(history_of_demand_to_keep, na)
var current_demand_poi8 = array.new_box(history_of_demand_to_keep, na)

//      ARRAYS FOR BOS
var supply_bos8 = array.new_line(5, na)
var demand_bos8 = array.new_line(5, na)

var swing_high_values9 = array.new_float(5, 0.00)
var swing_low_values9 = array.new_float(5, 0.00)

var swing_high_bns9 = array.new_int(5, 0)
var swing_low_bns9 = array.new_int(5, 0)

//      ARRAYS FOR SUPPORT / RESISTANCE
var supply_zones9 = array.new<zone_with_strength>(history_of_demand_to_keep, na)
var demand_zones9 = array.new<zone_with_strength>(history_of_demand_to_keep, na)

var touches_for_supply9 = array.new_int(history_of_demand_to_keep, 0)
var touches_for_demand9 = array.new_int(history_of_demand_to_keep, 0)

//      ARRAYS FOR SUPPORT / RESISTANCE POI LABELS
var current_supply_poi9 = array.new_box(history_of_demand_to_keep, na)
var current_demand_poi9 = array.new_box(history_of_demand_to_keep, na)

//      ARRAYS FOR BOS
var supply_bos9 = array.new_line(5, na)
var demand_bos9 = array.new_line(5, na)

// Select the source based on user input
body_source = pivot_source == 'Close' ? close : open

atr = ta.atr(50)
if show_current_sr
    cur_tf_label = timeframe.isintraday ? str.tostring(timeframe.in_seconds() / 60, '#.## MIN') : timeframe.period
    // Use the body source for pivot detection instead of high/low
    swing_high = ta.pivothigh(body_source, swing_length, swing_length)
    swing_low = ta.pivotlow(body_source, swing_length, swing_length)
    swing_index = bar_index[swing_length]
    calculateSR(swing_high_values, swing_low_values, swing_high_bns, swing_low_bns, supply_zones, demand_zones, touches_for_supply, touches_for_demand, current_supply_poi, current_demand_poi, supply_bos, demand_bos, high, low, cur_tf_label, bar_index, close, atr, false, swing_high, swing_low, swing_index)


// SUPPORT / RESISTANCE FOR HTF1
[high1, low1, close1, open1, barindex1, atr1, timeframe1, swing_high1, swing_low1, swing_index1] = request.security(syminfo.tickerid, htf1, [high, low, close, open, bar_index, ta.atr(50), timeframe.isintraday ? str.tostring(timeframe.in_seconds() / 60, '#.## MIN') : timeframe.period, ta.pivothigh(pivot_source == 'Close' ? close : open, swing_length, swing_length), ta.pivotlow(pivot_source == 'Close' ? close : open, swing_length, swing_length), bar_index[swing_length]])

// SUPPORT / RESISTANCE FOR HTF2
[high2, low2, close2, open2, barindex2, atr2, timeframe2, swing_high2, swing_low2, swing_index2] = request.security(syminfo.tickerid, htf2, [high, low, close, open, bar_index, ta.atr(50), timeframe.isintraday ? str.tostring(timeframe.in_seconds() / 60, '#.## MIN') : timeframe.period, ta.pivothigh(pivot_source == 'Close' ? close : open, swing_length, swing_length), ta.pivotlow(pivot_source == 'Close' ? close : open, swing_length, swing_length), bar_index[swing_length]])

// SUPPORT / RESISTANCE FOR HTF3
[high3, low3, close3, open3, barindex3, atr3, timeframe3, swing_high3, swing_low3, swing_index3] = request.security(syminfo.tickerid, htf3, [high, low, close, open, bar_index, ta.atr(50), timeframe.isintraday ? str.tostring(timeframe.in_seconds() / 60, '#.## MIN') : timeframe.period, ta.pivothigh(pivot_source == 'Close' ? close : open, swing_length, swing_length), ta.pivotlow(pivot_source == 'Close' ? close : open, swing_length, swing_length), bar_index[swing_length]])

// SUPPORT / RESISTANCE FOR HTF4
[high4, low4, close4, open4, barindex4, atr4, timeframe4, swing_high4, swing_low4, swing_index4] = request.security(syminfo.tickerid, htf4, [high, low, close, open, bar_index, ta.atr(50), timeframe.isintraday ? str.tostring(timeframe.in_seconds() / 60, '#.## MIN') : timeframe.period, ta.pivothigh(pivot_source == 'Close' ? close : open, swing_length, swing_length), ta.pivotlow(pivot_source == 'Close' ? close : open, swing_length, swing_length), bar_index[swing_length]])

// SUPPORT / RESISTANCE FOR HTF5
[high5, low5, close5, open5, barindex5, atr5, timeframe5, swing_high5, swing_low5, swing_index5] = request.security(syminfo.tickerid, htf5, [high, low, close, open, bar_index, ta.atr(50), timeframe.isintraday ? str.tostring(timeframe.in_seconds() / 60, '#.## MIN') : timeframe.period, ta.pivothigh(pivot_source == 'Close' ? close : open, swing_length, swing_length), ta.pivotlow(pivot_source == 'Close' ? close : open, swing_length, swing_length), bar_index[swing_length]])

// SUPPORT / RESISTANCE FOR HTF6
[high6, low6, close6, open6, barindex6, atr6, timeframe6, swing_high6, swing_low6, swing_index6] = request.security(syminfo.tickerid, htf6, [high, low, close, open, bar_index, ta.atr(50), timeframe.isintraday ? str.tostring(timeframe.in_seconds() / 60, '#.## MIN') : timeframe.period, ta.pivothigh(pivot_source == 'Close' ? close : open, swing_length, swing_length), ta.pivotlow(pivot_source == 'Close' ? close : open, swing_length, swing_length), bar_index[swing_length]])

// SUPPORT / RESISTANCE FOR HTF7
[high7, low7, close7, open7, barindex7, atr7, timeframe7, swing_high7, swing_low7, swing_index7] = request.security(syminfo.tickerid, htf7, [high, low, close, open, bar_index, ta.atr(50), timeframe.isintraday ? str.tostring(timeframe.in_seconds() / 60, '#.## MIN') : timeframe.period, ta.pivothigh(pivot_source == 'Close' ? close : open, swing_length, swing_length), ta.pivotlow(pivot_source == 'Close' ? close : open, swing_length, swing_length), bar_index[swing_length]])

// SUPPORT / RESISTANCE FOR HTF8
[high8, low8, close8, open8, barindex8, atr8, timeframe8, swing_high8, swing_low8, swing_index8] = request.security(syminfo.tickerid, htf8, [high, low, close, open, bar_index, ta.atr(50), timeframe.isintraday ? str.tostring(timeframe.in_seconds() / 60, '#.## MIN') : timeframe.period, ta.pivothigh(pivot_source == 'Close' ? close : open, swing_length, swing_length), ta.pivotlow(pivot_source == 'Close' ? close : open, swing_length, swing_length), bar_index[swing_length]])

// SUPPORT / RESISTANCE FOR HTF9
[high9, low9, close9, open9, barindex9, atr9, timeframe9, swing_high9, swing_low9, swing_index9] = request.security(syminfo.tickerid, htf9, [high, low, close, open, bar_index, ta.atr(50), timeframe.isintraday ? str.tostring(timeframe.in_seconds() / 60, '#.## MIN') : timeframe.period, ta.pivothigh(pivot_source == 'Close' ? close : open, swing_length, swing_length), ta.pivotlow(pivot_source == 'Close' ? close : open, swing_length, swing_length), bar_index[swing_length]])

if enableHtf1 and htf1 != ''
    calculateSR(swing_high_values1, swing_low_values1, swing_high_bns1, swing_low_bns1, supply_zones1, demand_zones1, touches_for_supply1, touches_for_demand1, current_supply_poi1, current_demand_poi1, supply_bos1, demand_bos1, high1, low1, timeframe1, barindex1, close1, atr1, true, swing_high1, swing_low1, swing_index1)

if enableHtf2 and htf2 != ''
    calculateSR(swing_high_values2, swing_low_values2, swing_high_bns2, swing_low_bns2, supply_zones2, demand_zones2, touches_for_supply2, touches_for_demand2, current_supply_poi2, current_demand_poi2, supply_bos2, demand_bos2, high2, low2, timeframe2, barindex2, close2, atr2, true, swing_high2, swing_low2, swing_index2)

if enableHtf3 and htf3 != ''
    calculateSR(swing_high_values3, swing_low_values3, swing_high_bns3, swing_low_bns3, supply_zones3, demand_zones3, touches_for_supply3, touches_for_demand3, current_supply_poi3, current_demand_poi3, supply_bos3, demand_bos3, high3, low3, timeframe3, barindex3, close3, atr3, true, swing_high3, swing_low3, swing_index3)

if enableHtf4 and htf4 != ''
    calculateSR(swing_high_values4, swing_low_values4, swing_high_bns4, swing_low_bns4, supply_zones4, demand_zones4, touches_for_supply4, touches_for_demand4, current_supply_poi4, current_demand_poi4, supply_bos4, demand_bos4, high4, low4, timeframe4, barindex4, close4, atr4, true, swing_high4, swing_low4, swing_index4)

if enableHtf5 and htf5 != ''
    calculateSR(swing_high_values5, swing_low_values5, swing_high_bns5, swing_low_bns5, supply_zones5, demand_zones5, touches_for_supply5, touches_for_demand5, current_supply_poi5, current_demand_poi5, supply_bos5, demand_bos5, high5, low5, timeframe5, barindex5, close5, atr5, true, swing_high5, swing_low5, swing_index5)

if enableHtf6 and htf6 != ''
    calculateSR(swing_high_values6, swing_low_values6, swing_high_bns6, swing_low_bns6, supply_zones6, demand_zones6, touches_for_supply6, touches_for_demand6, current_supply_poi6, current_demand_poi6, supply_bos6, demand_bos6, high6, low6, timeframe6, barindex6, close6, atr6, true, swing_high6, swing_low6, swing_index6)

if enableHtf7 and htf7 != ''
    calculateSR(swing_high_values7, swing_low_values7, swing_high_bns7, swing_low_bns7, supply_zones7, demand_zones7, touches_for_supply7, touches_for_demand7, current_supply_poi7, current_demand_poi7, supply_bos7, demand_bos7, high7, low7, timeframe7, barindex7, close7, atr7, true, swing_high7, swing_low7, swing_index7)

if enableHtf8 and htf8 != ''
    calculateSR(swing_high_values8, swing_low_values8, swing_high_bns8, swing_low_bns8, supply_zones8, demand_zones8, touches_for_supply8, touches_for_demand8, current_supply_poi8, current_demand_poi8, supply_bos8, demand_bos8, high8, low8, timeframe8, barindex8, close8, atr8, true, swing_high8, swing_low8, swing_index8)

if enableHtf9 and htf9 != ''
    calculateSR(swing_high_values9, swing_low_values9, swing_high_bns9, swing_low_bns9, supply_zones9, demand_zones9, touches_for_supply9, touches_for_demand9, current_supply_poi9, current_demand_poi9, supply_bos9, demand_bos9, high9, low9, timeframe9, barindex9, close9, atr9, true, swing_high9, swing_low9, swing_index9)





// This work is licensed under a Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) https://creativecommons.org/licenses/by-nc-sa/4.0/
// Â© LuxAlgo

//@version=6
//indicator('Trendlines with Breaks [LuxAlgo]', 'LuxAlgo - Trendlines with Breaks', overlay = true)
//------------------------------------------------------------------------------
//Settings
//-----------------------------------------------------------------------------{
length = input.int(14, 'Swing Detection Lookback')
mult = input.float(1., 'Slope', minval = 0, step = .1)
calcMethod = input.string('Atr', 'Slope Calculation Method', options = ['Atr', 'Stdev', 'Linreg'])
backpaint = input(true, tooltip = 'Backpainting offset displayed elements in the past. Disable backpainting to see real time information returned by the indicator.')

//Style
upCss = input.color(color.teal, 'Up Trendline Color', group = 'Style')
dnCss = input.color(color.red, 'Down Trendline Color', group = 'Style')
showExt = input(true, 'Show Extended Lines')

//-----------------------------------------------------------------------------}
//Calculations
//-----------------------------------------------------------------------------{
var upper = 0.
var lower = 0.
var slope_ph = 0.
var slope_pl = 0.

var offset = backpaint ? length : 0

n = bar_index
src = close

ph = ta.pivothigh(length, length)
pl = ta.pivotlow(length, length)

//Slope Calculation Method
slope = switch calcMethod
    'Atr' => ta.atr(length) / length * mult
    'Stdev' => ta.stdev(src, length) / length * mult
    'Linreg' => math.abs(ta.sma(src * n, length) - ta.sma(src, length) * ta.sma(n, length)) / ta.variance(n, length) / 2 * mult

//Get slopes and calculate trendlines
slope_ph := bool(ph) ? slope : slope_ph
slope_pl := bool(pl) ? slope : slope_pl

upper := bool(ph) ? ph : upper - slope_ph
lower := bool(pl) ? pl : lower + slope_pl

var upos = 0
var dnos = 0
upos := bool(ph) ? 0 : close > upper - slope_ph * length ? 1 : upos
dnos := bool(pl) ? 0 : close < lower + slope_pl * length ? 1 : dnos

//-----------------------------------------------------------------------------}
//Extended Lines
//-----------------------------------------------------------------------------{
var uptl = line.new(na, na, na, na, color = upCss, style = line.style_dashed, extend = extend.right, width = 2)
var dntl = line.new(na, na, na, na, color = dnCss, style = line.style_dashed, extend = extend.right, width = 2)

if bool(ph) and showExt
    uptl.set_xy1(n - offset, backpaint ? ph : upper - slope_ph * length)
    uptl.set_xy2(n - offset + 1, backpaint ? ph - slope : upper - slope_ph * (length + 1))

if bool(pl) and showExt
    dntl.set_xy1(n - offset, backpaint ? pl : lower + slope_pl * length)
    dntl.set_xy2(n - offset + 1, backpaint ? pl + slope : lower + slope_pl * (length + 1))

//-----------------------------------------------------------------------------}
//Plots
//-----------------------------------------------------------------------------{
plot(backpaint ? upper : upper - slope_ph * length, 'Upper', color = bool(ph) ? na : upCss, offset = -offset)
plot(backpaint ? lower : lower + slope_pl * length, 'Lower', color = bool(pl) ? na : dnCss, offset = -offset)

//Breakouts
// plotshape(upos > upos[1] ? low : na, 'Upper Break', shape.labelup, location.absolute, upCss, text = 'B', textcolor = color.white, size = size.tiny)

// plotshape(dnos > dnos[1] ? high : na, 'Lower Break', shape.labeldown, location.absolute, dnCss, text = 'B', textcolor = color.white, size = size.tiny)

//-----------------------------------------------------------------------------}
//Alerts
//-----------------------------------------------------------------------------{
alertcondition(upos > upos[1], 'Upward Breakout', 'Price broke the down-trendline upward')
alertcondition(dnos > dnos[1], 'Downward Breakout', 'Price broke the up-trendline downward')

//-----------------------------------------------------------------------------}










// @ Julien_Eche

//@version=6
//indicator('Adaptive Market Profile', overlay = true, max_bars_back = 5000)

useAdaptive = input.bool(true, "Automatic detection of optimal trend channel period")
pI = input.int(200, 'Manual channel period (bars)', minval = 2)
devMultiplier = input.float(2.2, 'Deviation Multiplier', minval = 0.1, step = 0.1)
uL = input.bool(true, 'Enable if chart is in logarithmic scale')
regColor = input.color(color.new(color.gray, 0), 'Channel Lines', inline = 'reg_channel')
regLineStyle = input.string('Solid', '', options = ['Solid', 'Dotted', 'Dashed'], inline = 'reg_channel')
regLineWidth = input.int(2, '', minval = 1, maxval = 4, inline = 'reg_channel')
fillColor = input.color(color.new(#909497, 95), 'Channel Fill', inline = 'channel_fill')
showRegLine = input.bool(true, 'Show Mid Line', inline = 'reg_line')
showMostActiveLines = input.bool(true, '', inline = 'lvls')
numActivityLines = input.int(2, 'Show Most Active Lines', minval = 1, maxval = 5, inline = 'lvls')
showProfile = input.bool(true, 'Show Profile', inline = 'profile_labels')
showLabels = input.bool(false, 'Show Labels', inline = 'profile_labels')
activityMethod = input.string('Volume', 'Calculation method', options = ['Touches', 'Volume'])
nFills = input.int(23, 'Number of Profile Sections', minval = 2, maxval = 25)
loActColor = input.color(color.new(#00BBFF, 95), 'Low Activity', inline = 'profile_color')
hiActColor = input.color(color.new(#00BBFF, 25), 'High Activity', inline = 'profile_color')
regLineColor = input.color(color.new(color.gray, 0), '', inline = 'reg_line')
regLineStyleOpt = input.string('Dashed', '', options = ['Solid', 'Dotted', 'Dashed'], inline = 'reg_line')
regLineWidthOpt = input.int(2, '', minval = 1, maxval = 4, inline = 'reg_line')
useCustomColor = input.bool(true, '', inline = 'act_line')
customColor = input.color(color.new(#00BBFF, 50), 'Custom Active Line Color', inline = 'act_line')
actLineStyle = input.string('Solid', '', options = ['Solid', 'Dotted', 'Dashed'], inline = 'act_line')
actLineWidth = input.int(2, '', minval = 1, maxval = 5, inline = 'act_line')

maxProfileBars = 25
effectiveProfileBars = math.max(numActivityLines, math.min(nFills, math.max(maxProfileBars - (numActivityLines - 2), 2)))

srcATF = close
devMultATF = devMultiplier
isLogATF = uL

calcDevATF(src, len) =>
    float base = isLogATF ? math.log(src) : src
    var int n1 = len - 1
    if barstate.islast
        float sumX = 0.0, sumXX = 0.0, sumYX = 0.0, sumY = 0.0
        for i = 1 to len by 1
            float val = base[i - 1]
            sumX += i
            sumXX += i * i
            sumYX += i * val
            sumY += val
        float slope = nz((len * sumYX - sumX * sumY) / (len * sumXX - sumX * sumX))
        float avg = sumY / len
        float intercept = avg - slope * sumX / len + slope
        float sumDev = 0.0, sumDxx = 0.0, sumDyy = 0.0, sumDyx = 0.0
        float reg = intercept + slope * n1 * 0.5
        float sumSlope = intercept
        for i = 0 to n1 by 1
            float v = base[i]
            float dxt = v - avg
            float dyt = sumSlope - reg
            v := v - sumSlope
            sumSlope += slope
            sumDxx += dxt * dxt
            sumDyy += dyt * dyt
            sumDyx += dxt * dyt
            sumDev += v * v
        float unStdDev = math.sqrt(sumDev / n1)
        float divisor = sumDxx * sumDyy
        float r = nz(sumDyx / math.sqrt(divisor))
        [unStdDev, r, slope, intercept]
    else
        [na, na, na, na]

[stdDev01, pr01, slope01, int01] = calcDevATF(srcATF, 50)
[stdDev02, pr02, slope02, int02] = calcDevATF(srcATF, 60)
[stdDev03, pr03, slope03, int03] = calcDevATF(srcATF, 70)
[stdDev04, pr04, slope04, int04] = calcDevATF(srcATF, 80)
[stdDev05, pr05, slope05, int05] = calcDevATF(srcATF, 90)
[stdDev06, pr06, slope06, int06] = calcDevATF(srcATF, 100)
[stdDev07, pr07, slope07, int07] = calcDevATF(srcATF, 115)
[stdDev08, pr08, slope08, int08] = calcDevATF(srcATF, 130)
[stdDev09, pr09, slope09, int09] = calcDevATF(srcATF, 145)
[stdDev10, pr10, slope10, int10] = calcDevATF(srcATF, 160)
[stdDev11, pr11, slope11, int11] = calcDevATF(srcATF, 180)
[stdDev12, pr12, slope12, int12] = calcDevATF(srcATF, 200)
[stdDev13, pr13, slope13, int13] = calcDevATF(srcATF, 220)
[stdDev14, pr14, slope14, int14] = calcDevATF(srcATF, 250)
[stdDev15, pr15, slope15, int15] = calcDevATF(srcATF, 280)
[stdDev16, pr16, slope16, int16] = calcDevATF(srcATF, 310)
[stdDev17, pr17, slope17, int17] = calcDevATF(srcATF, 340)
[stdDev18, pr18, slope18, int18] = calcDevATF(srcATF, 370)
[stdDev19, pr19, slope19, int19] = calcDevATF(srcATF, 400)


var int detectedLongPeriod = na
var float detectedLongSlope = na
var float detectedLongIntercept = na
var float detectedLongStdDev = na
var float detectedLongPearson = na
if barstate.islast
    float highestLong = math.max(pr01, pr02, pr03, pr04, pr05, pr06, pr07, pr08, pr09, pr10, pr11, pr12, pr13, pr14, pr15, pr16, pr17, pr18, pr19)
    if highestLong == pr01
        detectedLongPeriod := 50
        detectedLongSlope := slope01
        detectedLongIntercept := int01
        detectedLongStdDev := stdDev01
        detectedLongPearson := pr01
    else if highestLong == pr02
        detectedLongPeriod := 60
        detectedLongSlope := slope02
        detectedLongIntercept := int02
        detectedLongStdDev := stdDev02
        detectedLongPearson := pr02
    else if highestLong == pr03
        detectedLongPeriod := 70
        detectedLongSlope := slope03
        detectedLongIntercept := int03
        detectedLongStdDev := stdDev03
        detectedLongPearson := pr03
    else if highestLong == pr04
        detectedLongPeriod := 80
        detectedLongSlope := slope04
        detectedLongIntercept := int04
        detectedLongStdDev := stdDev04
        detectedLongPearson := pr04
    else if highestLong == pr05
        detectedLongPeriod := 90
        detectedLongSlope := slope05
        detectedLongIntercept := int05
        detectedLongStdDev := stdDev05
        detectedLongPearson := pr05
    else if highestLong == pr06
        detectedLongPeriod := 100
        detectedLongSlope := slope06
        detectedLongIntercept := int06
        detectedLongStdDev := stdDev06
        detectedLongPearson := pr06
    else if highestLong == pr07
        detectedLongPeriod := 115
        detectedLongSlope := slope07
        detectedLongIntercept := int07
        detectedLongStdDev := stdDev07
        detectedLongPearson := pr07
    else if highestLong == pr08
        detectedLongPeriod := 130
        detectedLongSlope := slope08
        detectedLongIntercept := int08
        detectedLongStdDev := stdDev08
        detectedLongPearson := pr08
    else if highestLong == pr09
        detectedLongPeriod := 145
        detectedLongSlope := slope09
        detectedLongIntercept := int09
        detectedLongStdDev := stdDev09
        detectedLongPearson := pr09
    else if highestLong == pr10
        detectedLongPeriod := 160
        detectedLongSlope := slope10
        detectedLongIntercept := int10
        detectedLongStdDev := stdDev10
        detectedLongPearson := pr10
    else if highestLong == pr11
        detectedLongPeriod := 180
        detectedLongSlope := slope11
        detectedLongIntercept := int11
        detectedLongStdDev := stdDev11
        detectedLongPearson := pr11
    else if highestLong == pr12
        detectedLongPeriod := 200
        detectedLongSlope := slope12
        detectedLongIntercept := int12
        detectedLongStdDev := stdDev12
        detectedLongPearson := pr12
    else if highestLong == pr13
        detectedLongPeriod := 220
        detectedLongSlope := slope13
        detectedLongIntercept := int13
        detectedLongStdDev := stdDev13
        detectedLongPearson := pr13
    else if highestLong == pr14
        detectedLongPeriod := 250
        detectedLongSlope := slope14
        detectedLongIntercept := int14
        detectedLongStdDev := stdDev14
        detectedLongPearson := pr14
    else if highestLong == pr15
        detectedLongPeriod := 280
        detectedLongSlope := slope15
        detectedLongIntercept := int15
        detectedLongStdDev := stdDev15
        detectedLongPearson := pr15
    else if highestLong == pr16
        detectedLongPeriod := 310
        detectedLongSlope := slope16
        detectedLongIntercept := int16
        detectedLongStdDev := stdDev16
        detectedLongPearson := pr16
    else if highestLong == pr17
        detectedLongPeriod := 340
        detectedLongSlope := slope17
        detectedLongIntercept := int17
        detectedLongStdDev := stdDev17
        detectedLongPearson := pr17
    else if highestLong == pr18
        detectedLongPeriod := 370
        detectedLongSlope := slope18
        detectedLongIntercept := int18
        detectedLongStdDev := stdDev18
        detectedLongPearson := pr18
    else
        detectedLongPeriod := 400
        detectedLongSlope := slope19
        detectedLongIntercept := int19
        detectedLongStdDev := stdDev19
        detectedLongPearson := pr19

finalPeriod = useAdaptive ? detectedLongPeriod : pI

eS = extend.right
lI = math.min(bar_index + 1, finalPeriod)

formatNumber(num) =>
    if num >= 1000000
        str.tostring(math.round(num / 1000000, 2)) + 'M'
    else if num >= 1000
        str.tostring(math.round(num / 1000, 2)) + 'K'
    else
        str.tostring(num)

f_adjust(p) =>
    uL ? math.log(p) : p
f_unadjust(p) =>
    uL ? math.exp(p) : p

cS(len) =>
    if not barstate.islast or len <= 1
        [float(na), float(na), float(na)]
    else
        sX = 0.0
        sY = 0.0
        sXS = 0.0
        sXY = 0.0
        for i = 0 to len - 1 by 1
            v = f_adjust(close[i])
            p = i + 1.0
            sX := sX + p
            sY := sY + v
            sXS := sXS + p * p
            sXY := sXY + v * p
            sXY
        sl = (len * sXY - sX * sY) / (len * sXS - sX * sX)
        av = sY / len
        ic = av - sl * sX / len + sl
        [sl, av, ic]

[s, a, i] = cS(lI)
sP = f_unadjust(i + s * (lI - 1))
eP = f_unadjust(i)

var float uSP = na
var float uEP = na
var float lSP = na
var float lEP = na
var line bL = na

if showRegLine
    if na(bL) and not na(sP)
        bL := line.new(bar_index - lI + 1, sP, bar_index, eP, width = regLineWidthOpt, extend = eS, color = regLineColor, style = regLineStyleOpt == 'Solid' ? line.style_solid : regLineStyleOpt == 'Dotted' ? line.style_dotted : line.style_dashed)
        bL
    else
        line.set_xy1(bL, bar_index - lI + 1, sP)
        line.set_xy2(bL, bar_index, eP)
        line.set_color(bL, regLineColor)
        line.set_style(bL, regLineStyleOpt == 'Solid' ? line.style_solid : regLineStyleOpt == 'Dotted' ? line.style_dotted : line.style_dashed)
        line.set_width(bL, regLineWidthOpt)
else
    line.delete(bL)

cD(len, sl, av, ic) =>
    uD = 0.0
    dD = 0.0
    sDA = 0.0
    dxx = 0.0
    dyy = 0.0
    dxy = 0.0
    per = len - 1
    dY = ic + sl * per / 2
    v = ic
    for j = 0 to per by 1
        pr = f_adjust(high[j]) - v
        if pr > uD
            uD := pr
            uD
        pr := v - f_adjust(low[j])
        if pr > dD
            dD := pr
            dD
        pr := f_adjust(close[j])
        dx = pr - av
        dy = v - dY
        pr := pr - v
        sDA := sDA + pr * pr
        dxx := dxx + dx * dx
        dyy := dyy + dy * dy
        dxy := dxy + dx * dy
        v := v + sl
        v
    sD = math.sqrt(sDA / (per == 0 ? 1 : per))
    pR = dxx == 0 or dyy == 0 ? 0 : dxy / math.sqrt(dxx * dyy)
    [sD, pR, uD, dD]

[sD, pR, uD, dD] = cD(lI, s, a, i)

applyDeviation(baseValue, deviation) =>
    f_unadjust(f_adjust(baseValue) + deviation)

uSP := applyDeviation(sP, devMultiplier * sD)
uEP := applyDeviation(eP, devMultiplier * sD)
lSP := applyDeviation(sP, -devMultiplier * sD)
lEP := applyDeviation(eP, -devMultiplier * sD)

var line u = na
var line l = na

if na(u) and not na(uSP)
    u := line.new(bar_index - lI + 1, uSP, bar_index, uEP, width = regLineWidth, extend = eS, color = regColor, style = regLineStyle == 'Solid' ? line.style_solid : regLineStyle == 'Dotted' ? line.style_dotted : line.style_dashed)
    u
else
    line.set_xy1(u, bar_index - lI + 1, uSP)
    line.set_xy2(u, bar_index, uEP)
    line.set_color(u, regColor)
    line.set_style(u, regLineStyle == 'Solid' ? line.style_solid : regLineStyle == 'Dotted' ? line.style_dotted : line.style_dashed)
    line.set_width(u, regLineWidth)

if na(l) and not na(lSP)
    l := line.new(bar_index - lI + 1, lSP, bar_index, lEP, width = regLineWidth, extend = eS, color = regColor, style = regLineStyle == 'Solid' ? line.style_solid : regLineStyle == 'Dotted' ? line.style_dotted : line.style_dashed)
    l
else
    line.set_xy1(l, bar_index - lI + 1, lSP)
    line.set_xy2(l, bar_index, lEP)
    line.set_color(l, regColor)
    line.set_style(l, regLineStyle == 'Solid' ? line.style_solid : regLineStyle == 'Dotted' ? line.style_dotted : line.style_dashed)


    line.set_style(l, regLineStyle == 'Solid' ? line.style_solid : regLineStyle == 'Dotted' ? line.style_dotted : line.style_dashed)
    line.set_width(l, regLineWidth)

linefill.new(u, showRegLine ? bL : l, color = fillColor)
if showRegLine
    linefill.new(bL, l, color = fillColor)

var label pL = na
label.delete(pL[1])
if not na(pR)
    pL := label.new(bar_index - lI + 1, lSP, str.tostring(pR, '#.###'), color = color.new(color.white, 100), textcolor = color.gray, size = size.normal, style = label.style_label_up)
    pL

calcLineValue(startY, endY, currentBar, totalBars) =>
    f_unadjust(f_adjust(startY) + (f_adjust(endY) - f_adjust(startY)) * currentBar / totalBars)

color_from_gradient(percent, color1, color2) =>
    r = color.r(color1) + (color.r(color2) - color.r(color1)) * percent
    g = color.g(color1) + (color.g(color2) - color.g(color1)) * percent
    b = color.b(color1) + (color.b(color2) - color.b(color1)) * percent
    t = color.t(color1) + (color.t(color2) - color.t(color1)) * percent
    color.rgb(r, g, b, t)

var counts = array.new_float(nFills, 0.0)
var activityLines = array.new_line(numActivityLines)
var profileFills = array.new_linefill(nFills)
var countLabels = array.new_label(numActivityLines)

if barstate.islast
    array.clear(counts)

    for actLine in activityLines
        line.delete(actLine)
    array.clear(activityLines)

    for cl in countLabels
        label.delete(cl)
    array.clear(countLabels)

    for pf in profileFills
        linefill.delete(pf)
    array.clear(profileFills)

    for idx1 = 0 to nFills - 1 by 1
        y1_top = calcLineValue(lSP, uSP, idx1, nFills)
        y1_bottom = calcLineValue(lSP, uSP, idx1 + 1, nFills)
        y2_top = calcLineValue(lEP, uEP, idx1, nFills)
        y2_bottom = calcLineValue(lEP, uEP, idx1 + 1, nFills)
        y1_mid = (y1_top + y1_bottom) / 2
        y2_mid = (y2_top + y2_bottom) / 2
        count = 0.0
        for j = 0 to lI - 1 by 1
            lineValue = calcLineValue(y1_mid, y2_mid, j, lI - 1)
            if activityMethod == 'Touches'
                if low[lI - 1 - j] <= lineValue and high[lI - 1 - j] >= lineValue
                    count := count + 1.0
                    count
            else
                if low[lI - 1 - j] <= lineValue and high[lI - 1 - j] >= lineValue
                    count := count + volume[lI - 1 - j]
                    count
        array.push(counts, count)

    maxCount = array.max(counts)
    sortedIndices = array.sort_indices(counts, order.descending)
    var float activitySlope = 0.0
    minActivityThreshold = maxCount * 0.1
    displayedActivityLines = 0

    index = array.get(sortedIndices, 0)
    actY1 = calcLineValue(lSP, uSP, index + 0.5, nFills)
    actY2 = calcLineValue(lEP, uEP, index + 0.5, nFills)
    activitySlope := (f_adjust(actY2) - f_adjust(actY1)) / (bar_index - (bar_index - lI + 1))

    if showMostActiveLines
        for idx2 = 0 to nFills - 1 by 1
            if displayedActivityLines >= numActivityLines
                break
            index := array.get(sortedIndices, idx2)
            count = array.get(counts, index)
            if count >= minActivityThreshold
                actY1 := calcLineValue(lSP, uSP, index + 0.5, nFills)
                actY2 := calcLineValue(lEP, uEP, index + 0.5, nFills)
                percent = count / maxCount
                lineColor = useCustomColor ? customColor : color_from_gradient(percent, loActColor, hiActColor)
                lineStyle = actLineStyle == 'Solid' ? line.style_solid : actLineStyle == 'Dotted' ? line.style_dotted : line.style_dashed
                startX = showProfile ? math.min(bar_index, bar_index - lI + 1 + math.round(count / maxCount * math.round(lI / 5))) : bar_index - lI + 1
                startY = showProfile ? f_unadjust(f_adjust(actY1) + activitySlope * (startX - (bar_index - lI + 1))) : actY1
                actLine = line.new(startX, startY, bar_index, actY2, color = lineColor, width = actLineWidth, style = lineStyle, extend = extend.right)
                array.push(activityLines, actLine)

                if showLabels
                    labelOffsetX = 5
                    labelOffsetY = activitySlope * labelOffsetX
                    labelX = bar_index + labelOffsetX
                    labelY = f_unadjust(f_adjust(actY2) + labelOffsetY)
                    countLabel = label.new(x = labelX, y = labelY, text = formatNumber(count), color = color.new(color.white, 100), textcolor = lineColor, size = size.small, style = label.style_label_left)
                    array.push(countLabels, countLabel)

                displayedActivityLines := displayedActivityLines + 1
                displayedActivityLines

    if showProfile
        profileLength = math.round(lI / 5)
        sortedProfileIndices = array.sort_indices(counts, order.descending)
        for idx3 = 0 to effectiveProfileBars - 1 by 1
            profileIndex = array.get(sortedProfileIndices, idx3)
            y1_top = calcLineValue(lSP, uSP, profileIndex, nFills)
            y1_bottom = calcLineValue(lSP, uSP, profileIndex + 1, nFills)
            y2_top = calcLineValue(lEP, uEP, profileIndex, nFills)
            y2_bottom = calcLineValue(lEP, uEP, profileIndex + 1, nFills)
            count = array.get(counts, profileIndex)
            percent = count / maxCount
            fillColor := color_from_gradient(percent, loActColor, hiActColor)
            lineLength = math.round(count / maxCount * profileLength)
            x2 = math.min(bar_index, bar_index - lI + 1 + lineLength)
            topLine = line.new(bar_index - lI + 1, y1_top, x2, f_unadjust(f_adjust(y1_top) + activitySlope * lineLength), color = color.new(fillColor, 100))
            bottomLine = line.new(bar_index - lI + 1, y1_bottom, x2, f_unadjust(f_adjust(y1_bottom) + activitySlope * lineLength), color = color.new(fillColor, 100))
            profileFill = linefill.new(topLine, bottomLine, color = fillColor)
            array.push(profileFills, profileFill)
