//@version=6
indicator('üêãüìö‚ù§Ô∏è‚ù§Ô∏è Reversal Point Dynamics + Information-Geometric DskyzInvestments/ IGMD', shorttitle = 'üêãüìö‚ù§Ô∏è‚ù§Ô∏è Dskyz RPD + IGMD', overlay = true, max_bars_back = 5000, precision = 4, max_labels_count = 500, max_lines_count = 500, max_boxes_count = 500)
//==============================================================================
// üìö COMPREHENSIVE USER GUIDE & CONCEPTUAL FRAMEWORK
//==============================================================================
//
// Reversal Point Dynamics - PROBABILITY-BASED REVERSAL ENGINE (Enhanced Real-Time Version)
//
// Welcome to Reversal Point Dynamics (RPD), a sophisticated trading algorithm designed to
// identify high-probability market turning points. RPD moves beyond simple
// overbought/oversold indicators by calculating a quantifiable "Probability Score"
// for every potential reversal.
//
// ‚ö° WHAT MAKES THIS DIFFERENT:
//
// Traditional indicators provide signals. RPD provides a multi-faceted decision framework.
//
// 1. PROBABILITY-BASED SIGNALS:
// - Instead of just a "buy" or "sell" arrow, RPD computes a probability percentage (0-99%)
// that the current candle is a peak or valley. Only signals surpassing a user-defined
// minProbability are shown.
//
// 2. ADAPTIVE ANALYSIS ENGINE:
// - RPD's core feature. It analyzes recent performance and market conditions
// in real-time. If conditions are favorable, it can boost signal confidence. If not,
// it becomes more selective to protect capital.
//
// 3. MULTI-FACTOR CONFLUENCE CORE:
// - The core probability score is derived from a confluence of momentum, volatility, and price
// action analysis over the Adaptive Analysis Period. It looks for conditions where momentum is
// exhausted and volatility suggests a turn.
//
// 4. INTELLIGENT ENTROPY & VOLUME FILTERS:
// - Automatically disqualifies signals in disordered, high-entropy markets (Entropy Threshold).
// - Validates signals with significant volume spikes, ensuring there is conviction
// behind the potential reversal (Volume Filter).
//
// 5. STATE ANALYSIS BALANCING:
// - Acknowledges that bull and bear markets behave differently. Users can adjust sensitivity
// for peak (short) and valley (long) signals via state levels and edge sensitivity.
//
// 6. LIVE SIGNAL MODE (NEW):
// - Enables intra-bar signal projection for no-lag detection. Tentative signals on current bar are marked '!' and confirm on close.
//
// 7. FIBONACCI TARGET ENGINE (NEW):
// - Displays adaptive Fibonacci levels (8,13,21,34,55 periods) for targets and support/resistance.
// - Active Fib Channel: Green zone post-signal for entry area, with red stop zone.
// - Static R2R Zone: 3 static fib lines on signal for risk-to-reward visualization, disappear on breach.
//
// 8. ENHANCED VISUALS (NEW):
// - Harmonic Wave: Smoothed bands around price for flow visualization.
// - Entropy Particles: Dynamic dots indicating flow strength and direction.
//
// üéØ HUD & KEY METRICS DEEP DIVE:
//
// The Dashboard displays the engine's internal calculations, giving you full transparency. Size options (Small/Normal/Large) show progressive info.
//
// üìà PROBABILITY SCORE (%):
// Mathematical Basis: A weighted composite score of multiple internal metrics, normalized to a 0-99% scale.
// ‚Ä¢ Measures the real-time confidence of a potential turning point.
// ‚Ä¢ > minProbability: A valid signal is triggered.
// ‚Ä¢ High Score (e.g., 90%+): Indicates a very strong confluence of factors for a reversal.
//
// üéØ TREND DIRECTION:
// Mathematical Basis: Derived from Supertrend calculations.
// ‚Ä¢ The core metric for aligning signals with market trend.
// ‚Ä¢ A signal is more likely if it aligns with a trend flip.

// üå™Ô∏è ENTROPY:
// Mathematical Basis: A measure of market order/disorder based on price changes.
// ‚Ä¢ Measures market choppiness.
// ‚Ä¢ Low Value: Ordered, directional price action (good for signals).
// ‚Ä¢ High Value: Disordered, choppy price action (bad for signals, filter will engage).

// üßÆ THE MATHEMATICS IN BRIEF:
//
// The final signal is a result of a multi-stage calculation:
//
// 1. BASE SCORE CALCULATION:
// - The engine analyzes price action, momentum (PSR velocity/acceleration), and volatility metrics within the Adaptive Analysis Period.
// - It identifies exhaustion patterns (e.g., slowing momentum at price extremes) to generate a raw BaseScore.
//
// 2. FILTER MODIFICATION:
// - The BaseScore is penalized or nullified if entropy exceeds the Entropy Threshold.
// - Volume and RSI bonuses are added if conditions are met.

// 3. STATE ANALYSIS MODIFICATION:
// - State levels divide the price range, and edge sensitivity determines how close to extremes a signal must be.

// 4. FINAL PROBABILITY:
// Probability = (BaseScore + Entropy Score + Divergence Bonus + RSI/Volume Bonuses)
// A signal is plotted IF Probability >= minProbability.
//
// üí° TRADING PHILOSOPHY WITH RPD:
//
// Markets move in waves, creating peaks and valleys. RPD is not designed to catch every small move but to identify the most statistically probable turning points‚Äîthe "turning points"‚Äîwhere the risk/reward is skewed in your favor. It operates on the principle of confluence and adaptive confirmation. A signal isn't just a pattern; it's a pattern that has been validated by entropy, volume, and state analysis.

// üéØ HOW TO USE THIS INDICATOR:
//
// 1. SIGNAL IDENTIFICATION:
// - Primary signals are the Peak (‚ñº) and Valley (‚ñ≤) labels on the chart. These have already passed all internal checks.
// - Use the dashboard to see the Probability % of the signal. Higher is better.
//
// 2. CONTEXTUAL ANALYSIS (VIA DASHBOARD):
// - Check the Trend direction. Signals aligning with trend flips are stronger.
// - Note the Entropy and Volume Spike. Low entropy and spikes add confluence.
//
// 3. ENTRY & MANAGEMENT:
// - Consider entering after the signal candle closes.
// - Use the signal's location for stop-loss placement (e.g., above a Peak, below a Valley).
// - Profit targets can be based on Fibonacci levels or a fixed Risk/Reward ratio.
//
// 4. OPTIMIZATION & CUSTOMIZATION:
// - For volatile markets (Crypto), you may need a higher Adaptive Analysis Period and stricter Entropy Threshold.
// - For trending markets (Indices), adjust State Levels to focus on significant turns.
// - Monitor the dashboard for real-time feedback on metrics like RSI and Entropy.
//
// ‚ö†Ô∏è ADVANCED CONSIDERATIONS:
// ‚Ä¢ High-Impact News: No indicator can predict the outcome of fundamental events. Be cautious around major news releases.
// ‚Ä¢ Strong Trends: In a powerful, parabolic trend, reversal indicators will naturally struggle. RPD's filters and state analysis are designed to minimize false signals in these conditions, but no system is perfect. Use trend analysis to complement signals.
// ‚Ä¢ Parameter Tuning: While the defaults are robust, the ideal settings can vary by asset and timeframe. Use strategy testing to find optimal parameters for your specific use case.

//==================================================================
// INPUTS & ADVANCED SETTINGS
//==================================================================
groupCore = 'üß† Core Algorithm'
_display = display.none
adaptivePeriod = input.int(25, 'Adaptive Analysis Period', minval = 5, maxval = 100, group = groupCore, tooltip = 'üéØ WHAT IT IS: The primary lookback period for state analysis, momentum, and entropy calculations.\n\n‚ö° HOW IT WORKS: Defines the number of past bars used to compute highs/lows, states, and entropy. Shorter periods are more responsive; longer ones provide broader context.\n\nüìà LONGER VALUES (50-100): Focuses on major turns, fewer signals. Good for swing trading.\nüìâ SHORTER VALUES (5-20): More sensitive to local extremes, more signals. Ideal for scalping.\n\nüïí TIMEFRAME OPTIMIZATION:\n‚Ä¢ Scalping (1-5min): 5-15.\n‚Ä¢ Day Trading (15min-1H): 20-40.\n‚Ä¢ Swing Trading (4H-1D): 50-100.\n\nüè¶ SECTOR RECOMMENDATIONS:\n‚Ä¢ Crypto (Volatile): 10-30.\n‚Ä¢ Stocks (Stable): 30-50.\n‚Ä¢ Forex (Varied): 20-40.\n‚Ä¢ Indices (Trending): 40-60.\n\nüí° PRO TIP: Start with 30 and adjust based on backtesting. Shorter periods increase signals but may add noise.')
fractalStrength = input.int(2, 'Fractal Strength (Bars)', minval = 1, maxval = 5, group = groupCore, tooltip = 'üéØ WHAT IT IS: Defines the number of bars on each side for fractal pattern detection.\n\n‚ö° HOW IT WORKS: Checks if the center bar is higher/lower than surrounding bars to identify fractals, enhancing pivot detection.\n\nüìà HIGHER VALUES (3-5): Stricter fractals, fewer but stronger signals.\nüìâ LOWER VALUES (1-2): More sensitive, detects smaller patterns.\n\nüïí TIMEFRAME OPTIMIZATION:\n‚Ä¢ Scalping (1-5min): 1-2 for quick patterns.\n‚Ä¢ Day Trading (15min-1H): 2-3 for balance.\n‚Ä¢ Swing Trading (4H-1D): 4-5 for major fractals.\n\nüè¶ SECTOR RECOMMENDATIONS:\n‚Ä¢ Crypto (Volatile): Lower for micro-fractals.\n‚Ä¢ Stocks (Stable): Higher for reliable patterns.\n‚Ä¢ Forex (Varied): 2-3 standard.\n‚Ä¢ Indices (Trending): Higher to filter noise.\n\nüí° PRO TIP: Pair with Predictive Mode; test 3 for most assets.')
mtfMultiplier = input.int(4, 'MTF Multiplier (e.g., 4 for 4x TF)', minval = 1, group = groupCore, tooltip = 'üéØ WHAT IT IS: Multiplier to derive a higher timeframe for multi-timeframe (MTF) analysis.\n\n‚ö° HOW IT WORKS: Multiplies current timeframe (e.g., 1H * 4 = 4H) to incorporate higher TF pivots into signals.\n\nüìà HIGHER VALUES (4-8): Incorporates broader context, stronger confluence.\nüìâ LOWER VALUES (1-3): Closer to current TF, more responsive but less filtered.\n\nüïí TIMEFRAME OPTIMIZATION:\n‚Ä¢ Scalping (1-5min): 2-4 for quick MTF.\n‚Ä¢ Day Trading (15min-1H): 4-6 for daily view.\n‚Ä¢ Swing Trading (4H-1D): 2-4 for weekly.\n\nüè¶ SECTOR RECOMMENDATIONS:\n‚Ä¢ Crypto (Volatile): Lower for speed.\n‚Ä¢ Stocks (Stable): Higher for trend confirmation.\n‚Ä¢ Forex (Varied): 4 standard.\n‚Ä¢ Indices (Trending): Higher for macro view.\n\nüí° PRO TIP: Set to 4; align with your strategy\'s higher TF.')
groupSignal = 'üéØ Signal Settings'
minProbThreshold = input.int(65, 'Min Probability %', minval = 50, maxval = 95, group = groupSignal, tooltip = 'üéØ WHAT IT IS: The minimum probability score required for a signal to be displayed.\n\n‚ö° HOW IT WORKS: Calculated score must exceed this threshold after factoring entropy, divergence, RSI, and volume.\n\nüìà HIGHER VALUES (80-95): Fewer, higher-quality signals.\nüìâ LOWER VALUES (50-65): More signals, including lower-confidence ones.\n\nüïí TIMEFRAME OPTIMIZATION:\n‚Ä¢ Scalping: 50-60 for more opportunities.\n‚Ä¢ Swing Trading: 80-90 for reliability.\n\nüè¶ SECTOR RECOMMENDATIONS:\n‚Ä¢ Volatile assets: Lower to capture quick turns.\n\nüí° PRO TIP: Set to 70 for balance; monitor dashboard for score trends.')
minSignalDistance = input.int(10, 'Min Signal Distance (Bars)', minval = 1, maxval = 30, group = groupSignal, tooltip = 'üéØ WHAT IT IS: Minimum bars between consecutive signals to prevent clustering.\n\n‚ö° HOW IT WORKS: Ensures signals are spaced out, avoiding noise in choppy markets.\n\nüìà HIGHER VALUES (10-20): Fewer signals, focuses on major turns.\nüìâ LOWER VALUES (1-5): Allows closer signals for active trading.\n\nüïí TIMEFRAME OPTIMIZATION:\n‚Ä¢ Lower TFs: 3-5.\n‚Ä¢ Higher TFs: 10-15.\n\nüí° PRO TIP: Use 5 for most cases; increase in ranging markets.')
entropyThreshold = input.float(0.85, 'Entropy Threshold', minval = 0.1, maxval = 1.0, step = 0.05, group = groupSignal, tooltip = 'üéØ WHAT IT IS: Threshold for market disorder; higher values allow signals in choppier conditions.\n\n‚ö° HOW IT WORKS: Entropy measures price change randomness; signals require entropy below this for orderliness.\n\nüìà HIGHER VALUES (0.7-1.0): More lenient, more signals in varied conditions.\nüìâ LOWER VALUES (0.1-0.4): Strict, only in highly ordered markets.\n\nüïí TIMEFRAME OPTIMIZATION:\n‚Ä¢ Volatile TFs: Higher to avoid missing turns.\n\nüí° PRO TIP: 0.6 is balanced; adjust based on asset volatility.')
groupState = 'üìä State Analysis'
analysisLevels = input.int(6, 'Analysis Levels', minval = 3, maxval = 9, group = groupState, tooltip = 'üéØ WHAT IT IS: Number of discrete levels for dividing the price range in state analysis.\n\n‚ö° HOW IT WORKS: Price is quantized into these levels based on recent high/low; extremes trigger signals.\n\nüìà HIGHER VALUES (7-9): Finer granularity, more precise extremes.\nüìâ LOWER VALUES (3-5): Broader, fewer but stronger signals.\n\nüïí TIMEFRAME OPTIMIZATION:\n‚Ä¢ Short TFs: 7-9 for detail.\n‚Ä¢ Long TFs: 5-7 for major levels.\n\nüí° PRO TIP: 9 for most assets; reduce if too many signals.')
edgeSensitivity = input.int(3, 'Edge Sensitivity', minval = 0, maxval = 4, group = groupState, tooltip = 'üéØ WHAT IT IS: How close to range edges (high/low) price must be for state requirement.\n\n‚ö° HOW IT WORKS: 0 is strictest (must be at absolute edge); 4 is lenient.\n\nüìà HIGHER VALUES (3-4): More signals, allows near-extremes.\nüìâ LOWER VALUES (0-2): Fewer, requires true extremes.\n\nüïí TIMEFRAME OPTIMIZATION:\n‚Ä¢ Volatile: Higher for flexibility.\n\nüí° PRO TIP: 3 for balance; increase if missing turns.')
predictiveMode = input.bool(true, 'Predictive Mode (Early Detection)', group = groupState, tooltip = 'üéØ WHAT IT IS: Toggles the predictive detection mode for early reversal anticipation.\n\n‚ö° HOW IT WORKS: Analyzes current bar state, acceleration, entropy, and trend to forecast potential turns before full confirmation. Signals appear as \'?\' on the current bar.\n\nüìà ENABLED (true): Activates early signals for proactive trading. Recommended for scalping or volatile markets.\nüìâ DISABLED (false): Only shows confirmed signals after bar close. Safer but less timely.\n\nüïí TIMEFRAME OPTIMIZATION:\n‚Ä¢ Scalping (1-5min): Enable for intra-bar alerts.\n‚Ä¢ Day Trading (15min-1H): Enable for early entries.\n‚Ä¢ Swing Trading (4H-1D): Disable to avoid false positives.\n\nüè¶ SECTOR RECOMMENDATIONS:\n‚Ä¢ Crypto (Volatile): Enable to catch fast reversals.\n‚Ä¢ Stocks (Stable): Optional, depending on timeframe.\n‚Ä¢ Forex (Varied): Enable for major pairs.\n‚Ä¢ Indices (Trending): Disable in strong trends.\n\nüí° PRO TIP: Use with alerts for real-time notifications. Combine with confirmed signals for validation.')
liveSignalMode = input.bool(false, 'Live Signal Mode (Current Bar)', group = groupState, tooltip = 'üéØ WHAT IT IS: Toggles real-time signal detection on the current open bar for immediate trading insights.\n\n‚ö° HOW IT WORKS: Projects tentative signals intra-bar based on projected high/low and momentum. Signals are marked \'!\' and confirm on bar close; may repaint as the bar develops.\n\nüìà ENABLED (true): Activates live projections for no-lag detection. Ideal for high-frequency or real-time trading.\nüìâ DISABLED (false): Signals only on confirmed closed bars. Reduces repaint risk but delays detection.\n\nüïí TIMEFRAME OPTIMIZATION:\n‚Ä¢ Scalping (1-5min): Enable for instant alerts on fast moves.\n‚Ä¢ Day Trading (15min-1H): Enable if monitoring live; disable for backtesting.\n‚Ä¢ Swing Trading (4H-1D): Disable to avoid intra-bar noise.\n\nüè¶ SECTOR RECOMMENDATIONS:\n‚Ä¢ Crypto (Volatile): Enable for rapid reversals.\n‚Ä¢ Stocks (Stable): Optional; use if trading intraday.\n‚Ä¢ Forex (Varied): Enable for liquid pairs.\n‚Ä¢ Indices (Trending): Disable in low-vol sessions.\n\nüí° PRO TIP: Combine with alerts for notifications on tentative signals. Use in conjunction with Predictive Mode for enhanced early detection.')
adaptiveEntropy = input.bool(true, 'Adaptive Entropy (Auto-Adjust)', group = groupSignal, tooltip = 'üéØ WHAT IT IS: Enables automatic adjustment of the entropy threshold based on market conditions.\n\n‚ö° HOW IT WORKS: Dynamically modifies the entropy filter using trend strength and volatility, making it stricter in noisy markets and more lenient in ordered ones.\n\nüìà ENABLED (true): Auto-adjusts for adaptive filtering, improving signal quality across varying conditions.\nüìâ DISABLED (false): Uses fixed Entropy Threshold; consistent but less responsive to changes.\n\nüïí TIMEFRAME OPTIMIZATION:\n‚Ä¢ Scalping (1-5min): Enable for quick adaptations to volatility spikes.\n‚Ä¢ Day Trading (15min-1H): Enable for intraday shifts.\n‚Ä¢ Swing Trading (4H-1D): Optional; disable if preferring manual control.\n\nüè¶ SECTOR RECOMMENDATIONS:\n‚Ä¢ Crypto (Volatile): Enable to handle sudden disorder.\n‚Ä¢ Stocks (Stable): Enable for earnings volatility.\n‚Ä¢ Forex (Varied): Enable during news events.\n‚Ä¢ Indices (Trending): Disable in steady trends.\n\nüí° PRO TIP: Pair with a moderate Entropy Threshold (e.g., 0.7) as a base; monitor dashboard entropy for effectiveness.')
aggressiveMode = input.bool(false, 'Aggressive Mode (Catch All)', group = groupSignal, tooltip = 'üéØ WHAT IT IS: Activates a mode that relaxes filters to capture more potential signals.\n\n‚ö° HOW IT WORKS: Increases edge sensitivity, raises entropy threshold, and reduces min distance, allowing more signals in varied conditions while maintaining core probability checks.\n\nüìà ENABLED (true): Generates more signals, ideal for active trading or low-signal environments.\nüìâ DISABLED (false): Stricter filtering for higher-quality, fewer signals.\n\nüïí TIMEFRAME OPTIMIZATION:\n‚Ä¢ Scalping (1-5min): Enable for frequent opportunities.\n‚Ä¢ Day Trading (15min-1H): Enable in ranging markets.\n‚Ä¢ Swing Trading (4H-1D): Disable to focus on major turns.\n\nüè¶ SECTOR RECOMMENDATIONS:\n‚Ä¢ Crypto (Volatile): Enable to catch all micro-turns.\n‚Ä¢ Stocks (Stable): Disable to avoid noise.\n‚Ä¢ Forex (Varied): Enable during quiet hours.\n‚Ä¢ Indices (Trending): Disable in bull/bear runs.\n\nüí° PRO TIP: Use with higher Min Probability (e.g., 75) to filter low-quality extras; backtest to balance quantity vs. quality.')
groupFilters = 'üìà Additional Filters'
enableRSI = input.bool(true, 'Enable RSI Filter', group = groupFilters, tooltip = 'üéØ WHAT IT IS: Toggles RSI-based bonuses for probability calculation.\n\n‚ö° HOW IT WORKS: Adds bonus if RSI is overbought (peaks) or oversold (valleys).\n\nüìà ENABLED: Enhances signals in extremes.\nüìâ DISABLED: Ignores RSI.\n\nüí° PRO TIP: Enable for momentum confirmation.')
rsiLen = input.int(17, 'RSI Length', group = groupFilters, tooltip = 'üéØ WHAT IT IS: Period for RSI calculation.\n\n‚ö° HOW IT WORKS: Standard RSI length.\n\nüí° PRO TIP: 14 is classic; adjust for sensitivity.')
rsiTop = input.int(65, 'Overbought Threshold', group = groupFilters, tooltip = 'üéØ WHAT IT IS: RSI level for overbought bonus (peaks).\n\n‚ö° HOW IT WORKS: RSI > this adds probability bonus.\n\nüí° PRO TIP: 70 for strict; 65 for more signals.')
rsiBot = input.int(40, 'Oversold Threshold', group = groupFilters, tooltip = 'üéØ WHAT IT IS: RSI level for oversold bonus (valleys).\n\n‚ö° HOW IT WORKS: RSI < this adds probability bonus.\n\nüí° PRO TIP: 30 for strict; 35 for more signals.')
volLookback = input.int(17, 'Volume Lookback', group = groupFilters, tooltip = 'üéØ WHAT IT IS: Period for average volume calculation.\n\n‚ö° HOW IT WORKS: SMA(volume, this) for spike detection.\n\nüí° PRO TIP: 22 for balance.')
volMultiplier = input.float(1.2, 'Volume Multiplier', step = 0.1, group = groupFilters, tooltip = 'üéØ WHAT IT IS: Multiplier for volume spike bonus.\n\n‚ö° HOW IT WORKS: Volume > avg * this adds bonus.\n\nüí° PRO TIP: 1.3 for moderate spikes.')
groupVisual = 'üåà Visual Design'
signalSize = input.string('Normal', 'Signal Size', options = ['Tiny', 'Small', 'Normal', 'Large'], group = groupVisual, tooltip = 'üéØ WHAT IT IS: Size of signal labels (‚ñº/‚ñ≤/?) on the chart.\n\n‚ö° HOW IT WORKS: Adjusts visual prominence of signals.\n\nüìà LARGER: Easier to see on busy charts.\nüìâ SMALLER: Minimalist view.\n\nüí° PRO TIP: \'Normal\' for most setups.')
showHarmonicWave = input.bool(false, 'Show Harmonic Wave', group = groupVisual, inline = 'viz1', tooltip = 'üéØ WHAT IT IS: Toggles the harmonic wave visualization around price.\n\n‚ö° HOW IT WORKS: Plots smoothed wave bands based on sine functions and stddev for visual flow.\n\nüìà ENABLED: Adds aesthetic bands.\nüìâ DISABLED: Cleaner chart.\n\nüí° PRO TIP: Enable for visual trend feel.')
showEntropyParticles = input.bool(false, 'Show Entropy Particles', group = groupVisual, inline = 'viz1', tooltip = 'üéØ WHAT IT IS: Toggles particle effects based on entropy and velocity.\n\n‚ö° HOW IT WORKS: Visualizes flow strength with colored particles.\n\nüìà ENABLED: Dynamic visual aid.\nüìâ DISABLED: Reduce clutter.\n\nüí° PRO TIP: Useful for entropy intuition.')
colorTheme = input.string('Ocean', 'Color Theme', options = ['Neon', 'Cyber', 'Solar', 'Ocean', 'Aurora', 'Plasma'], group = groupVisual, tooltip = 'üéØ WHAT IT IS: Selects the color scheme for signals, waves, and particles.\n\n‚ö° HOW IT WORKS: Applies theme colors to visuals (e.g., bull/bear/quantum).\n\nOPTIONS:\n‚Ä¢ Neon: Vibrant greens/pinks/blues.\n‚Ä¢ Cyber: Cool cyan/magenta/purple.\n‚Ä¢ Solar: Warm yellows/oranges/reds.\n‚Ä¢ Ocean: Calming teals/pinks/blues.\n‚Ä¢ Aurora: Dynamic greens/purples/blues (northern lights vibe).\n‚Ä¢ Plasma: Energetic purples/blues/pinks (plasma energy feel).\n\nüí° PRO TIP: Choose based on chart background; \'Aurora\' for dark themes.')
groupFib = 'üîÆ Fibonacci Target Engine'
showFibLevels = input.bool(true, 'Show Fibonacci Levels', group = groupFib, inline = 'fib1', tooltip = 'üéØ WHAT IT IS: Toggles display of Fibonacci-based high/low lines.\n\n‚ö° HOW IT WORKS: Plots recent highs/lows over fib periods (8,13,21,34,55).\n\nüìà ENABLED: Shows levels for targets/support.\nüìâ DISABLED: Hides for simplicity.\n\nüí° PRO TIP: Use with channels for trade management.')
showActiveChannel = input.bool(true, 'Show Active Fib Channel', group = groupFib, inline = 'fib1', tooltip = 'üéØ WHAT IT IS: Toggles the active fib channel and stop zone after signals.\n\n‚ö° HOW IT WORKS: Creates green channel around price post-signal, with red stop zone.\n\nüìà ENABLED: Visual trade zones.\nüìâ DISABLED: No channels.\n\nüí° PRO TIP: Essential for visualizing entries/exits.')
c_f8 = input.color(color.new(#3B82F6, 30), 'F8 Color', group = groupFib, inline = 'fib_c', tooltip = 'üéØ WHAT IT IS: Color for 8-period fib line.\n\n‚ö° HOW IT WORKS: Customizes visual appearance.\n\nüí° PRO TIP: Match to theme.')
c_f13 = input.color(color.new(#8B5CF6, 30), 'F13 Color', group = groupFib, inline = 'fib_c', tooltip = 'üéØ WHAT IT IS: Color for 13-period fib line.\n\n‚ö° HOW IT WORKS: Customizes visual appearance.\n\nüí° PRO TIP: Match to theme.')
c_f21 = input.color(color.new(#F59E0B, 30), 'F21 Color', group = groupFib, inline = 'fib_c', tooltip = 'üéØ WHAT IT IS: Color for 21-period fib line.\n\n‚ö° HOW IT WORKS: Customizes visual appearance.\n\nüí° PRO TIP: Match to theme.')
c_f34 = input.color(color.new(#10B981, 30), 'F34 Color', group = groupFib, inline = 'fib_c', tooltip = 'üéØ WHAT IT IS: Color for 34-period fib line.\n\n‚ö° HOW IT WORKS: Customizes visual appearance.\n\nüí° PRO TIP: Match to theme.')
c_f55 = input.color(color.new(#EF4444, 30), 'F55 Color', group = groupFib, inline = 'fib_c', tooltip = 'üéØ WHAT IT IS: Color for 55-period fib line.\n\n‚ö° HOW IT WORKS: Customizes visual appearance.\n\nüí° PRO TIP: Match to theme.')
group_dashboard_main = 'üìä Dashboard Configuration'
show_dashboard = input.bool(false, 'üìã Show Enhanced Dashboard', group = group_dashboard_main, tooltip = 'üéØ WHAT IT IS: Master toggle for displaying the main dashboard on your chart.\n\n‚ö° HOW IT WORKS: Enabling it shows the key data panels.\n\nüìà ENABLED (true): Shows the dashboard with all its analytical components.\nüìâ DISABLED (false): Hides the dashboard for a minimalist chart view.\n\nüí° PRO TIP: Keep enabled to leverage the full analytical power of the indicator\'s real-time feedback.')
dashboard_size = input.string('Large', 'üìè Dashboard Size', options = ['Small', 'Normal', 'Large'], group = group_dashboard_main, tooltip = 'üéØ WHAT IT IS: Controls the amount of information displayed in the dashboard and its overall size.\n\n‚ö° HOW IT WORKS:\n‚Ä¢ Small: Displays only the most critical metrics.\n‚Ä¢ Normal: Shows a detailed analysis.\n‚Ä¢ Large: Presents all available data.\n\nüí° PRO TIP: Use \'Normal\' for most desktop trading. Switch to \'Small\' on your phone. Use \'Large\' when you are doing a deep dive or fine-tuning the indicator settings.')
dashboard_position_input = input.string('Top Right', 'üìç Dashboard Position', options = ['Top Left', 'Top Right', 'Bottom Left', 'Bottom Right'], group = group_dashboard_main, tooltip = 'üéØ WHAT IT IS: Sets the corner of the chart where the main dashboard will be anchored.\n\n‚ö° HOW IT WORKS: Select the desired position from the dropdown menu to place the dashboard in the corner that best suits your chart layout.\n\nüìà OPTIONS: Top Left, Top Right, Bottom Left, Bottom Right.\n\nüí° PRO TIP: Place the dashboard in a corner where it won\'t obscure recent price action or other essential indicators. \'Top Right\' is a common default as price action typically develops from the right.')
//==================================================================
// VISUAL DESIGN SYSTEM
//==================================================================
f_getColors(theme) =>
    if theme == 'Cyber'
        [#00F0FF, #FF00F7, #7B61FF]
    else if theme == 'Solar'
        [#FFB300, #FF4161, #FF8E00]
    else if theme == 'Ocean'
        [#00F5E9, #FF7BAC, #7DF9FF]
    else if theme == 'Aurora'
        [#00FF7F, #9370DB, #20B2AA]
    else if theme == 'Plasma'
        [#FF00FF, #00BFFF, #FF1493]
    else
        [#39FF14, #FF10F0, #00F5FF]
[bullColor, bearColor, quantumColor] = f_getColors(colorTheme)
//==================================================================
// HELPER FUNCTIONS
//==================================================================
f_get_size(s) =>
    if s == 'Tiny'
        size.tiny
    else if s == 'Small'
        size.small
    else if s == 'Normal'
        size.normal
    else if s == 'Large'
        size.large
    else
        size.tiny
getSupertrend(_src, _mult, _len) =>
    atr = ta.atr(_len)
    upper = _src - _mult * atr
    lower = _src + _mult * atr
    upper := close[1] > upper[1] ? math.max(upper, upper[1]) : upper
    lower := close[1] < lower[1] ? math.min(lower, lower[1]) : lower
    var int trend = 1
    trend := trend == -1 and close > lower[1] ? 1 : trend == 1 and close < upper[1] ? -1 : trend
    [trend, upper, lower]
[rTrend, rUp, rDn] = getSupertrend(hlcc4, 1.1, 16)
//==================================================================
// CORE SIGNAL ENGINE
//==================================================================
hlc3_smooth = ta.wma((high + low + close) / 3, 3)
atrValue = ta.atr(14)
calculateEntropy(series, length) =>
    priceChanges = series - series[1]
    upChanges = 0.0
    total = 0.0
    int i = 0
    while i < length
        if not na(priceChanges[i])
            total := total + 1
            if priceChanges[i] > 0
                upChanges := upChanges + 1
                upChanges
        i := i + 1
        i
    p = upChanges / math.max(total, 1)
    p > 0 and p < 1 ? (-p * math.log(p) - (1 - p) * math.log(1 - p)) / math.log(2) : 0.5
quantumStateAnalysis(price, states, period) =>
    hi = ta.highest(price, period)
    lo = ta.lowest(price, period)
    priceRangeVal = hi - lo
    state = priceRangeVal > 0 ? math.round((price - lo) / priceRangeVal * (states - 1)) : 0
    [state, priceRangeVal > 0 ? (price - lo) / priceRangeVal : 0]
psr(series, period) =>
    velocity = series - series[math.round(period / 2)]
    [velocity, velocity - velocity[1]]
[state, statePercent] = quantumStateAnalysis(hlc3_smooth, analysisLevels, adaptivePeriod)
[psr_velocity, psr_acceleration] = psr(hlc3_smooth, adaptivePeriod)
entropy = calculateEntropy(hlc3_smooth, adaptivePeriod)
rsi = ta.rsi(close, rsiLen)
rsiTopCond = enableRSI ? rsi > rsiTop : false
rsiBotCond = enableRSI ? rsi < rsiBot : false
volSpike = volume > volMultiplier * ta.sma(volume, volLookback)
isPivotHigh = high[1] > high[2] and high[1] > high
isPivotLow = low[1] < low[2] and low[1] < low
isFractalHigh = false
isFractalLow = false
if bar_index >= fractalStrength * 2
    center = fractalStrength
    isFractalHigh := true
    isFractalLow := true
    int i = 1
    while i <= fractalStrength
        if nz(high[center]) <= nz(high[center + i]) or nz(high[center]) <= nz(high[center - i])
            isFractalHigh := false
            isFractalHigh
        if nz(low[center]) >= nz(low[center + i]) or nz(low[center]) >= nz(low[center - i])
            isFractalLow := false
            isFractalLow
        i := i + 1
        i
isPeakEvent = (isPivotHigh or isFractalHigh[1]) and close < low[1]
isValleyEvent = (isPivotLow or isFractalLow[1]) and close > high[1]
peak_price_at_pivot = high[1]
valley_price_at_pivot = low[1]
var float last_valid_peak_price = na
var float last_valid_peak_velocity = na
var float last_valid_valley_price = na
var float last_valid_valley_velocity = na
isBearishDivergence = isPeakEvent and not na(last_valid_peak_price) and peak_price_at_pivot > last_valid_peak_price and psr_velocity[1] < last_valid_peak_velocity
isBullishDivergence = isValleyEvent and not na(last_valid_valley_price) and valley_price_at_pivot < last_valid_valley_price and psr_velocity[1] > last_valid_valley_velocity
isPeakStateReqMet = isPeakEvent and state[1] >= analysisLevels - 1 - edgeSensitivity and (rTrend == -1 or ta.change(rTrend) < 0)
isValleyStateReqMet = isValleyEvent and state[1] <= edgeSensitivity and (rTrend == 1 or ta.change(rTrend) > 0)
isPotentialPeak = predictiveMode and state >= analysisLevels - 1 - edgeSensitivity and psr_acceleration < 0 and entropy < entropyThreshold and rTrend == -1
isPotentialValley = predictiveMode and state <= edgeSensitivity and psr_acceleration > 0 and entropy < entropyThreshold and rTrend == 1
currentTFSeconds = timeframe.in_seconds()
mtfTFSeconds = currentTFSeconds * mtfMultiplier
string mtfTF = timeframe.from_seconds(mtfTFSeconds)
[mtfHigh, mtfLow, mtfClose] = request.security(syminfo.tickerid, mtfTF, [high, low, close], gaps = barmerge.gaps_on)
mtfIsPeak = not na(mtfHigh[1]) and mtfHigh[1] > nz(mtfHigh[2], mtfHigh[1]) and mtfHigh[1] > nz(mtfHigh, mtfHigh[1])
mtfIsValley = not na(mtfLow[1]) and mtfLow[1] < nz(mtfLow[2], mtfLow[1]) and mtfLow[1] < nz(mtfLow, mtfLow[1])
isPeakEvent := isPeakEvent or mtfIsPeak and close < nz(mtfLow[1], low[1])
isValleyEvent := isValleyEvent or mtfIsValley and close > nz(mtfHigh[1], high[1])
trendStrength = math.abs(ta.ema(psr_velocity, 10))
avgVolRecent = ta.sma(volume, 5)
calculateProbability(p_entropy, isDivergence) =>
    base_score = 40 + trendStrength / atrValue * 30 + (1 - p_entropy) * 10
    entropy_score = p_entropy < entropyThreshold ? 10 + (1 - p_entropy) * 5 : -5
    divergence_bonus = isDivergence ? 20 + math.abs(psr_acceleration) * 2 : 0
    rsi_bonus = rsiTopCond and isPeakEvent or rsiBotCond and isValleyEvent ? 8 + (rsi - 50) / 5 : 0
    vol_bonus = volSpike ? 5 + (volume / avgVolRecent - 1) * 3 : 0
    adaptive_bonus = adaptiveEntropy and trendStrength > atrValue ? 10 + trendStrength * 0.5 : 0
    mtf_bonus = mtfIsPeak and isPeakEvent or mtfIsValley and isValleyEvent ? 12 : 0
    barRangeFactor = (high - low) / atrValue
    variation = barRangeFactor * 3 - 1.5
    raw_prob = base_score + entropy_score + divergence_bonus + rsi_bonus + vol_bonus + adaptive_bonus + mtf_bonus + variation
    math.min(99, math.max(40, math.round(raw_prob, 1)))
peakProb = isPeakStateReqMet or isPotentialPeak ? calculateProbability(entropy[1], isBearishDivergence) : na
valleyProb = isValleyStateReqMet or isPotentialValley ? calculateProbability(entropy[1], isBullishDivergence) : na
effectiveMinProb = minProbThreshold - (adaptiveEntropy ? trendStrength / atrValue * 5 : 0)
effectiveMinDistance = aggressiveMode ? 1 : minSignalDistance
effectiveEdgeSens = aggressiveMode ? 4 : edgeSensitivity
effectiveEntropyThresh = aggressiveMode ? 0.95 : entropyThreshold
var int lastSignalBar = na
validPeak = (isPeakStateReqMet or isPotentialPeak) and peakProb >= effectiveMinProb and (na(lastSignalBar) or bar_index - lastSignalBar > effectiveMinDistance)
validValley = (isValleyStateReqMet or isPotentialValley) and valleyProb >= effectiveMinProb and (na(lastSignalBar) or bar_index - lastSignalBar > effectiveMinDistance)
if validPeak
    lastSignalBar := bar_index
    last_valid_peak_price := peak_price_at_pivot
    last_valid_peak_velocity := psr_velocity[1]
    last_valid_peak_velocity
if validValley
    lastSignalBar := bar_index
    last_valid_valley_price := valley_price_at_pivot
    last_valid_valley_velocity := psr_velocity[1]
    last_valid_valley_velocity
var bool livePeakEvent = false
var bool liveValleyEvent = false
var float livePeakProb = na
var float liveValleyProb = na
var label livePeakLabel = na
var label livePeakProbLabel = na
var label liveValleyLabel = na
var label liveValleyProbLabel = na
projectedClose = ta.linreg(close, 5, 0)
tentativePeakProb = calculateProbability(entropy, isBearishDivergence)
tentativeValleyProb = calculateProbability(entropy, isBullishDivergence)
if liveSignalMode and barstate.isrealtime
    projectedHigh = math.max(high, open)
    projectedLow = math.min(low, open)
    intraVelocity = close - open
    intraAcceleration = intraVelocity - (close[1] - open[1])
    livePeakEvent := projectedHigh > high[1] and projectedClose < projectedLow and intraAcceleration < 0 and entropy < effectiveEntropyThresh
    liveValleyEvent := projectedLow < low[1] and projectedClose > projectedHigh and intraAcceleration > 0 and entropy < effectiveEntropyThresh
    livePeakProb := livePeakEvent ? tentativePeakProb : na
    liveValleyProb := liveValleyEvent ? tentativeValleyProb : na
    if livePeakEvent and livePeakProb >= effectiveMinProb
        label.delete(livePeakLabel)
        label.delete(livePeakProbLabel)
        livePeakLabel := label.new(bar_index, projectedHigh + atrValue * 0.7, '!', color = color.new(color.black, 100), textcolor = color.new(bearColor, 70), style = label.style_none, size = f_get_size(signalSize))
        livePeakProbLabel := label.new(bar_index, projectedHigh + atrValue * 1.2, str.tostring(livePeakProb) + '%', color = color.new(color.black, 100), textcolor = color.new(bearColor, 70), style = label.style_none, size = f_get_size(signalSize))
        livePeakProbLabel
    else
        label.delete(livePeakLabel)
        label.delete(livePeakProbLabel)
    if liveValleyEvent and liveValleyProb >= effectiveMinProb
        label.delete(liveValleyLabel)
        label.delete(liveValleyProbLabel)
        liveValleyLabel := label.new(bar_index, projectedLow - atrValue * 0.7, '!', color = color.new(color.black, 100), textcolor = color.new(bullColor, 70), style = label.style_none, size = f_get_size(signalSize))
        liveValleyProbLabel := label.new(bar_index, projectedLow - atrValue * 1.2, str.tostring(liveValleyProb) + '%', color = color.new(color.black, 100), textcolor = color.new(bullColor, 70), style = label.style_none, size = f_get_size(signalSize))
        liveValleyProbLabel
    else
        label.delete(liveValleyLabel)
        label.delete(liveValleyProbLabel)
else
    livePeakEvent := false
    liveValleyEvent := false
    livePeakProb := na
    liveValleyProb := na
    liveValleyProb
if barstate.isconfirmed
    label.delete(livePeakLabel)
    label.delete(livePeakProbLabel)
    label.delete(liveValleyLabel)
    label.delete(liveValleyProbLabel)
var bool livePending = false
livePending := liveSignalMode and barstate.isrealtime and (not na(livePeakProb) or not na(liveValleyProb))
//==================================================================
// FIBONACCI LEVEL ENGINE & ACTIVE CHANNEL
//==================================================================
fib8_high = ta.highest(high, 8)
fib8_low = ta.lowest(low, 8)
fib13_high = ta.highest(high, 13)
fib13_low = ta.lowest(low, 13)
fib21_high = ta.highest(high, 21)
fib21_low = ta.lowest(low, 21)
fib34_high = ta.highest(high, 34)
fib34_low = ta.lowest(low, 34)
fib55_high = ta.highest(high, 55)
fib55_low = ta.lowest(low, 55)
var box activeChannelBox = na
var box stopZoneBox = na
var bool isTradeActive = false
var string activeSignalDirection = ''
if validPeak or validValley
    isTradeActive := true
    activeSignalDirection := validValley ? 'long' : 'short'
    if not na(activeChannelBox)
        box.delete(activeChannelBox)
        activeChannelBox := na
        activeChannelBox
    if not na(stopZoneBox)
        box.delete(stopZoneBox)
        stopZoneBox := na
        stopZoneBox
if barstate.isconfirmed
    if showFibLevels
        fib_periods_display = array.from(8, 13, 21, 34, 55)
        fib_highs_display_arr = array.from(fib8_high, fib13_high, fib21_high, fib34_high, fib55_high)
        fib_lows_display_arr = array.from(fib8_low, fib13_low, fib21_low, fib34_low, fib55_low)
        fib_colors_arr = array.from(c_f8, c_f13, c_f21, c_f34, c_f55)
        var array<line> fibLines = array.new<line>()
        var array<label> fibLabels = array.new<label>()
        if array.size(fibLines) > 0
            for i = 0 to array.size(fibLines) - 1 by 1
                line.delete(array.get(fibLines, i))
        if array.size(fibLabels) > 0
            for i = 0 to array.size(fibLabels) - 1 by 1
                label.delete(array.get(fibLabels, i))
        array.clear(fibLines)
        array.clear(fibLabels)
        right_boundary = bar_index + 60
        used_positions = array.new<float>()
        min_spacing = atrValue * 0.5
        for i = 0 to array.size(fib_periods_display) - 1 by 1
            hi_val = array.get(fib_highs_display_arr, i)
            lo_val = array.get(fib_lows_display_arr, i)
            line_color = array.get(fib_colors_arr, i)
            period = array.get(fib_periods_display, i)
            if not na(hi_val)
                array.push(fibLines, line.new(bar_index, hi_val, right_boundary, hi_val, color = color.new(color.white, 0), width = 2))
                array.push(fibLines, line.new(bar_index, hi_val, right_boundary, hi_val, color = color.new(line_color, 0), width = 2, style = line.style_dotted))
                can_place_label = true
                for used_pos in used_positions
                    if math.abs(hi_val - used_pos) < min_spacing
                        can_place_label := false
                        can_place_label
                if can_place_label
                    label_text = 'F' + str.tostring(period) + '/' + timeframe.period + ' - RSI: ' + str.tostring(rsi, '#.0')
                    array.push(fibLabels, label.new(right_boundary + 1, hi_val, label_text, color = color.new(line_color, 85), textcolor = color.new(line_color, 20), style = label.style_label_left, size = size.small))
                    array.push(used_positions, hi_val)
            if not na(lo_val)
                array.push(fibLines, line.new(bar_index, lo_val, right_boundary, lo_val, color = color.new(color.white, 75), width = 2))
                array.push(fibLines, line.new(bar_index, lo_val, right_boundary, lo_val, color = color.new(line_color, 40), width = 2, style = line.style_dotted))
                can_place_label = true
                for used_pos in used_positions
                    if math.abs(lo_val - used_pos) < min_spacing
                        can_place_label := false
                        can_place_label
                if can_place_label
                    label_text = 'F' + str.tostring(period) + '/' + timeframe.period + ' - RSI: ' + str.tostring(rsi, '#.0')
                    array.push(fibLabels, label.new(right_boundary + 1, lo_val, label_text, color = color.new(line_color, 40), textcolor = color.new(line_color, 10), style = label.style_label_left, size = size.normal))
                    array.push(used_positions, lo_val)
    if not na(activeChannelBox)
        box.delete(activeChannelBox)
        activeChannelBox := na
        activeChannelBox
    if not na(stopZoneBox)
        box.delete(stopZoneBox)
        stopZoneBox := na
        stopZoneBox
    if showActiveChannel and isTradeActive
        fib_highs_all = array.from(fib8_high, fib13_high, fib21_high, fib34_high, fib55_high)
        fib_lows_all = array.from(fib8_low, fib13_low, fib21_low, fib34_low, fib55_low)
        bool foundChannelThisBar = false
        for i = 0 to array.size(fib_highs_all) - 1 by 1
            hi_channel = array.get(fib_highs_all, i)
            lo_channel = array.get(fib_lows_all, i)
            if not na(hi_channel) and not na(lo_channel)
                if close > lo_channel and close < hi_channel
                    activeChannelBox := box.new(bar_index, lo_channel, bar_index + 40, hi_channel, bgcolor = color.new(#6c6aed, 85), border_color = color.blue, border_width = 2)
                    if activeSignalDirection == 'long'
                        float lowerBoundary = na
                        for j = 0 to array.size(fib_highs_all) - 1 by 1
                            prev_hi = array.get(fib_highs_all, j)
                            if not na(prev_hi) and prev_hi < lo_channel and (na(lowerBoundary) or prev_hi > lowerBoundary)
                                lowerBoundary := prev_hi
                                lowerBoundary
                        if not na(lowerBoundary)
                            stopZoneBox := box.new(bar_index, lowerBoundary, bar_index + 40, lo_channel, bgcolor = color.new(#FF0000, 85), border_color = color.blue, border_width = 2)
                            stopZoneBox
                    else if activeSignalDirection == 'short'
                        float upperBoundary = na
                        for j = 0 to array.size(fib_lows_all) - 1 by 1
                            next_lo = array.get(fib_lows_all, j)
                            if not na(next_lo) and next_lo > hi_channel and (na(upperBoundary) or next_lo < upperBoundary)
                                upperBoundary := next_lo
                                upperBoundary
                        if not na(upperBoundary)
                            stopZoneBox := box.new(bar_index, hi_channel, bar_index + 40, upperBoundary, bgcolor = color.new(#FF0000, 85), border_color = color.blue, border_width = 2)
                            stopZoneBox
                    foundChannelThisBar := true
                    break
        if not foundChannelThisBar
            isTradeActive := false
            isTradeActive
            //==================================================================
            // VISUALS
            //==================================================================
wave_period = math.round(adaptivePeriod * 1.5)
wave_outer = ta.sma(math.sin(2 * math.pi * bar_index / wave_period) * ta.stdev(hlc3_smooth, wave_period) * 1.5 + hlc3_smooth, 3)
wave_mid = hlc3_smooth + (wave_outer - hlc3_smooth) * 0.66
wave_core = hlc3_smooth + (wave_outer - hlc3_smooth) * 0.33
p_price = plot(showHarmonicWave ? hlc3_smooth : na, 'Price', display = display.none)
p_core_fill = plot(showHarmonicWave ? wave_core : na, 'Core', display = display.none)
p_mid_fill = plot(showHarmonicWave ? wave_mid : na, 'Mid', display = display.none)
p_outer_fill = plot(showHarmonicWave ? wave_outer : na, 'Outer', display = display.none)
fill(p_price, p_core_fill, color = showHarmonicWave ? color.new(quantumColor, 75) : na)
fill(p_core_fill, p_mid_fill, color = showHarmonicWave ? color.new(quantumColor, 85) : na)
fill(p_mid_fill, p_outer_fill, color = showHarmonicWave ? color.new(quantumColor, 95) : na)
if showEntropyParticles
    flow_strength = 1.0 - entropy / effectiveEntropyThresh
    if flow_strength > 0
        particle_color = psr_velocity > 0 ? bullColor : bearColor
        y_pos = psr_velocity > 0 ? low - atrValue * 0.1 : high + atrValue * 0.1
        particleSize = flow_strength > 0.7 ? size.small : size.tiny
        label.new(bar_index, y_pos, '‚Ä¢', color = color.new(#2b52bc, 100), textcolor = color.new(particle_color, 50), style = label.style_none, size = particleSize)
var int plotBarIndex = na
plotBarIndex := bar_index
if validPeak
    isPredictive = isPotentialPeak and not isPeakStateReqMet
    peak_icon = isBearishDivergence ? '‚óà' : isPredictive ? '?' : '‚ñº'
    icon_y_pos = (isPredictive ? high : peak_price_at_pivot) + atrValue * 0.7
    text_y_pos = icon_y_pos + atrValue * 0.5
    icon_color = isPredictive ? color.new(bearColor, 50) : bearColor
    label.new(plotBarIndex, icon_y_pos, text = peak_icon, color = color.new(color.black, 100), textcolor = icon_color, style = label.style_none, size = f_get_size(signalSize))
    label.new(plotBarIndex, text_y_pos, text = str.tostring(peakProb, '#.0') + '%', color = color.new(color.black, 100), textcolor = icon_color, style = label.style_none, size = f_get_size(signalSize))
if validValley
    isPredictive = isPotentialValley and not isValleyStateReqMet
    valley_icon = isBullishDivergence ? '‚óà' : isPredictive ? '?' : '‚ñ≤'
    icon_y_pos = (isPredictive ? low : valley_price_at_pivot) - atrValue * 0.7
    text_y_pos = icon_y_pos - atrValue * 0.5
    icon_color = isPredictive ? color.new(bullColor, 50) : bullColor
    label.new(plotBarIndex, icon_y_pos, text = valley_icon, color = color.new(color.black, 100), textcolor = icon_color, style = label.style_none, size = f_get_size(signalSize))
    label.new(plotBarIndex, text_y_pos, text = str.tostring(valleyProb, '#.0') + '%', color = color.new(color.black, 100), textcolor = icon_color, style = label.style_none, size = f_get_size(signalSize))
    //==================================================================
    // üñ•Ô∏è DASHBOARD
    //==================================================================
var table dashboard = na
var string lastSignalType = 'None'
var float lastPeakProb = 0
var float lastValleyProb = 0
var int barsSinceSignal = na
if validPeak
    lastSignalType := 'Peak'
    lastPeakProb := peakProb
    barsSinceSignal := 0
    barsSinceSignal
else if validValley
    lastSignalType := 'Valley'
    lastValleyProb := valleyProb
    barsSinceSignal := 0
    barsSinceSignal
else if not na(lastSignalBar)
    barsSinceSignal := bar_index - lastSignalBar
    barsSinceSignal
if show_dashboard and barstate.islast
    dashboard_pos = dashboard_position_input == 'Top Left' ? position.top_left : dashboard_position_input == 'Top Right' ? position.top_right : dashboard_position_input == 'Bottom Left' ? position.bottom_left : position.bottom_right
    cols = 4
    rows = dashboard_size == 'Small' ? 8 : dashboard_size == 'Normal' ? 20 : 40
    if not na(dashboard)
        table.delete(dashboard)
    dashboard := table.new(dashboard_pos, cols, rows, border_width = 1, border_color = color.new(color.gray, 50), bgcolor = color.new(#1e222d, 20))
    dc_white = color.white
    dc_gray = #B2B5BE
    dc_green = #26A69A
    dc_red = #EF5350
    dc_gold = #FFD700
    dc_purple = quantumColor
    dc_aqua = bullColor
    dc_orange = #FF8C00
    dc_cyan = #00FFFF
    bg_header = color.new(color.black, 30)
    bg_section = color.new(color.gray, 85)
    header_size = size.small
    value_size = size.small
    label_size = size.tiny
    current_row = 0
    table.merge_cells(dashboard, 0, current_row, cols - 1, current_row)
    table.cell(dashboard, 0, current_row, '‚áã Reversal Point Dynamics  | ' + syminfo.ticker, text_halign = text.align_center, text_color = dc_white, bgcolor = bg_header, text_size = header_size)
    current_row := current_row + 1
    table.merge_cells(dashboard, 0, current_row, cols - 1, current_row)
    table.cell(dashboard, 0, current_row, '‚ïê‚ïê‚ïê üéØ UNIFIED PROB SCORE ‚ïê‚ïê‚ïê', text_halign = text.align_center, text_color = dc_gold, bgcolor = bg_section, text_size = label_size)
    current_row := current_row + 1
    totalScore = math.max(nz(peakProb, lastPeakProb), nz(valleyProb, lastValleyProb))
    signalQuality = totalScore >= 90 ? 'EXCEPTIONAL' : totalScore >= 75 ? 'STRONG' : totalScore >= 60 ? 'MODERATE' : totalScore >= 30 ? 'BUILDING' : 'WEAK'
    scoreColor = signalQuality == 'EXCEPTIONAL' ? dc_gold : signalQuality == 'STRONG' ? dc_green : signalQuality == 'MODERATE' ? dc_aqua : signalQuality == 'BUILDING' ? dc_orange : dc_gray
    table.cell(dashboard, 0, current_row, 'TOTAL SCORE', text_color = dc_gray, text_size = label_size)
    table.merge_cells(dashboard, 1, current_row, cols - 1, current_row)
    table.cell(dashboard, 1, current_row, str.tostring(totalScore, '#.##'), text_halign = text.align_right, text_color = scoreColor, text_size = value_size)
    current_row := current_row + 1
    table.cell(dashboard, 0, current_row, 'Quality', text_color = dc_gray, text_size = label_size)
    table.merge_cells(dashboard, 1, current_row, cols - 1, current_row)
    qualityEmoji = signalQuality == 'EXCEPTIONAL' ? 'üåü' : signalQuality == 'STRONG' ? 'üí™' : signalQuality == 'MODERATE' ? 'üëç' : '‚ö†Ô∏è'
    table.cell(dashboard, 1, current_row, qualityEmoji + ' ' + signalQuality, text_halign = text.align_right, text_color = scoreColor, text_size = value_size)
    current_row := current_row + 1
    if dashboard_size != 'Small'
        table.merge_cells(dashboard, 0, current_row, cols - 1, current_row)
        table.cell(dashboard, 0, current_row, '‚ïê‚ïê‚ïê üìä ORDER FLOW ‚ïê‚ïê‚ïê', text_halign = text.align_center, text_color = dc_gold, bgcolor = bg_section, text_size = label_size)
        current_row := current_row + 1
        table.cell(dashboard, 0, current_row, 'Volume Spike', text_color = dc_gray, text_size = label_size)
        table.merge_cells(dashboard, 1, current_row, cols - 1, current_row)
        table.cell(dashboard, 1, current_row, volSpike ? 'YES (' + str.tostring(volume / avgVolRecent, '#.#') + 'x)' : 'NO', text_halign = text.align_right, text_color = volSpike ? dc_green : dc_red, text_size = value_size)
        current_row := current_row + 1
        table.merge_cells(dashboard, 0, current_row, cols - 1, current_row)
        table.cell(dashboard, 0, current_row, 'üìä Component Analysis', text_halign = text.align_center, text_color = dc_aqua, text_size = label_size)
        current_row := current_row + 1
        table.cell(dashboard, 0, current_row, 'Peak Conf', text_color = dc_gray, text_size = label_size)
        peakColor = peakProb > 70 ? dc_red : peakProb > 40 ? dc_orange : dc_gray
        table.cell(dashboard, 1, current_row, str.tostring(peakProb, '#.#'), text_halign = text.align_right, text_color = peakColor, text_size = label_size)
        table.cell(dashboard, 2, current_row, 'Valley Conf', text_color = dc_gray, text_size = label_size)
        valleyColor = valleyProb > 70 ? dc_green : valleyProb > 40 ? dc_aqua : dc_gray
        table.cell(dashboard, 3, current_row, str.tostring(valleyProb, '#.#'), text_halign = text.align_right, text_color = valleyColor, text_size = label_size)
        current_row := current_row + 1
        table.merge_cells(dashboard, 0, current_row, cols - 1, current_row)
        table.cell(dashboard, 0, current_row, '‚ïê‚ïê‚ïê üåå MARKET STRUCTURE ‚ïê‚ïê‚ïê', text_halign = text.align_center, text_color = dc_gold, bgcolor = bg_section, text_size = label_size)
        current_row := current_row + 1
        trendDirection = rTrend == 1 ? 1 : -1
        table.cell(dashboard, 0, current_row, 'HTF Trend', text_color = dc_gray, text_size = label_size)
        htfText = trendDirection > 0 ? 'üìà BULL (' + str.tostring(trendStrength, '#.#') + '%)' : 'üìâ BEAR (' + str.tostring(trendStrength, '#.#') + '%)'
        htfColor = trendDirection > 0 ? dc_green : dc_red
        table.merge_cells(dashboard, 1, current_row, cols - 1, current_row)
        table.cell(dashboard, 1, current_row, htfText, text_halign = text.align_right, text_color = htfColor, text_size = label_size)
        current_row := current_row + 1
        table.cell(dashboard, 0, current_row, 'Entropy', text_color = dc_gray, text_size = label_size)
        entropyText = entropy < effectiveEntropyThresh ? 'üî• LOW' : entropy < 0.8 ? 'üìä MED' : 'üò¥ HIGH'
        entropyColor = entropy < effectiveEntropyThresh ? dc_green : entropy < 0.8 ? dc_gold : dc_red
        table.merge_cells(dashboard, 1, current_row, cols - 1, current_row)
        table.cell(dashboard, 1, current_row, entropyText + ' (' + str.tostring(entropy, '#.##') + ')', text_halign = text.align_right, text_color = entropyColor, text_size = value_size)
        current_row := current_row + 1
        current_row
    if dashboard_size == 'Large'
        table.merge_cells(dashboard, 0, current_row, cols - 1, current_row)
        table.cell(dashboard, 0, current_row, '‚ïê‚ïê‚ïê üõ°Ô∏è FILTERS & PREDICTIVES ‚ïê‚ïê‚ïê', text_halign = text.align_center, text_color = dc_gold, bgcolor = bg_section, text_size = label_size)
        current_row := current_row + 1
        table.cell(dashboard, 0, current_row, 'RSI Status', text_color = dc_gray, text_size = label_size)
        rsiText = rsi > rsiTop ? 'Overbought' : rsi < rsiBot ? 'Oversold' : 'Neutral'
        rsiColor = rsi > rsiTop ? dc_red : rsi < rsiBot ? dc_green : dc_gray
        table.cell(dashboard, 1, current_row, rsiText + ' (' + str.tostring(rsi, '#.##') + ')', text_halign = text.align_right, text_color = rsiColor, text_size = label_size)
        table.cell(dashboard, 2, current_row, 'Divergence', text_color = dc_gray, text_size = label_size)
        divText = isBearishDivergence ? 'Bearish' : isBullishDivergence ? 'Bullish' : 'None'
        divColor = isBearishDivergence ? dc_red : isBullishDivergence ? dc_green : dc_gray
        table.cell(dashboard, 3, current_row, divText, text_halign = text.align_right, text_color = divColor, text_size = label_size)
        current_row := current_row + 1
        table.cell(dashboard, 0, current_row, 'Live Pending', text_color = dc_gray, text_size = label_size)
        table.merge_cells(dashboard, 1, current_row, cols - 1, current_row)
        table.cell(dashboard, 1, current_row, livePending ? 'YES (' + (not na(livePeakProb) ? 'Peak ' + str.tostring(livePeakProb, '#.#') : 'Valley ' + str.tostring(liveValleyProb, '#.#')) + '%)' : 'NO', text_halign = text.align_right, text_color = livePending ? dc_gold : dc_gray, text_size = value_size)
        current_row := current_row + 1
        table.cell(dashboard, 0, current_row, 'Predictive Mode', text_color = dc_gray, text_size = label_size)
        table.merge_cells(dashboard, 1, current_row, cols - 1, current_row)
        table.cell(dashboard, 1, current_row, predictiveMode ? 'ON' : 'OFF', text_halign = text.align_right, text_color = predictiveMode ? dc_green : dc_red, text_size = value_size)
        current_row := current_row + 1
        table.cell(dashboard, 0, current_row, 'Last Signal', text_color = dc_gray, text_size = label_size)
        table.cell(dashboard, 1, current_row, lastSignalType, text_halign = text.align_right, text_color = lastSignalType == 'Valley' ? dc_green : lastSignalType == 'Peak' ? dc_red : dc_gray, text_size = label_size)
        table.cell(dashboard, 2, current_row, 'Bars Since', text_color = dc_gray, text_size = label_size)
        table.cell(dashboard, 3, current_row, str.tostring(barsSinceSignal), text_halign = text.align_right, text_color = dc_white, text_size = label_size)
        current_row := current_row + 1
        table.cell(dashboard, 0, current_row, 'Entropy Particles', text_color = dc_gray, text_size = label_size)
        table.merge_cells(dashboard, 1, current_row, cols - 1, current_row)
        table.cell(dashboard, 1, current_row, showEntropyParticles ? 'ON (Strength: ' + str.tostring(1.0 - entropy, '#.#') + ')' : 'OFF', text_halign = text.align_right, text_color = showEntropyParticles ? dc_purple : dc_gray, text_size = label_size)
        current_row := current_row + 1
        current_row
        //==================================================================
        // WATERMARK
        //==================================================================
var table watermarkTable = na
if na(watermarkTable)
    watermarkTable := table.new(position.bottom_center, 1, 1, bgcolor = color.new(color.black, 90), border_color = color.new(color.purple, 80), border_width = 1)
    watermarkTable
table.clear(watermarkTable, 0, 0)
table.cell(watermarkTable, 0, 0, '‚áã Reversal Point Dynamics (DAFE)', text_color = color.rgb(200, 200, 255), text_size = size.normal)





////@version=6
//indicator('üìä‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è Information-Geometric Market Dynamics DskyzInvestments', shorttitle = 'üìä‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è IGMD DskyzInv', overlay = true, max_lines_count = 500, max_labels_count = 500, max_boxes_count = 500, max_bars_back = 5000)

//==============================================================================
// üéØ INFORMATION-GEOMETRIC MARKET DYNAMICS (IGMD) - COMPLETE THEORY & USER GUIDE
//==============================================================================
//
// üìä IGMD: THE PHYSICS OF MARKET MOVEMENT - A REVOLUTIONARY APPROACH
//
// Welcome to Information-Geometric Market Dynamics (IGMD), a groundbreaking analytical
// framework that applies principles from theoretical physics, information theory, and
// differential geometry to decode market behavior. IGMD transcends traditional technical
// analysis by treating markets as complex information fields where price movements
// represent the flow of information through geometric manifolds.
//
// ‚ö° THE REVOLUTIONARY PARADIGM SHIFT:
//
// Traditional indicators measure what happened. IGMD reveals WHY it happened and WHAT comes next.
//
// 1. INFORMATION FIELD THEORY:
//    Markets are not random walks but structured information fields where every price
//    movement carries geometric significance. IGMD maps these fields using five fundamental
//    dimensions: Wavelet (multi-scale structure), Hurst (memory persistence), Fractal
//    (complexity), Entropy (disorder), and Transfer Entropy (causal flow).
//
// 2. MULTI-DIMENSIONAL MARKET GEOMETRY:
//    - WAVELET TRANSFORM: Decomposes price into frequency components like a market MRI
//    - HURST EXPONENT: Measures whether trends persist (H>0.5) or revert (H<0.5)
//    - FRACTAL DIMENSION: Quantifies market roughness and path complexity
//    - SHANNON ENTROPY: Captures information content and uncertainty levels
//    - TRANSFER ENTROPY: Reveals directional causality between market forces
//
// 3. FIELD SCORE SYNTHESIS:
//    The revolutionary Field Score fuses all dimensions into a single unified measure
//    of market state. Think of it as the "market weather" - positive values indicate
//    bullish field conditions, negative values bearish fields, near-zero transitional.
//
// 4. PATTERN FIELD DETECTION:
//    IGMD identifies geometric patterns in the information field before they manifest
//    as price patterns. Range boxes visualize field coherence zones where information
//    accumulates before explosive moves. Each pattern type reveals specific field dynamics.
//
// 5. RISK/REWARD GEOMETRY:
//    Dynamic RR rails adapt to field conditions, automatically adjusting targets and
//    stops based on information flow. When price breaks levels, rails disappear,
//    creating a living risk management system synchronized with market geometry.
//
// üßÆ THE MATHEMATICS OF MARKET FIELDS:
//
// IGMD employs sophisticated mathematical frameworks rarely seen in trading:
//
// 1. STATIONARY WAVELET TRANSFORM (SWT):
//    Unlike simple moving averages, SWT preserves time-invariance while decomposing
//    price into orthogonal frequency bands. Each level captures different market
//    cycles without lag or phase distortion.
//
// 2. RESCALED RANGE ANALYSIS:
//    The Hurst exponent uses R/S statistics to measure long-range dependence.
//    Markets exhibit fractal scaling: H = log(R/S) / log(N) where R/S is the
//    rescaled range and N is the time scale.
//
// 3. HAUSDORFF DIMENSION:
//    Fractal dimension D measures how price fills space: D = log(N(Œµ))/log(1/Œµ)
//    where N(Œµ) counts boxes needed to cover the price path at scale Œµ.
//
// 4. SHANNON ENTROPY:
//    Information content H = -Œ£ p(i) log p(i) quantifies uncertainty in return
//    distributions. Low entropy signals directional clarity, high entropy chaos.
//
// 5. KULLBACK-LEIBLER DIVERGENCE:
//    Transfer entropy TE = Œ£ p(yn+1,yn,xn) log[p(yn+1|yn,xn)/p(yn+1|yn)]
//    measures information flow from driver X to price Y.
//
// üí° TRADING PHILOSOPHY WITH IGMD:
//
// Markets are information processing systems where price discovers value through
// collective computation. IGMD reveals this hidden computation by mapping the
// geometric structure of information flow. When fields align (high Field Score),
// markets trend powerfully. When fields decohere (near-zero Field Score), markets
// consolidate. Pattern emergence signals field reorganization - the market's way
// of processing new information into price discovery.
//
// üéØ SIGNAL GENERATION LOGIC:
//
// IGMD generates signals through multi-dimensional confluence:
// - Field Score exceeds directional thresholds
// - Component indicators align (wavelets, Hurst, entropy)
// - Pattern field confirms setup quality
// - MTF context validates higher timeframe bias
// - Risk/Reward geometry favors the trade
//
// Each signal carries a probability score based on field coherence strength.
// Higher probability signals occur when all dimensional fields align perfectly,
// creating what physicists call "field resonance" - unstoppable directional moves.
//
// ‚ö†Ô∏è ADVANCED FIELD DYNAMICS:
//
// ‚Ä¢ Field Bifurcation: When Field Score oscillates near zero, markets approach
//   critical points where small events trigger large moves (butterfly effect)
// ‚Ä¢ Entropy Cascades: Sudden entropy drops often precede explosive trends as
//   uncertainty collapses into directional certainty
// ‚Ä¢ Wavelet Divergence: When fast and slow wavelets diverge, major trends emerge
// ‚Ä¢ Transfer Entropy Reversals: TE polarity flips signal causality regime changes
// ‚Ä¢ Fractal Transitions: FDI moving from 2.0 to 1.0 indicates chaos-to-trend shift
//
// üöÄ PERFORMANCE OPTIMIZATION:
//
// IGMD performs heavy calculations. For smooth operation:
// - Use on liquid instruments with clean price action
// - Higher timeframes (15m+) provide better signal quality
// - Reduce pattern history if performance lags
// - Disable unused features (MTF, patterns) if needed
// - Modern browsers/devices recommended for full experience
//
//==============================================================================
// üìä IGMD INPUT CONFIGURATION - COMPLETE REFERENCE GUIDE
//==============================================================================
group_wave = 'üìä Wavelet Transform Engine'
wl_kernel = input.string('Haar', 'Wavelet Kernel', options = ['Haar', 'db2'], group = group_wave, tooltip = 'üéØ WHAT IT IS: The mathematical basis function for multi-resolution price decomposition.\n\n‚ö° HOW IT WORKS: Wavelets act like mathematical microscopes, zooming into different frequency components of price action. Each kernel has unique properties for signal processing.\n\nüìà HAAR WAVELET:\n‚Ä¢ Simplest orthogonal wavelet (step function)\n‚Ä¢ Perfect time localization\n‚Ä¢ Best for: Choppy markets, noise filtering\n‚Ä¢ Computation: Fastest\n‚Ä¢ Character: Sharp, responsive, blocky\n\nüìâ DAUBECHIES-2 (DB2):\n‚Ä¢ Smooth, continuous wavelet\n‚Ä¢ Balanced time-frequency localization\n‚Ä¢ Best for: Trending markets, smooth analysis\n‚Ä¢ Computation: Moderate\n‚Ä¢ Character: Smooth, nuanced, flowing\n\nüïí TIMEFRAME OPTIMIZATION:\n‚Ä¢ Scalping (1-5min): Haar (captures micro-structure)\n‚Ä¢ Day Trading (15min-1H): db2 (balanced smoothness)\n‚Ä¢ Swing Trading (4H-Daily): db2 (trend clarity)\n\nüè¶ MARKET RECOMMENDATIONS:\n‚Ä¢ Forex: db2 (smooth price action)\n‚Ä¢ Crypto: Haar (handles volatility spikes)\n‚Ä¢ Stocks: db2 (cleaner institutional flow)\n‚Ä¢ Commodities: db2 (trend-following nature)\n\nüí° PRO TIP: Start with db2 for most markets. Switch to Haar only if you need faster response in choppy conditions or are analyzing market microstructure.')
wl_levels = input.int(2, 'Decomposition Levels', minval = 2, maxval = 4, group = group_wave, tooltip = 'üéØ WHAT IT IS: Number of frequency scales to decompose price into (like octaves in music).\n\n‚ö° HOW IT WORKS: Each level doubles the time scale: Level 1 = 2 bars, Level 2 = 4 bars, Level 3 = 8 bars, Level 4 = 16 bars. More levels capture longer cycles.\n\nüìà HIGHER LEVELS (3-4):\n‚Ä¢ Captures longer-term cycles\n‚Ä¢ Smoother trend identification\n‚Ä¢ Better for position trading\n‚Ä¢ More lag but fewer false signals\n\nüìâ LOWER LEVELS (2):\n‚Ä¢ Focuses on short-term structure\n‚Ä¢ More responsive to price changes\n‚Ä¢ Better for scalping\n‚Ä¢ Less lag but more noise\n\nüïí TIMEFRAME OPTIMIZATION:\n‚Ä¢ 1-5 min charts: 2 levels (avoid over-smoothing)\n‚Ä¢ 15min-1H charts: 3 levels (optimal balance)\n‚Ä¢ 4H-Daily charts: 3-4 levels (capture weekly cycles)\n\nüí° PRO TIP: Level 3 is the sweet spot for most trading. It captures daily, 2-day, and weekly cycles without excessive lag. Only use Level 4 on higher timeframes where you need monthly cycle analysis.')
group_hurst = 'üìà Hurst Exponent Memory Detector'
hurst_window = input.int(125, 'Analysis Window', minval = 60, maxval = 1000, group = group_hurst, tooltip = 'üéØ WHAT IT IS: The lookback period for calculating market memory and trend persistence using Rescaled Range analysis.\n\n‚ö° HOW IT WORKS: Hurst Exponent H reveals market character:\n‚Ä¢ H > 0.5: Trending (persistence) - trends tend to continue\n‚Ä¢ H = 0.5: Random walk - no memory\n‚Ä¢ H < 0.5: Mean-reverting (anti-persistence) - trends tend to reverse\n\nüìà LARGER WINDOWS (300-1000):\n‚Ä¢ More statistically reliable\n‚Ä¢ Captures long-term market regime\n‚Ä¢ Slower to adapt to changes\n‚Ä¢ Better for position trading\n\nüìâ SMALLER WINDOWS (60-150):\n‚Ä¢ More responsive to regime changes\n‚Ä¢ May give false readings in noise\n‚Ä¢ Better for short-term trading\n‚Ä¢ Adapts quickly to new conditions\n\nüïí TIMEFRAME OPTIMIZATION:\n‚Ä¢ Scalping: 60-100 (quick regime detection)\n‚Ä¢ Day Trading: 150-250 (balanced reliability)\n‚Ä¢ Swing Trading: 200-500 (stable readings)\n‚Ä¢ Investing: 500+ (long-term character)\n\nüè¶ MARKET CHARACTERISTICS:\n‚Ä¢ Forex: Often H ‚âà 0.5 (efficient)\n‚Ä¢ Stocks: Often H > 0.5 (trending)\n‚Ä¢ Crypto: Varies wildly (regime-dependent)\n‚Ä¢ Commodities: Often H > 0.6 (super-trending)\n\nüí° PRO TIP: Use 200 bars as baseline - roughly 50 4-hour candles or 8 daily candles. This captures about 2 weeks of market behavior, enough for reliable statistics without excessive lag.')
group_fdi = 'üîç Fractal Dimension Complexity Analyzer'
fdi_len = input.int(32, 'FDI Calculation Length', minval = 16, maxval = 256, group = group_fdi, tooltip = 'üéØ WHAT IT IS: The window for calculating Fractal Dimension Index using the FRAMA (Fractal Adaptive Moving Average) algorithm.\n\n‚ö° HOW IT WORKS: FDI measures how price path fills space:\n‚Ä¢ FDI ‚âà 1.0: Straight line (strong trend)\n‚Ä¢ FDI ‚âà 1.5: Typical market (mixed)\n‚Ä¢ FDI ‚âà 2.0: Space-filling (pure noise)\n\nLower FDI = Smoother/trending | Higher FDI = Rougher/ranging\n\nüìà LONGER LENGTHS (64-256):\n‚Ä¢ More stable FDI readings\n‚Ä¢ Better long-term complexity measure\n‚Ä¢ Filters out micro-noise\n‚Ä¢ Suitable for higher timeframes\n\nüìâ SHORTER LENGTHS (16-32):\n‚Ä¢ More responsive to complexity changes\n‚Ä¢ Captures local market texture\n‚Ä¢ Good for pattern recognition\n‚Ä¢ Suitable for lower timeframes\n\nüïí TIMEFRAME OPTIMIZATION:\n‚Ä¢ 1-5 min: 16-24 (local complexity)\n‚Ä¢ 15min-1H: 32-48 (standard analysis)\n‚Ä¢ 4H-Daily: 48-128 (structural complexity)\n\nüè¶ TYPICAL FDI VALUES BY MARKET:\n‚Ä¢ Strong Trends: 1.2-1.4\n‚Ä¢ Normal Markets: 1.4-1.6\n‚Ä¢ Ranging/Choppy: 1.6-1.8\n‚Ä¢ High Volatility: 1.8-2.0\n\nüí° PRO TIP: FDI of 32 works universally. Watch for FDI dropping below 1.4 (trend emerging) or rising above 1.7 (trend ending). The transition zones 1.4-1.5 and 1.6-1.7 often mark regime changes.')
group_entropy = '‚ö° Shannon Entropy Information Analyzer'
ent_window = input.int(125, 'Entropy Window', minval = 50, maxval = 600, group = group_entropy, tooltip = 'üéØ WHAT IT IS: Rolling window for calculating Shannon entropy of return distributions to measure market uncertainty.\n\n‚ö° HOW IT WORKS: Entropy quantifies information content:\n‚Ä¢ Low Entropy: Predictable, directional, organized\n‚Ä¢ High Entropy: Unpredictable, random, chaotic\n‚Ä¢ Falling Entropy: Uncertainty resolving into trend\n‚Ä¢ Rising Entropy: Trend dissolving into chaos\n\nüìà LARGER WINDOWS (300-600):\n‚Ä¢ Stable entropy measurements\n‚Ä¢ Long-term uncertainty gauge\n‚Ä¢ Better statistical significance\n‚Ä¢ Slower to react to changes\n\nüìâ SMALLER WINDOWS (50-150):\n‚Ä¢ Responsive to uncertainty shifts\n‚Ä¢ Captures local information changes\n‚Ä¢ More false signals possible\n‚Ä¢ Faster regime detection\n\nüïí TIMEFRAME OPTIMIZATION:\n‚Ä¢ Scalping: 50-100 (quick uncertainty shifts)\n‚Ä¢ Day Trading: 150-250 (balanced measure)\n‚Ä¢ Swing Trading: 200-400 (stable readings)\n‚Ä¢ Position Trading: 400+ (major regime shifts)\n\n‚ö†Ô∏è ENTROPY INTERPRETATION:\n‚Ä¢ Entropy < 0.3: Strong directional bias\n‚Ä¢ Entropy 0.3-0.7: Normal market conditions\n‚Ä¢ Entropy > 0.7: High uncertainty/volatility\n‚Ä¢ Sudden drops: Breakout imminent\n‚Ä¢ Sudden spikes: Trend exhaustion\n\nüí° PRO TIP: 200 bars captures sufficient return samples for reliable entropy. Watch for entropy dropping below its average - this often precedes explosive moves as uncertainty collapses into directional certainty.')
ent_bins = input.int(6, 'Histogram Bins', minval = 3, maxval = 15, group = group_entropy, tooltip = 'üéØ WHAT IT IS: Number of bins for discretizing return distributions in entropy calculation.\n\n‚ö° HOW IT WORKS: Returns are grouped into bins to estimate probability distributions:\n‚Ä¢ Fewer Bins: Coarser but stable estimates\n‚Ä¢ More Bins: Finer but noisier estimates\n‚Ä¢ Optimal: Square root of sample size\n\nüìà MORE BINS (10-15):\n‚Ä¢ Captures distribution details\n‚Ä¢ Better for large sample sizes\n‚Ä¢ May overfit in small samples\n‚Ä¢ Higher computational load\n\nüìâ FEWER BINS (3-6):\n‚Ä¢ Robust to small samples\n‚Ä¢ Smooth entropy estimates\n‚Ä¢ May miss distribution nuances\n‚Ä¢ Fast computation\n\nüî¨ STATISTICAL THEORY:\n‚Ä¢ Sturges Rule: bins = 1 + log2(N)\n‚Ä¢ Square Root: bins = sqrt(N)\n‚Ä¢ Rice Rule: bins = 2 * N^(1/3)\n‚Ä¢ For 200 samples: optimal ‚âà 7-9 bins\n\nüí° PRO TIP: 7 bins is statistically optimal for 200-bar windows. This follows Sturges rule and provides good balance between resolution and stability. Only increase if using windows > 500 bars.')
ent_normATR = input.bool(true, 'ATR Normalization', group = group_entropy, tooltip = 'üéØ WHAT IT IS: Whether to normalize returns by Average True Range before entropy calculation.\n\n‚ö° HOW IT WORKS:\n‚Ä¢ ON: Returns divided by ATR (volatility-adjusted)\n‚Ä¢ OFF: Raw percentage returns used\n\n‚úÖ ATR NORMALIZATION ON:\n‚Ä¢ Compares "surprises" relative to volatility\n‚Ä¢ Works across different volatility regimes\n‚Ä¢ Better for adaptive systems\n‚Ä¢ Recommended for most cases\n\n‚ùå ATR NORMALIZATION OFF:\n‚Ä¢ Uses absolute return magnitudes\n‚Ä¢ Entropy dominated by volatility changes\n‚Ä¢ Better for fixed volatility assets\n‚Ä¢ Useful for comparing across instruments\n\nüí° PRO TIP: Always use ATR normalization unless comparing multiple instruments. It makes entropy measure "surprise" rather than just "movement", which is what really matters for prediction.')
ent_atrLen = input.int(14, 'ATR Period', minval = 5, maxval = 100, group = group_entropy, tooltip = 'üéØ WHAT IT IS: Period for Average True Range calculation used in return normalization.\n\n‚ö° STANDARD VALUES:\n‚Ä¢ 14: Classic Wilder setting\n‚Ä¢ 10: More responsive\n‚Ä¢ 20: Smoother\n‚Ä¢ 7: Short-term volatility\n‚Ä¢ 21: Monthly volatility\n\nüí° PRO TIP: Keep at 14 - its the market standard and works across all timeframes.')
ent_zLen = input.int(200, 'Z-Score Lookback', minval = 50, maxval = 1000, group = group_entropy, tooltip = 'üéØ WHAT IT IS: Period for normalizing entropy into Z-scores to identify statistical extremes.\n\n‚ö° HOW IT WORKS: Z-score = (Entropy - Mean) / StdDev\n‚Ä¢ Z > 2: Extremely high entropy (rare)\n‚Ä¢ Z < -2: Extremely low entropy (rare)\n‚Ä¢ Extremes often precede major moves\n\nüí° PRO TIP: Match this to your entropy window (200) for consistent statistical analysis.')
group_te = 'üîÑ Transfer Entropy Causal Flow Detector'
te_window = input.int(125, 'TE Analysis Window', minval = 80, maxval = 800, group = group_te, tooltip = 'üéØ WHAT IT IS: Window for calculating directional information flow between market drivers and price using Transfer Entropy.\n\n‚ö° HOW IT WORKS: TE measures causality - does X drive Y?\n‚Ä¢ Positive TE: Driver leads price (predictive)\n‚Ä¢ Negative TE: Price leads driver (reactive)\n‚Ä¢ Near-zero TE: No causal relationship\n\nüìà LARGER WINDOWS (400-800):\n‚Ä¢ More reliable causality detection\n‚Ä¢ Captures long-term relationships\n‚Ä¢ Better statistical significance\n‚Ä¢ Suitable for macro analysis\n\nüìâ SMALLER WINDOWS (80-200):\n‚Ä¢ Responsive to causality shifts\n‚Ä¢ Detects short-term influences\n‚Ä¢ More noise in measurements\n‚Ä¢ Suitable for tactical trading\n\nüïí OPTIMAL WINDOWS BY TIMEFRAME:\n‚Ä¢ 1-15 min: 80-150 bars\n‚Ä¢ 1H: 150-250 bars\n‚Ä¢ 4H: 200-400 bars\n‚Ä¢ Daily: 300-600 bars\n\nüéØ MINIMUM REQUIREMENTS:\n‚Ä¢ Need at least 50 samples for reliability\n‚Ä¢ 200 bars provides good balance\n‚Ä¢ More is better for statistical power\n\nüí° PRO TIP: TE needs substantial data - use 200 minimum. This captures enough state transitions to reliably measure information flow while remaining responsive to regime changes.')
te_thresh = input.float(0.08, 'State Quantization Threshold', minval = 0.01, maxval = 1.0, step = 0.01, group = group_te, tooltip = 'üéØ WHAT IT IS: Return threshold for discretizing continuous prices into discrete states for TE calculation.\n\n‚ö° HOW IT WORKS: Returns are classified:\n‚Ä¢ Return > +threshold: Upward state\n‚Ä¢ Return < -threshold: Downward state\n‚Ä¢ Between: Neutral state\n\nüìà HIGHER THRESHOLDS (0.15-1.0):\n‚Ä¢ Only captures significant moves\n‚Ä¢ More robust to noise\n‚Ä¢ Fewer state transitions\n‚Ä¢ Better for volatile markets\n\nüìâ LOWER THRESHOLDS (0.01-0.07):\n‚Ä¢ Captures subtle movements\n‚Ä¢ More state transitions\n‚Ä¢ Higher TE sensitivity\n‚Ä¢ Better for stable markets\n\nüè¶ MARKET-SPECIFIC SETTINGS:\n‚Ä¢ Forex: 0.05-0.08 (tight spreads)\n‚Ä¢ Stocks: 0.08-0.12 (medium volatility)\n‚Ä¢ Crypto: 0.10-0.20 (high volatility)\n‚Ä¢ Indices: 0.06-0.10 (smooth moves)\n\nüí° PRO TIP: Set threshold to roughly 0.5x daily ATR percentage. For example, if daily ATR is 2%, use 0.08-0.10. This captures meaningful moves while filtering micro-noise.')
te_driver = input.string('OBV', 'Causality Driver', options = ['OBV', 'Volume', 'VWAP', 'External Symbol'], group = group_te, tooltip = 'üéØ WHAT IT IS: The market variable to test for causal influence on price.\n\n‚ö° DRIVER OPTIONS:\n\nüìä OBV (On-Balance Volume):\n‚Ä¢ Cumulative volume flow indicator\n‚Ä¢ Best for: Detecting accumulation/distribution\n‚Ä¢ Reveals: Smart money positioning\n‚Ä¢ Works well: All markets\n\nüìä VOLUME:\n‚Ä¢ Raw transaction volume\n‚Ä¢ Best for: Liquidity analysis\n‚Ä¢ Reveals: Participation levels\n‚Ä¢ Works well: Liquid markets\n\nüìä VWAP:\n‚Ä¢ Volume-weighted average price\n‚Ä¢ Best for: Institutional levels\n‚Ä¢ Reveals: Fair value deviations\n‚Ä¢ Works well: Stocks, futures\n\nüìä EXTERNAL SYMBOL:\n‚Ä¢ Any correlated instrument\n‚Ä¢ Examples: VIX, DXY, Gold, Bond yields\n‚Ä¢ Best for: Intermarket analysis\n‚Ä¢ Reveals: Macro influences\n\nüéØ SELECTION GUIDE:\n‚Ä¢ Stocks: OBV or VWAP\n‚Ä¢ Forex: External (DXY, yields)\n‚Ä¢ Crypto: Volume or OBV\n‚Ä¢ Commodities: External (DXY, related futures)\n\nüí° PRO TIP: Start with OBV - it combines price and volume information optimally. Switch to External only for specific intermarket analysis (e.g., VIX for S&P500, DXY for forex pairs).')
te_symbol = input.symbol('TVC:VIX', 'External Driver Symbol', group = group_te, tooltip = 'üéØ WHAT IT IS: External symbol for causality analysis when using External Symbol driver.\n\n‚ö° POWERFUL COMBINATIONS:\n‚Ä¢ SPY/QQQ + VIX: Fear drives markets\n‚Ä¢ Forex + DXY: Dollar dominance\n‚Ä¢ Gold + Real Yields: Inflation hedge\n‚Ä¢ Crypto + TOTAL2: Altcoin correlation\n‚Ä¢ Oil + USO: Energy sector leader\n\nüí° PRO TIP: Use highly correlated but leading indicators. VIX often leads equity reversals, DXY leads forex pairs, Bitcoin leads altcoins.')
te_tf_in = input.string('', 'External Timeframe', group = group_te, tooltip = 'üéØ WHAT IT IS: Timeframe for external symbol data (blank = current chart timeframe).\n\n‚ö° USE CASES:\n‚Ä¢ Higher TF: Macro influence (Daily DXY on 1H chart)\n‚Ä¢ Same TF: Direct correlation (blank/default)\n‚Ä¢ Lower TF: Leading microstructure (rare)\n\nüí° PRO TIP: Leave blank for most cases. Only specify for macro overlays.')
te_sigMin = input.float(0.08, 'TE Significance Filter', minval = 0.0, maxval = 0.5, step = 0.01, group = group_te, tooltip = 'üéØ WHAT IT IS: Minimum Transfer Entropy magnitude to consider significant (filters weak relationships).\n\n‚ö° HOW IT WORKS:\n‚Ä¢ TE below threshold treated as zero\n‚Ä¢ Filters statistical noise\n‚Ä¢ Focuses on meaningful causality\n\nüìà HIGHER VALUES (0.15-0.5):\n‚Ä¢ Only strongest relationships\n‚Ä¢ Very few signals\n‚Ä¢ High confidence when triggered\n\nüìâ LOWER VALUES (0.01-0.07):\n‚Ä¢ Includes weak relationships\n‚Ä¢ More signals\n‚Ä¢ More false positives\n\nüí° PRO TIP: 0.08 filters noise while preserving real signals. Increase in choppy markets, decrease in trending markets.')
corr_len = input.int(55, 'Correlation Fallback Period', minval = 20, maxval = 300, group = group_te, tooltip = 'üéØ WHAT IT IS: Period for Pearson correlation as fallback when TE calculation fails.\n\n‚ö° WHY NEEDED: TE requires many state transitions. In strong trends with few transitions, correlation provides backup causality measure.\n\nüí° PRO TIP: 55 bars (quarterly cycle) provides stable correlation. This fallback rarely triggers except in extreme trending conditions.')
corr_w = input.float(0.25, 'Correlation Weight', minval = 0.0, maxval = 1.0, step = 0.05, group = group_te, tooltip = 'üéØ WHAT IT IS: How much correlation contributes to final TE score when both are available.\n\n‚ö° FORMULA: Final = TE + (Weight √ó Correlation)\n\nüìà HIGHER WEIGHTS (0.4-1.0):\n‚Ä¢ More correlation influence\n‚Ä¢ Smoother TE readings\n‚Ä¢ Better for trending markets\n\nüìâ LOWER WEIGHTS (0.0-0.2):\n‚Ä¢ Pure TE dominance\n‚Ä¢ More responsive\n‚Ä¢ Better for ranging markets\n\nüí° PRO TIP: 0.25 adds slight smoothing without overpowering TEs causal information.')
te_step = input.int(2, 'TE Calculation Throttle', minval = 1, maxval = 10, group = group_te, tooltip = 'üéØ WHAT IT IS: Calculate Transfer Entropy every N bars to improve performance.\n\n‚ö° PERFORMANCE IMPACT:\n‚Ä¢ 1: Every bar (maximum CPU load)\n‚Ä¢ 2: Every other bar (50% reduction)\n‚Ä¢ 5: Every 5 bars (80% reduction)\n‚Ä¢ 10: Every 10 bars (90% reduction)\n\nüìà HIGHER VALUES (5-10):\n‚Ä¢ Much faster performance\n‚Ä¢ Good for slow devices\n‚Ä¢ May miss quick changes\n‚Ä¢ Fine for higher timeframes\n\nüìâ LOWER VALUES (1-2):\n‚Ä¢ Maximum responsiveness\n‚Ä¢ Heavy CPU usage\n‚Ä¢ Catches all transitions\n‚Ä¢ Needed for scalping\n\nüí° PRO TIP: Use 2 for good balance. TE changes slowly enough that every-other-bar calculation is sufficient. Only use 1 if you need absolute real-time precision.')
group_mtf = 'üåê Multi-Timeframe Confluence Engine'
use_mtf_ctx = input.bool(true, 'Enable MTF Analysis', group = group_mtf, tooltip = 'üéØ WHAT IT IS: Incorporates higher timeframe trend analysis for confluence.\n\n‚ö° BENEFITS:\n‚Ä¢ Confirms with larger trends\n‚Ä¢ Reduces counter-trend trades\n‚Ä¢ Improves win rate\n‚Ä¢ Adds institutional perspective\n\nüí° PRO TIP: Always enable unless scalping micro-moves. Higher timeframe bias is crucial for sustained directional moves.')
ref_tf1 = input.string('5', 'Primary Reference TF', group = group_mtf, tooltip = 'üéØ WHAT IT IS: First higher timeframe for trend confluence.\n\n‚ö° SELECTION GUIDE:\n‚Ä¢ Current TF √ó 3-5 = Good primary reference\n‚Ä¢ Examples: 5m‚Üí15m, 15m‚Üí1H, 1H‚Üí4H\n\nüïí COMMON COMBINATIONS:\n‚Ä¢ Scalping: 1m chart ‚Üí 5m reference\n‚Ä¢ Day Trading: 5m chart ‚Üí 30m reference\n‚Ä¢ Swing Trading: 1H chart ‚Üí 4H reference\n‚Ä¢ Position Trading: 4H chart ‚Üí Daily reference\n\nüí° PRO TIP: Use standard timeframes (5,15,30,60,240) as they represent institutional decision points.')
ref_tf2 = input.string('15', 'Secondary Reference TF', group = group_mtf, tooltip = 'üéØ WHAT IT IS: Second higher timeframe for additional confluence.\n\n‚ö° SELECTION PRINCIPLE:\n‚Ä¢ Between primary reference and daily\n‚Ä¢ Provides intermediate perspective\n‚Ä¢ Should be 1.5-2x primary reference\n\nüí° PRO TIP: This captures the "in-between" timeframe that often shows transitional moves. 45-min is perfect between 30m and 1H.')
w_mtf = input.float(0.8, 'MTF Weight in Field Score', minval = 0, maxval = 3, step = 0.1, group = group_mtf, tooltip = 'üéØ WHAT IT IS: How much higher timeframe alignment influences the final Field Score.\n\n‚ö° WEIGHT IMPACT:\n‚Ä¢ 0: No MTF influence (disabled)\n‚Ä¢ 0.5: Moderate influence (25% of signal)\n‚Ä¢ 1.0: Equal weight with other components\n‚Ä¢ 2.0: Dominant influence (overrides others)\n\nüí° PRO TIP: 0.6 provides healthy bias without overwhelming local signals. Increase to 1.0+ only for strict trend-following systems.')
group_pattern = 'üéØ Geometric Pattern Field Detector'
show_patterns = input.bool(true, 'Enable Pattern Detection', group = group_pattern, tooltip = 'üéØ WHAT IT IS: Activates the geometric pattern field detection system that identifies coherent zones in the information field.\n\n‚ö° WHAT IT DOES:\n‚Ä¢ Identifies field coherence zones\n‚Ä¢ Tracks pattern evolution\n‚Ä¢ Measures pattern quality\n‚Ä¢ Visualizes accumulation areas\n\nüí° PRO TIP: Essential feature - patterns reveal where information geometry coheres before major moves.')
pattern_min_bars = input.int(5, 'Minimum Pattern Duration', minval = 2, maxval = 20, group = group_pattern, tooltip = 'üéØ WHAT IT IS: Minimum bars required for a valid pattern formation.\n\n‚ö° PATTERN QUALITY:\n‚Ä¢ 2-3 bars: Captures quick formations (more signals)\n‚Ä¢ 4-6 bars: Balanced quality filter\n‚Ä¢ 7+ bars: Only major patterns (fewer, stronger)\n\nüïí TIMEFRAME OPTIMIZATION:\n‚Ä¢ Scalping (1-5m): 2-3 bars\n‚Ä¢ Day Trading (15m-1H): 3-5 bars\n‚Ä¢ Swing Trading (4H+): 5-8 bars\n\nüí° PRO TIP: Use 3 for most timeframes. This filters out noise while catching legitimate pattern formations. Increase only if getting too many false patterns.')
show_range_box = input.bool(true, 'Display Range Boxes', group = group_pattern, tooltip = 'üéØ WHAT IT IS: Shows colored boxes around detected pattern ranges.\n\n‚ö° VISUAL BENEFITS:\n‚Ä¢ Instant pattern recognition\n‚Ä¢ Clear entry/exit zones\n‚Ä¢ Pattern strength visualization\n‚Ä¢ Historical pattern analysis\n\nüí° PRO TIP: Keep enabled - these boxes are the core visual element showing where field coherence occurs.')
show_bar_boxes = input.bool(true, 'Show Individual Bar Patterns', group = group_pattern, tooltip = 'üéØ WHAT IT IS: Displays small boxes on individual candlestick patterns (engulfing, hammers, etc).\n\n‚ö° PATTERNS DETECTED:\n‚Ä¢ Engulfing (Bullish/Bearish)\n‚Ä¢ Inside/Outside bars\n‚Ä¢ Hammers/Shooting Stars\n‚Ä¢ Doji formations\n\nüí° PRO TIP: Useful for learning but can clutter charts. Disable once familiar with patterns.')
bar_box_style = input.string('Wick', 'Bar Box Style', options = ['Body', 'Wick', 'Full'], group = group_pattern, tooltip = 'üéØ WHAT IT IS: Visual style for individual bar pattern boxes.\n\n‚ö° STYLE OPTIONS:\n‚Ä¢ Body: Covers candle body only (clean)\n‚Ä¢ Wick: Extends to wicks (full range)\n‚Ä¢ Full: Maximum coverage (emphasis)\n\nüí° PRO TIP: "Body" provides cleanest visuals without obscuring price action.')
bar_box_opacity = input.int(20, 'Bar Box Transparency', minval = 0, maxval = 100, group = group_pattern, tooltip = 'üéØ WHAT IT IS: Transparency level for individual bar pattern boxes.\n\n‚ö° VISUAL BALANCE:\n‚Ä¢ 0-30: Bold, prominent (can obscure)\n‚Ä¢ 40-60: Balanced visibility\n‚Ä¢ 70-100: Subtle hints\n\nüí° PRO TIP: 40% provides good visibility without dominating the chart.')
bar_box_history = input.int(50, 'Bar Pattern History', minval = 20, maxval = 1000, group = group_pattern, tooltip = 'üéØ WHAT IT IS: How many historical bar patterns to display.\n\n‚ö° PERFORMANCE IMPACT:\n‚Ä¢ 20-50: Minimal impact, recent patterns\n‚Ä¢ 100-200: Moderate impact, good history\n‚Ä¢ 500+: Heavy impact, full analysis\n\nüí° PRO TIP: 50 bars shows recent patterns without cluttering. Increase only for pattern frequency analysis.')
pattern_style = input.string('Full', 'Range Box Style', options = ['Full', 'Body', 'Wick', 'Minimal', 'Dynamic'], group = group_pattern, tooltip = 'üéØ WHAT IT IS: Visual style for pattern range boxes.\n\n‚ö° STYLE CHARACTERISTICS:\n‚Ä¢ Full: Complete range coverage\n‚Ä¢ Body: Open/Close range only\n‚Ä¢ Wick: High/Low extremes\n‚Ä¢ Minimal: Thin line style\n‚Ä¢ Dynamic: Adapts to pattern type\n\nüí° PRO TIP: "Full" provides clearest pattern visualization. Use "Minimal" only on busy charts.')
pattern_opacity = input.int(5, 'Range Box Transparency', minval = 0, maxval = 100, group = group_pattern, tooltip = 'üéØ WHAT IT IS: Base transparency for pattern range boxes.\n\n‚ö° VISUAL HIERARCHY:\n‚Ä¢ 0-40: Dominant (patterns are primary)\n‚Ä¢ 50-70: Balanced (equal with price)\n‚Ä¢ 80-100: Background (price is primary)\n\nüí° PRO TIP: 55% creates perfect balance - visible enough to trade but not obscuring price action.')
pattern_field_threshold = input.float(0.35, 'Field Strength Trigger', minval = 0.0, maxval = 1.0, step = 0.01, group = group_pattern, tooltip = 'üéØ WHAT IT IS: Minimum Field Score magnitude required to trigger pattern detection.\n\n‚ö° HOW IT WORKS:\n‚Ä¢ Field Score must exceed ¬±threshold\n‚Ä¢ Higher = fewer but stronger patterns\n‚Ä¢ Lower = more patterns of varying quality\n\nüìà HIGHER VALUES (0.5-1.0):\n‚Ä¢ Only extreme field conditions\n‚Ä¢ Very high quality patterns\n‚Ä¢ Rare but powerful signals\n‚Ä¢ Best for: Conservative trading\n\nüìâ LOWER VALUES (0.1-0.3):\n‚Ä¢ Includes moderate field states\n‚Ä¢ More pattern opportunities\n‚Ä¢ Mix of qualities\n‚Ä¢ Best for: Active trading\n\nüí° PRO TIP: 0.35 captures patterns in meaningfully strong fields while avoiding noise. Increase to 0.5+ for only the strongest setups.')
pattern_max_bars = input.int(150, 'Maximum Pattern Length', minval = 20, maxval = 5000, group = group_pattern, tooltip = 'üéØ WHAT IT IS: Maximum duration before forcing pattern completion.\n\n‚ö° PURPOSE:\n‚Ä¢ Prevents endless patterns\n‚Ä¢ Forces re-evaluation\n‚Ä¢ Maintains performance\n\nüí° PRO TIP: 150 bars is about one month on 4H charts or one week on 1H. Patterns lasting longer need re-evaluation anyway.')
pattern_history = input.int(24, 'Pattern History Limit', minval = 1, maxval = 200, group = group_pattern, tooltip = 'üéØ WHAT IT IS: Maximum number of completed patterns to display.\n\n‚ö° VISUAL MANAGEMENT:\n‚Ä¢ 10-20: Recent patterns only\n‚Ä¢ 30-50: Good historical context\n‚Ä¢ 100+: Full pattern analysis\n\nüí° PRO TIP: 24 patterns provides about one week of pattern history on active instruments without cluttering.')
engulf_body_factor = input.float(0.8, 'Engulfing Body Ratio', minval = 0.3, maxval = 1.5, step = 0.05, group = group_pattern, tooltip = 'üéØ WHAT IT IS: Minimum size ratio for engulfing pattern validation (engulfing body vs previous body).\n\n‚ö° QUALITY CONTROL:\n‚Ä¢ 0.5: Liberal (more patterns)\n‚Ä¢ 0.8: Standard definition\n‚Ä¢ 1.0: Full engulfing required\n‚Ä¢ 1.2: Extra confirmation\n\nüí° PRO TIP: 0.8 follows classical definition while allowing for spreads and micro-gaps.')
pin_wick_ratio = input.float(2.5, 'Pin Bar Wick Ratio', minval = 1.5, maxval = 5, step = 0.1, group = group_pattern, tooltip = 'üéØ WHAT IT IS: Minimum wick-to-body ratio for hammer and shooting star patterns.\n\n‚ö° PATTERN QUALITY:\n‚Ä¢ 2.0: Standard requirement\n‚Ä¢ 2.5: Good quality filter\n‚Ä¢ 3.0+: Only perfect pins\n\nüí° PRO TIP: 2.5 ensures meaningful rejection without being too restrictive.')
doji_body_range_max = input.float(0.12, 'Doji Body Threshold', minval = 0.03, maxval = 0.3, step = 0.01, group = group_pattern, tooltip = 'üéØ WHAT IT IS: Maximum body-to-range ratio to qualify as a doji pattern.\n\n‚ö° DOJI TYPES:\n‚Ä¢ 0.05: Perfect doji only\n‚Ä¢ 0.10: Standard doji\n‚Ä¢ 0.15: Includes spinning tops\n‚Ä¢ 0.20+: Liberal definition\n\nüí° PRO TIP: 0.12 captures true indecision candles without including normal small-body candles.')
group_score = '‚ö° Field Score Fusion Weights'
w_wave = input.float(1.2, 'Wavelet Alignment Weight', minval = 0, maxval = 3, step = 0.1, group = group_score, tooltip = 'üéØ WHAT IT IS: How much wavelet multi-scale alignment contributes to Field Score.\n\n‚ö° WEIGHT IMPACT:\n‚Ä¢ 0: Disabled (no wavelet influence)\n‚Ä¢ 1.0: Standard contribution\n‚Ä¢ 1.2: Slightly emphasized (default)\n‚Ä¢ 2.0+: Dominant factor\n\nüí° PRO TIP: 1.2 gives appropriate emphasis to trend structure. Wavelets are the most reliable component, hence slightly higher weight.')
w_hurst = input.float(1.0, 'Hurst Persistence Weight', minval = 0, maxval = 3, step = 0.1, group = group_score, tooltip = 'üéØ WHAT IT IS: How much Hurst trend persistence contributes to Field Score.\n\n‚ö° COMPONENT VALUE:\n‚Ä¢ Identifies trending vs ranging\n‚Ä¢ Critical for regime detection\n‚Ä¢ Complements wavelets perfectly\n\nüí° PRO TIP: Keep at 1.0 - Hurst provides unique information about market memory that other components miss.')
w_fdi = input.float(0.8, 'Fractal Complexity Weight', minval = 0, maxval = 3, step = 0.1, group = group_score, tooltip = 'üéØ WHAT IT IS: How much fractal dimension (complexity) contributes to Field Score.\n\n‚ö° INFORMATION VALUE:\n‚Ä¢ Detects chaos-to-order transitions\n‚Ä¢ Identifies smooth vs rough paths\n‚Ä¢ Early warning for regime changes\n\nüí° PRO TIP: 0.8 provides good input without overwhelming. Increase in ranging markets where complexity matters more.')
w_ent = input.float(0.8, 'Entropy Uncertainty Weight', minval = 0, maxval = 3, step = 0.1, group = group_score, tooltip = 'üéØ WHAT IT IS: How much Shannon entropy contributes to Field Score (inverted - low entropy is bullish).\n\n‚ö° SIGNAL VALUE:\n‚Ä¢ Low entropy = directional clarity\n‚Ä¢ High entropy = confusion/consolidation\n‚Ä¢ Entropy drops precede breakouts\n\nüí° PRO TIP: 0.8 captures entropy signals without over-weighting. Critical for breakout detection.')
w_te = input.float(0.8, 'Transfer Entropy Weight', minval = 0, maxval = 3, step = 0.1, group = group_score, tooltip = 'üéØ WHAT IT IS: How much causal information flow contributes to Field Score.\n\n‚ö° UNIQUE VALUE:\n‚Ä¢ Only component measuring causality\n‚Ä¢ Reveals what drives price\n‚Ä¢ Leads other indicators\n\nüí° PRO TIP: 0.8 incorporates causality without dominating. Increase when using strong external drivers (VIX, DXY).')
group_signal = 'üìä Signal Generation Engine'
mode_signal = input.string('Elite', 'Signal Mode', options = ['Conservative', 'Balanced', 'Elite', 'Aggressive'], group = group_signal, tooltip = 'üéØ WHAT IT IS: Overall signal generation philosophy and filter stringency.\n\n‚ö° MODE CHARACTERISTICS:\n\nüìä CONSERVATIVE:\n‚Ä¢ Highest quality requirement\n‚Ä¢ 85%+ probability threshold\n‚Ä¢ Fewer signals (1-3 per day)\n‚Ä¢ Best for: Large accounts, beginners\n‚Ä¢ Win rate: Highest\n‚Ä¢ Risk/Reward: Best\n\nüìä BALANCED:\n‚Ä¢ Standard quality filters\n‚Ä¢ 70%+ probability threshold\n‚Ä¢ Moderate signals (3-5 per day)\n‚Ä¢ Best for: Regular trading\n‚Ä¢ Win rate: Good\n‚Ä¢ Risk/Reward: Good\n\nüìä ELITE:\n‚Ä¢ Advanced multi-factor filters\n‚Ä¢ 75%+ probability threshold\n‚Ä¢ Quality over quantity\n‚Ä¢ Best for: Experienced traders\n‚Ä¢ Win rate: Very good\n‚Ä¢ Risk/Reward: Excellent\n\nüìä AGGRESSIVE:\n‚Ä¢ Relaxed filters\n‚Ä¢ 60%+ probability threshold\n‚Ä¢ Many signals (5-10 per day)\n‚Ä¢ Best for: Scalping, high frequency\n‚Ä¢ Win rate: Moderate\n‚Ä¢ Risk/Reward: Variable\n\nüí° PRO TIP: Start with Elite - it uses sophisticated filters that eliminate most false signals while maintaining good opportunity frequency.')
min_confluence = input.int(3, 'Minimum Confluence Score', minval = 1, maxval = 6, group = group_signal, tooltip = 'üéØ WHAT IT IS: How many indicator components must align before triggering a signal.\n\n‚ö° CONFLUENCE FACTORS:\n‚Ä¢ Field Score alignment\n‚Ä¢ Wavelet direction\n‚Ä¢ Hurst trending/ranging\n‚Ä¢ Entropy expansion/contraction\n‚Ä¢ Transfer entropy direction\n‚Ä¢ MTF alignment\n‚Ä¢ MACD confirmation\n‚Ä¢ Pattern quality\n\nüìà HIGHER REQUIREMENTS (4-6):\n‚Ä¢ Very few but high-quality signals\n‚Ä¢ All dimensions must align\n‚Ä¢ Best for position trading\n‚Ä¢ Highest win rate\n\nüìâ LOWER REQUIREMENTS (1-2):\n‚Ä¢ Many signals of varying quality\n‚Ä¢ Early entries possible\n‚Ä¢ More false positives\n‚Ä¢ Requires good management\n\nüí° PRO TIP: 3 is the sweet spot - ensures multiple dimensions confirm without waiting for perfect alignment which rarely occurs.')
field_long_thr = input.float(0.35, 'Long Entry Field Score', minval = 0, maxval = 1, step = 0.01, group = group_signal, tooltip = 'üéØ WHAT IT IS: Minimum Field Score required to consider long entries.\n\n‚ö° FIELD INTERPRETATION:\n‚Ä¢ 0.2: Weak bullish field\n‚Ä¢ 0.35: Moderate bullish field\n‚Ä¢ 0.5: Strong bullish field\n‚Ä¢ 0.7+: Extreme bullish field\n\nüìà HIGHER THRESHOLDS (0.5-1.0):\n‚Ä¢ Only strong trends\n‚Ä¢ Fewer but better entries\n‚Ä¢ Misses early moves\n‚Ä¢ Lower drawdown\n\nüìâ LOWER THRESHOLDS (0.1-0.3):\n‚Ä¢ Catches trend starts\n‚Ä¢ More opportunities\n‚Ä¢ Higher false positive rate\n‚Ä¢ Requires tight stops\n\nüí° PRO TIP: 0.35 identifies meaningful bullish bias without requiring extreme conditions. Increase to 0.5 in ranging markets.')
field_short_thr = input.float(-0.35, 'Short Entry Field Score', minval = -1, maxval = 0, step = 0.01, group = group_signal, tooltip = 'üéØ WHAT IT IS: Maximum Field Score (negative) required for short entries.\n\n‚ö° SYMMETRY NOTE:\n‚Ä¢ Should mirror long threshold\n‚Ä¢ -0.35 matches long 0.35\n‚Ä¢ Maintains system balance\n\nüí° PRO TIP: Keep symmetric with long threshold unless you have specific directional bias (e.g., long-only in bull markets).')
lock_direction = input.bool(true, 'Directional Field Lock', group = group_signal, tooltip = 'üéØ WHAT IT IS: Requires Field Score polarity to match trade direction.\n\n‚ö° WHEN ENABLED:\n‚Ä¢ Longs only when Field Score > 0\n‚Ä¢ Shorts only when Field Score < 0\n‚Ä¢ Prevents counter-trend trades\n‚Ä¢ Improves win rate\n\n‚ö° WHEN DISABLED:\n‚Ä¢ Allows counter-trend setups\n‚Ä¢ More trading opportunities\n‚Ä¢ Requires better timing\n‚Ä¢ Higher risk\n\nüí° PRO TIP: Keep enabled unless you are an experienced counter-trend trader. This single setting prevents most losing trades.')
cooldownBars = input.int(12, 'Signal Cooldown Period', minval = 1, maxval = 200, group = group_signal, tooltip = 'üéØ WHAT IT IS: Minimum bars between signals to prevent overtrading.\n\n‚ö° COOLDOWN BENEFITS:\n‚Ä¢ Prevents signal clustering\n‚Ä¢ Allows trades to develop\n‚Ä¢ Reduces overtrading\n‚Ä¢ Improves risk management\n\nüïí TIMEFRAME GUIDE:\n‚Ä¢ 1-5 min: 5-10 bars\n‚Ä¢ 15-60 min: 10-20 bars\n‚Ä¢ 4H: 12-24 bars\n‚Ä¢ Daily: 5-10 bars\n\nüí° PRO TIP: 12 bars prevents immediate re-entry while allowing new opportunities when conditions truly change.')
risk_atrMultSL = input.float(1.2, 'Stop Loss ATR Multiplier', minval = 0.2, maxval = 5, step = 0.1, group = group_signal, tooltip = 'üéØ WHAT IT IS: Stop loss distance as multiple of Average True Range.\n\n‚ö° RISK PHILOSOPHY:\n‚Ä¢ 0.5-1.0: Tight stops (scalping)\n‚Ä¢ 1.0-1.5: Standard stops\n‚Ä¢ 1.5-2.5: Wide stops (trending)\n‚Ä¢ 2.5+: Position/swing trading\n\nüè¶ MARKET SPECIFIC:\n‚Ä¢ Forex: 0.8-1.2 (stable)\n‚Ä¢ Stocks: 1.2-1.8 (medium)\n‚Ä¢ Crypto: 1.5-2.5 (volatile)\n‚Ä¢ Futures: 1.0-1.5 (leveraged)\n\nüí° PRO TIP: 1.2 ATR accommodates normal volatility without premature stops. Adjust based on market conditions and timeframe.')
risk_t1R = input.float(1.8, 'Target 1 Risk Multiple', minval = 0.5, maxval = 10, step = 0.1, group = group_signal, tooltip = 'üéØ WHAT IT IS: First profit target as multiple of risk (R).\n\n‚ö° TARGET STRATEGY:\n‚Ä¢ 1.0R: Break-even target\n‚Ä¢ 1.5-2.0R: Conservative target\n‚Ä¢ 2.0-3.0R: Standard target\n‚Ä¢ 3.0+R: Aggressive target\n\nüí° PRO TIP: 1.8R allows for 50% position close at decent profit, making remaining position risk-free.')
risk_t2R = input.float(3.0, 'Target 2 Risk Multiple', minval = 0.5, maxval = 20, step = 0.1, group = group_signal, tooltip = 'üéØ WHAT IT IS: Second profit target for runners.\n\n‚ö° POSITION MANAGEMENT:\n‚Ä¢ Close 50% at Target 1\n‚Ä¢ Move stop to break-even\n‚Ä¢ Let remainder run to Target 2\n‚Ä¢ Trail stop after Target 2\n\nüí° PRO TIP: 3.0R captures trending moves. With 50% closed at 1.8R, total return = 2.4R on full position.')
rr_len = input.int(25, 'RR Rails Projection', minval = 10, maxval = 200, group = group_signal, tooltip = 'üéØ WHAT IT IS: How many bars forward to project risk/reward rails.\n\n‚ö° VISUAL PLANNING:\n‚Ä¢ Shows entry, stop, targets\n‚Ä¢ Projects trade timeline\n‚Ä¢ Helps position sizing\n‚Ä¢ Clear trade plan\n\nüí° PRO TIP: 45 bars shows about 2 days on hourly charts - typical trade duration.')
dyn_conf = input.bool(true, 'Dynamic Confluence Adjustment', group = group_signal, tooltip = 'üéØ WHAT IT IS: Automatically adjusts confluence requirements based on market regime.\n\n‚ö° SMART ADAPTATION:\n‚Ä¢ Trending: Requires more confluence\n‚Ä¢ Ranging: Relaxes requirements\n‚Ä¢ Prevents bad trades in chop\n‚Ä¢ Captures trends aggressively\n\nüí° PRO TIP: Essential feature - markets change character and signals should adapt accordingly.')
dyn_trend_factor = input.float(1.20, 'Trending Regime Factor', minval = 0.5, maxval = 1.5, step = 0.05, group = group_signal, tooltip = 'üéØ WHAT IT IS: Confluence multiplier in trending conditions (>1 = stricter).\n\n‚ö° LOGIC: In strong trends, require more confirmation to avoid late entries.\n\nüí° PRO TIP: 1.20 adds 20% more confluence requirement in trends, preventing chase entries.')
dyn_range_factor = input.float(0.85, 'Ranging Regime Factor', minval = 0.5, maxval = 1.5, step = 0.05, group = group_signal, tooltip = 'üéØ WHAT IT IS: Confluence multiplier in ranging conditions (<1 = looser).\n\n‚ö° LOGIC: In ranges, act quickly on reversals with less confirmation needed.\n\nüí° PRO TIP: 0.85 reduces requirements by 15% in ranges, capturing reversals better.')
prefer_best_side = input.bool(true, 'Prefer Stronger Signal', group = group_signal, tooltip = 'üéØ WHAT IT IS: When both long and short signals qualify, take only the stronger one.\n\n‚ö° CONFLICT RESOLUTION:\n‚Ä¢ Compares probability scores\n‚Ä¢ Picks higher confidence side\n‚Ä¢ Prevents conflicting positions\n‚Ä¢ Improves win rate\n\nüí° PRO TIP: Always enable - simultaneous opposing signals usually mean consolidation, better to wait.')
group_vis = 'üé® Visual Display Settings'
show_dashboard2 = input.bool(false, 'Show Analytics Dashboard', group = group_vis, tooltip = 'üéØ WHAT IT IS: Comprehensive real-time analytics panel.\n\n‚ö° DASHBOARD CONTENTS:\n‚Ä¢ Field Score and regime\n‚Ä¢ All component values\n‚Ä¢ Signal probabilities\n‚Ä¢ Pattern detection\n‚Ä¢ Market statistics\n\nüí° PRO TIP: Essential for understanding what the indicator sees. Disable only after mastering the system.')
dash_pos = input.string('Top Right', 'Dashboard Position', options = ['Top Right', 'Top Left', 'Bottom Right', 'Bottom Left'], group = group_vis, tooltip = 'üéØ POSITION SELECTION:\n‚Ä¢ Top Right: Standard, out of the way\n‚Ä¢ Top Left: Near price scale\n‚Ä¢ Bottom Right: Near time axis\n‚Ä¢ Bottom Left: Clean corner\n\nüí° PRO TIP: Top Right keeps price action clear while remaining visible.')
theme = input.string('Dark', 'Color Theme', options = ['Dark', 'Light', 'Neon'], group = group_vis, tooltip = 'üéØ THEME CHARACTERISTICS:\n‚Ä¢ Dark: Easy on eyes, professional\n‚Ä¢ Light: High contrast, printing\n‚Ä¢ Neon: Vibrant, modern, attention-grabbing\n\nüí° PRO TIP: Dark theme reduces eye strain during long sessions.')
plot_signals = input.bool(true, 'Display Signal Markers', group = group_vis, tooltip = 'üéØ WHAT IT IS: Shows entry signals and risk/reward rails.\n\n‚ö° VISUAL ELEMENTS:\n‚Ä¢ Entry arrows with probability\n‚Ä¢ Stop loss line\n‚Ä¢ Target lines\n‚Ä¢ Entry level\n\nüí° PRO TIP: Core feature - shows exact trade setup visually.')
signal_labels = input.bool(true, 'Show Probability Labels', group = group_vis, tooltip = 'üéØ WHAT IT IS: Displays win probability next to signals.\n\n‚ö° HELPS WITH:\n‚Ä¢ Signal quality assessment\n‚Ä¢ Position sizing decisions\n‚Ä¢ Trade selection\n\nüí° PRO TIP: Useful for learning signal quality. Can disable once familiar.')
right_tags = input.bool(true, 'Show RR Level Tags', group = group_vis, tooltip = 'üéØ WHAT IT IS: Labels on the right showing Entry, SL, T1, T2 prices.\n\n‚ö° BENEFITS:\n‚Ä¢ Clear trade levels\n‚Ä¢ Easy order placement\n‚Ä¢ Visual trade plan\n\nüí° PRO TIP: Extremely helpful for order management.')
min_prob_plot = input.int(72, 'Minimum Display Probability', minval = 0, maxval = 100, group = group_vis, tooltip = 'üéØ WHAT IT IS: Hide signals below this probability to reduce noise.\n\n‚ö° FILTER LEVELS:\n‚Ä¢ 60%: Show most signals\n‚Ä¢ 72%: Balanced (default)\n‚Ä¢ 80%: High quality only\n‚Ä¢ 90%: Exceptional only\n\nüí° PRO TIP: 72% filters mediocre setups while showing good opportunities.')
group_sr = 'üìè Dynamic Support/Resistance Engine'
show_sr = input.bool(true, 'Display S/R Levels', group = group_sr, tooltip = 'üéØ WHAT IT IS: Dynamic support/resistance based on recent highs/lows.\n\n‚ö° FEATURES:\n‚Ä¢ Auto-updates with price\n‚Ä¢ Key reversal levels\n‚Ä¢ Stop/target references\n‚Ä¢ Structure visualization\n\nüí° PRO TIP: These levels often align with pattern boxes and wavelet bands, creating confluence zones.')
sr_lookback = input.int(20, 'S/R Lookback Period', minval = 10, maxval = 200, group = group_sr, tooltip = 'üéØ WHAT IT IS: Bars to analyze for support/resistance levels.\n\n‚ö° PERIOD IMPACT:\n‚Ä¢ 10-20: Recent levels (responsive)\n‚Ä¢ 30-50: Medium-term structure\n‚Ä¢ 100+: Major levels only\n\nüïí TIMEFRAME GUIDE:\n‚Ä¢ Scalping: 10-15 bars\n‚Ä¢ Day Trading: 20-30 bars\n‚Ä¢ Swing Trading: 50-100 bars\n\nüí° PRO TIP: 20 bars captures immediate market structure without cluttering with old levels.')
//==============================================================================
// CORE ENGINE
//==============================================================================
cBull = color.new(#00C853, 0)
cBear = color.new(#FF1744, 0)
cNeut = color.new(#FFC107, 0)
cInfo = color.new(#00ACC1, 0)
cWave2 = color.new(#7E57C2, 12)
cWave3 = color.new(#26A69A, 12)
cWave4 = color.new(#EF6C00, 12)
cGray = color.new(#9E9E9E, 0)
cGold = color.new(#FFD700, 0)
cPurple = color.new(#9C27B0, 0)
cOrange = color.new(#FF6F00, 0)
cCyan = color.new(#00BCD4, 0)
cMagenta = color.new(#E91E63, 0)
cBlue = color.new(#2962FF, 0)
cPanelBg = theme == 'Dark' ? color.new(#101214, 10) : theme == 'Light' ? color.new(#F5F7FB, 0) : color.new(#05122B, 10)
cText = theme == 'Light' ? color.black : color.white
clamp(v, lo, hi) =>
    math.min(hi, math.max(lo, v))
sgn(x) =>
    x > 0 ? 1 : x < 0 ? -1 : 0
safe_log(x) =>
    math.log(math.max(x, 1e-12))
smoothstep(lo, hi, x) =>
    t = clamp((x - lo) / math.max(hi - lo, 1e-9), 0.0, 1.0)
    t * t * (3.0 - 2.0 * t)
var float TICK = na
if barstate.isfirst
    TICK := syminfo.mintick
    TICK
prune_old_boxes(arr, ageBars) =>
    sz = array.size(arr)
    if sz > 0
        i = sz - 1
        while i >= 0
            b = array.get(arr, i)
            if not na(b)
                xr = box.get_right(b)
                if not na(xr) and bar_index - xr > ageBars
                    box.delete(b)
                    array.remove(arr, i)
            i := i - 1
            i
cap_boxes(arr, maxN) =>
    while array.size(arr) > maxN
        box.delete(array.shift(arr))
        //==============================================================================
        // PATTERN HELPERS
        //==============================================================================
pattern_box_top_bottom(style, hi, lo, o, c) =>
    switch style
        'Body' => [math.max(o, c) + syminfo.mintick * 2, math.min(o, c) - syminfo.mintick * 2]
        'Wick' => [hi + syminfo.mintick * 3, lo - syminfo.mintick * 3]
        'Full' => [hi + syminfo.mintick * 4, lo - syminfo.mintick * 4]
        => [hi + syminfo.mintick * 2, lo - syminfo.mintick * 2]
P_NONE = 0
P_BULL_ENG = 1
P_BEAR_ENG = 2
P_INSIDE = 3
P_OUTSIDE = 4
P_HAMMER = 5
P_SHOOTING = 6
P_DOJI = 7
pattern_color_for_type(p) =>
    switch p
        P_BULL_ENG => cBull
        P_BEAR_ENG => cBear
        P_INSIDE => cInfo
        P_OUTSIDE => cOrange
        P_HAMMER => cCyan
        P_SHOOTING => cMagenta
        P_DOJI => cGray
        => color.gray
pattern_name(p) =>
    switch p
        P_BULL_ENG => 'Bull Engulf'
        P_BEAR_ENG => 'Bear Engulf'
        P_INSIDE => 'Inside'
        P_OUTSIDE => 'Outside'
        P_HAMMER => 'Hammer'
        P_SHOOTING => 'Shooting'
        P_DOJI => 'Doji'
        => 'None'
bar_pattern_type() =>
    if bar_index == 0
        P_NONE
    else
        rng = high - low
        body = math.abs(close - open)
        prevBody = math.abs(close[1] - open[1])
        upperW = high - math.max(open, close)
        lowerW = math.min(open, close) - low
        isDoji = rng > 0 and body / rng <= doji_body_range_max
        isInside = high < high[1] and low > low[1]
        isOutside = high > high[1] and low < low[1]
        bullEng = close > open and prevBody > 0 and close >= math.max(open[1], close[1]) and open <= math.min(open[1], close[1]) and body >= prevBody * engulf_body_factor
        bearEng = close < open and prevBody > 0 and close <= math.min(open[1], close[1]) and open >= math.max(open[1], close[1]) and body >= prevBody * engulf_body_factor
        isHammer = rng > 0 and lowerW / math.max(body, 1e-6) >= pin_wick_ratio and upperW <= body * 0.7
        isShooting = rng > 0 and upperW / math.max(body, 1e-6) >= pin_wick_ratio and lowerW <= body * 0.7
        bullEng ? P_BULL_ENG : bearEng ? P_BEAR_ENG : isInside ? P_INSIDE : isOutside ? P_OUTSIDE : isHammer ? P_HAMMER : isShooting ? P_SHOOTING : isDoji ? P_DOJI : P_NONE
dominant_type_from_counts(cntBullEng, cntBearEng, cntInside, cntOutside, cntHammer, cntShooting, cntDoji, fallbackBull) =>
    maxCnt = 0
    dom = P_NONE
    if cntBullEng > maxCnt
        maxCnt := cntBullEng
        dom := P_BULL_ENG
        dom
    if cntBearEng > maxCnt
        maxCnt := cntBearEng
        dom := P_BEAR_ENG
        dom
    if cntInside > maxCnt
        maxCnt := cntInside
        dom := P_INSIDE
        dom
    if cntOutside > maxCnt
        maxCnt := cntOutside
        dom := P_OUTSIDE
        dom
    if cntHammer > maxCnt
        maxCnt := cntHammer
        dom := P_HAMMER
        dom
    if cntShooting > maxCnt
        maxCnt := cntShooting
        dom := P_SHOOTING
        dom
    if cntDoji > maxCnt
        maxCnt := cntDoji
        dom := P_DOJI
        dom
    dom == P_NONE ? fallbackBull ? P_BULL_ENG : P_BEAR_ENG : dom
    //==============================================================================
    // DATA SOURCES
    //==============================================================================
te_tf = te_tf_in == '' ? timeframe.period : te_tf_in
ext_close = request.security(te_symbol, te_tf, close, barmerge.gaps_off, barmerge.lookahead_off)
ref_close1 = request.security(syminfo.tickerid, ref_tf1, close, barmerge.gaps_off, barmerge.lookahead_off)
ref_close2 = request.security(syminfo.tickerid, ref_tf2, close, barmerge.gaps_off, barmerge.lookahead_off)
volSMA20 = ta.sma(volume, 20)
atr14 = ta.atr(14)
rsi14 = ta.rsi(close, 14)
ema20 = ta.ema(close, 20)
vwapValue = ta.vwap(hlc3)
[macdLine, signalLine, _] = ta.macd(close, 12, 26, 9)
//==============================================================================
// WAVELET TRANSFORM
//==============================================================================
wavelet_pair(src, step, kernel) =>
    float a = na
    float d = na
    if kernel == 'Haar'
        float h0 = 0.70710678
        h1 = 0.70710678
        float g0 = -0.70710678
        g1 = 0.70710678
        a := h0 * nz(src) + h1 * nz(src[step])
        d := g0 * nz(src) + g1 * nz(src[step])
        d
    else
        float h0 = 0.4829629131
        h1 = 0.8365163037
        h2 = 0.2241438680
        h3 = -0.1294095226
        float g0 = -0.1294095226
        g1 = -0.2241438680
        g2 = 0.8365163037
        g3 = -0.4829629131
        a := h0 * nz(src) + h1 * nz(src[step]) + h2 * nz(src[2 * step]) + h3 * nz(src[3 * step])
        d := g0 * nz(src) + g1 * nz(src[step]) + g2 * nz(src[2 * step]) + g3 * nz(src[3 * step])
        d
    [a, d]
var float a1 = 0.0
d1 = 0.0
var float a2 = 0.0
d2 = 0.0
var float a3 = 0.0
d3 = 0.0
var float a4 = 0.0
d4 = 0.0
[a1t, d1t] = wavelet_pair(close, 1, wl_kernel)
a1 := a1t
d1 := d1t
if wl_levels >= 2
    [a2t, d2t] = wavelet_pair(a1, 2, wl_kernel)
    a2 := a2t
    d2 := d2t
    d2
if wl_levels >= 3
    [a3t, d3t] = wavelet_pair(a2, 4, wl_kernel)
    a3 := a3t
    d3 := d3t
    d3
if wl_levels >= 4
    [a4t, d4t] = wavelet_pair(a3, 8, wl_kernel)
    a4 := a4t
    d4 := d4t
    d4
atrN = ta.atr(14)
s2n = wl_levels >= 2 ? (a2 - a2[1]) / nz(atrN, 1) : na
s3n = wl_levels >= 3 ? (a3 - a3[1]) / nz(atrN, 1) : na
s4n = wl_levels >= 4 ? (a4 - a4[1]) / nz(atrN, 1) : na
w2 = wl_levels >= 2 ? 2.0 : 0.0
w3 = wl_levels >= 3 ? 4.0 : 0.0
w4 = wl_levels >= 4 ? 8.0 : 0.0
sumW = w2 + w3 + w4
wave_align = sumW > 0 ? clamp((w2 * sgn(nz(s2n)) + w3 * sgn(nz(s3n)) + w4 * sgn(nz(s4n))) / sumW, -1.0, 1.0) : 0.0
//==============================================================================
// HURST EXPONENT
//==============================================================================
hurst_est_pow2(src, win) =>
    float m1 = ta.sma(math.abs(src - src[1]), win)
    float m2 = ta.sma(math.abs(src - src[2]), win)
    float m4 = ta.sma(math.abs(src - src[4]), win)
    float m8 = ta.sma(math.abs(src - src[8]), win)
    float m16 = ta.sma(math.abs(src - src[16]), win)
    float m32 = ta.sma(math.abs(src - src[32]), win)
    float sx = 0.0
    sy = 0.0
    sxx = 0.0
    sxy = 0.0
    int cnt = 0
    eps = 1e-12
    if not na(m1) and m1 > eps and bar_index > win + 1 + 5
        x = math.log(1.0)
        y = math.log(m1)
        sx := sx + x
        sy := sy + y
        sxx := sxx + x * x
        sxy := sxy + x * y
        cnt := cnt + 1
        cnt
    if not na(m2) and m2 > eps and bar_index > win + 2 + 5
        x = math.log(2.0)
        y = math.log(m2)
        sx := sx + x
        sy := sy + y
        sxx := sxx + x * x
        sxy := sxy + x * y
        cnt := cnt + 1
        cnt
    if not na(m4) and m4 > eps and bar_index > win + 4 + 5
        x = math.log(4.0)
        y = math.log(m4)
        sx := sx + x
        sy := sy + y
        sxx := sxx + x * x
        sxy := sxy + x * y
        cnt := cnt + 1
        cnt
    if not na(m8) and m8 > eps and bar_index > win + 8 + 5
        x = math.log(8.0)
        y = math.log(m8)
        sx := sx + x
        sy := sy + y
        sxx := sxx + x * x
        sxy := sxy + x * y
        cnt := cnt + 1
        cnt
    if not na(m16) and m16 > eps and bar_index > win + 16 + 5
        x = math.log(16.0)
        y = math.log(m16)
        sx := sx + x
        sy := sy + y
        sxx := sxx + x * x
        sxy := sxy + x * y
        cnt := cnt + 1
        cnt
    if not na(m32) and m32 > eps and bar_index > win + 32 + 5
        x = math.log(32.0)
        y = math.log(m32)
        sx := sx + x
        sy := sy + y
        sxx := sxx + x * x
        sxy := sxy + x * y
        cnt := cnt + 1
        cnt
    den = cnt * sxx - sx * sx
    slope = cnt >= 2 and math.abs(den) > eps ? (cnt * sxy - sx * sy) / den : na
    clamp(nz(slope, 0.5), 0.0, 1.0)
H2 = wl_levels >= 2 ? hurst_est_pow2(a2, hurst_window) : na
H3 = wl_levels >= 3 ? hurst_est_pow2(a3, hurst_window) : na
H4 = wl_levels >= 4 ? hurst_est_pow2(a4, hurst_window) : na
sumHw = 0.0
wH = 0.0
if not na(H2)
    sumHw := sumHw + 2.0
    wH := wH + 2.0 * H2
    wH
if not na(H3)
    sumHw := sumHw + 4.0
    wH := wH + 4.0 * H3
    wH
if not na(H4)
    sumHw := sumHw + 8.0
    wH := wH + 8.0 * H4
    wH
H_weighted = sumHw > 0 ? wH / sumHw : na
H_score = na(H_weighted) ? 0.0 : clamp((H_weighted - 0.5) / 0.15, -1.0, 1.0)
//==============================================================================
// FRACTAL DIMENSION
//==============================================================================
fdi_frama(len) =>
    n = len
    n2 = math.floor(n / 2)
    hh1 = ta.highest(high[n2], n2)
    ll1 = ta.lowest(low[n2], n2)
    hh2 = ta.highest(high, n2)
    ll2 = ta.lowest(low, n2)
    hh = ta.highest(high, n)
    ll = ta.lowest(low, n)
    N1 = (hh1 - ll1) / n2
    N2 = (hh2 - ll2) / n2
    N3 = (hh - ll) / n
    d = (safe_log(N1 + N2) - safe_log(N3)) / safe_log(2)
    clamp(1 + d, 1.0, 2.0)
FDI = fdi_frama(fdi_len)
FDI_score = clamp(1.0 - 2.0 * smoothstep(1.35, 1.75, FDI), -1.0, 1.0)
//==============================================================================
// SHANNON ENTROPY
//==============================================================================
atrN_forEnt = ta.atr(ent_atrLen)
ret_norm = ent_normATR ? (close - close[1]) / nz(atrN_forEnt, 1) : (close - close[1]) / nz(close[1], 1)
bin_index(v, bins) =>
    vv = clamp(v, -3.0, 3.0)
    idx = int(math.floor((vv + 3.0) / 6.0 * bins))
    clamp(idx, 0, bins - 1)
var array<float> ent_counts = na
var array<int> ent_queue = na
var int ent_qi = 0
var int ent_last_win = na
var int ent_last_bins = na
var float ent_total = 0.0
if barstate.isfirst or ent_last_win != ent_window or ent_last_bins != ent_bins
    ent_counts := array.new_float(ent_bins, 0.0)
    ent_queue := array.new_int(ent_window, -1)
    ent_qi := 0
    ent_total := 0.0
    ent_last_win := ent_window
    ent_last_bins := ent_bins
    ent_last_bins
curEntBin = bin_index(ret_norm, ent_bins)
old = array.get(ent_queue, ent_qi)
if old >= 0
    array.set(ent_counts, old, array.get(ent_counts, old) - 1.0)
    ent_total := ent_total - 1.0
    ent_total
array.set(ent_queue, ent_qi, curEntBin)
array.set(ent_counts, curEntBin, array.get(ent_counts, curEntBin) + 1.0)
ent_total := ent_total + 1.0
ent_qi := (ent_qi + 1) % ent_window
entropy_calc() =>
    if ent_total < ent_bins
        na
    else
        H = 0.0
        for k = 0 to ent_bins - 1 by 1
            p = array.get(ent_counts, k) / ent_total
            H := H + (p > 0 ? -p * math.log(p) : 0)
            H
        H / math.log(ent_bins)
EntropyN = entropy_calc()
entMean = ta.sma(EntropyN, ent_zLen)
entStd = ta.stdev(EntropyN, ent_zLen)
entZ = (EntropyN - entMean) / nz(entStd, 1)
tanh_approx = entZ / (1 + math.abs(entZ))
Ent_score = clamp(-tanh_approx, -1.0, 1.0)
//==============================================================================
// TRANSFER ENTROPY
//==============================================================================
var float drv_OBV = 0.0
drv_OBV := nz(drv_OBV[1]) + (close > close[1] ? volume : close < close[1] ? -volume : 0.0)
drv_VOL = volume
drv_VWAP = ta.vwap(hlc3)
drv_raw = te_driver == 'OBV' ? drv_OBV : te_driver == 'Volume' ? drv_VOL : te_driver == 'VWAP' ? drv_VWAP : ext_close
norm_ret(src) =>
    (src - src[1]) / nz(atrN, 1)
state3(x, thr) =>
    x > thr ? 2 : x < -thr ? 0 : 1
drv_ret = norm_ret(drv_raw)
px_ret = norm_ret(close)
y_state = state3(px_ret, te_thresh)
x_state = state3(drv_ret, te_thresh)
transfer_entropy(y_state_series, x_state_series, win) =>
    int K = 3
    int N = math.min(win, bar_index - 2)
    if N < 50
        na
    else
        array<float> c3 = array.new_float(K * K * K, 0.0)
        array<float> cY1Y0 = array.new_float(K * K, 0.0)
        array<float> cY0X0 = array.new_float(K * K, 0.0)
        array<float> cY0 = array.new_float(K, 0.0)
        for i = 0 to N - 1 by 1
            sy1 = y_state_series[i]
            sy0 = y_state_series[i + 1]
            sx0 = x_state_series[i + 1]
            array.set(c3, sy1 * 9 + sy0 * 3 + sx0, array.get(c3, sy1 * 9 + sy0 * 3 + sx0) + 1.0)
            array.set(cY1Y0, sy1 * 3 + sy0, array.get(cY1Y0, sy1 * 3 + sy0) + 1.0)
            array.set(cY0X0, sy0 * 3 + sx0, array.get(cY0X0, sy0 * 3 + sx0) + 1.0)
            array.set(cY0, sy0, array.get(cY0, sy0) + 1.0)
        NN = N * 1.0
        TE = 0.0
        for sy1 = 0 to K - 1 by 1
            for sy0 = 0 to K - 1 by 1
                for sx0 = 0 to K - 1 by 1
                    p_y1y0x0 = array.get(c3, sy1 * 9 + sy0 * 3 + sx0) / NN
                    if p_y1y0x0 > 0
                        p_y1y0 = array.get(cY1Y0, sy1 * 3 + sy0) / NN
                        p_y0x0 = array.get(cY0X0, sy0 * 3 + sx0) / NN
                        p_y0 = array.get(cY0, sy0) / NN
                        num = p_y1y0x0 * p_y0
                        den = (p_y1y0 > 0 ? p_y1y0 : 1e-12) * (p_y0x0 > 0 ? p_y0x0 : 1e-12)
                        TE := TE + p_y1y0x0 * safe_log(num / den)
                        TE
        clamp(TE / math.log(K), 0.0, 1.0)
corr = ta.correlation(drv_raw, close, corr_len)
var float TE_sc_last = 0.0
calcTE = bar_index % te_step == 0 or barstate.isfirst
TE_x2y_tmp = transfer_entropy(y_state, x_state, te_window)
TE_y2x_tmp = transfer_entropy(x_state, y_state, te_window)
var float TE_x2y = na
var float TE_y2x = na
var float TE_net0 = 0.0
if calcTE
    TE_x2y := TE_x2y_tmp
    TE_y2x := TE_y2x_tmp
    TE_net0 := na(TE_x2y) or na(TE_y2x) ? 0.0 : clamp(TE_x2y - TE_y2x, -1.0, 1.0)
    TE_sc_raw = math.abs(TE_net0) >= te_sigMin ? TE_net0 : 0.0
    TE_sc_last := clamp(TE_sc_raw + corr_w * clamp(corr, -1.0, 1.0), -1.0, 1.0)
    TE_sc_last
TE_sc = TE_sc_last
//==============================================================================
// MTF CONTEXT
//==============================================================================
slope_norm(src, len) =>
    lr = ta.linreg(src, len, 0)
    (lr - lr[1]) / nz(ta.atr(14), 1)
mtf1_align = slope_norm(ref_close1, 55)
mtf2_align = slope_norm(ref_close2, 55)
mtf_align_score = clamp((sgn(mtf1_align) + sgn(mtf2_align)) / 2.0, -1.0, 1.0)
//==============================================================================
// FIELD SCORE FUSION
//==============================================================================
weight_sum = w_wave + w_hurst + w_fdi + w_ent + w_te + (use_mtf_ctx ? w_mtf : 0)
FieldScore = weight_sum > 0 ? clamp((w_wave * wave_align + w_hurst * H_score + w_fdi * FDI_score + w_ent * Ent_score + w_te * TE_sc + (use_mtf_ctx ? w_mtf * mtf_align_score : 0)) / weight_sum, -1.0, 1.0) : 0
regime = FieldScore >= 0.55 ? 'Uptrend Field' : FieldScore <= -0.55 ? 'Downtrend Field' : 'Transitional'
//==============================================================================
// PATTERN FIELD DETECTION
//==============================================================================
var array<box> pattern_boxes = array.new_box()
var array<label> pattern_labels = array.new_label()
var box pattern_range_live = na
var box pattern_glow_live = na
var array<box> pattern_layers_live = array.new_box()
var line pattern_spine_mid = na
var line pattern_spine_u = na
var line pattern_spine_l = na
var label pattern_tag_live = na
var array<box> pattern_bar_boxes = array.new_box()
var array<label> pattern_bar_badges = array.new_label()
var int pattern_start = na
var float pattern_high = na
var float pattern_low = na
var int pattern_length = 0
var bool pattern_active = false
var float last_pattern_score = 0.0
var int cntBullEng = 0
cntBearEng = 0
cntInside = 0
cntOutside = 0
cntHammer = 0
cntShooting = 0
cntDoji = 0
var string apex_pat_name = 'None'
var float apex_pat_conf = 0.0
pattern_enabled = show_patterns
barPat = pattern_enabled ? bar_pattern_type() : P_NONE
pattern_trigger = false
var float prev_field_score = 0.0
var int bars_since_last_pattern = 0
bars_since_last_pattern := bars_since_last_pattern + 1
pattern_adaptive_color = true
pattern_glow = true
if pattern_enabled and bars_since_last_pattern > 8
    field_strength = math.abs(FieldScore)
    field_momentum = math.abs(FieldScore - prev_field_score)
    strong_field = field_strength >= pattern_field_threshold
    good_momentum = field_momentum > 0.08
    pattern_confluence = barPat != P_NONE or math.abs(wave_align) > 0.2
    pattern_trigger := strong_field and (good_momentum or pattern_confluence)
    pattern_trigger
prev_field_score := FieldScore
if show_bar_boxes and pattern_enabled and barPat != P_NONE and bar_index > 0
    col = pattern_color_for_type(barPat)
    fillTrans = 100 - bar_box_opacity
    borderTrans = math.max(0, fillTrans - 20)
    [bTop, bBot] = pattern_box_top_bottom(bar_box_style, high, low, open, close)
    x1 = bar_index - 1
    x2 = bar_index
    bb = box.new(x1, bTop, x2, bBot, bgcolor = color.new(col, fillTrans), border_color = color.new(col, borderTrans), border_width = 1)
    array.push(pattern_bar_boxes, bb)
    badgeText = barPat == P_BULL_ENG ? 'BE' : barPat == P_BEAR_ENG ? 'SE' : barPat == P_INSIDE ? 'IN' : barPat == P_OUTSIDE ? 'OUT' : barPat == P_HAMMER ? 'H' : barPat == P_SHOOTING ? 'SS' : 'D'
    badgeY = (bTop + bBot) / 2
    badge = label.new(x2, badgeY, badgeText, color = color.new(color.black, 100), textcolor = col, style = label.style_label_left, size = size.tiny)
    array.push(pattern_bar_badges, badge)
    while array.size(pattern_bar_boxes) > bar_box_history
        box.delete(array.shift(pattern_bar_boxes))
    while array.size(pattern_bar_badges) > bar_box_history
        label.delete(array.shift(pattern_bar_badges))
if pattern_trigger
    if not pattern_active
        pattern_active := true
        pattern_start := bar_index
        pattern_high := high
        pattern_low := low
        pattern_length := 0
        last_pattern_score := FieldScore
        bars_since_last_pattern := 0
        bars_since_last_pattern
    pattern_length := pattern_length + 1
    pattern_high := math.max(pattern_high, high)
    pattern_low := math.min(pattern_low, low)
    last_pattern_score := FieldScore
    if barPat != P_NONE
        cntBullEng := cntBullEng + (barPat == P_BULL_ENG ? 1 : 0)
        cntBearEng := cntBearEng + (barPat == P_BEAR_ENG ? 1 : 0)
        cntInside := cntInside + (barPat == P_INSIDE ? 1 : 0)
        cntOutside := cntOutside + (barPat == P_OUTSIDE ? 1 : 0)
        cntHammer := cntHammer + (barPat == P_HAMMER ? 1 : 0)
        cntShooting := cntShooting + (barPat == P_SHOOTING ? 1 : 0)
        cntDoji := cntDoji + (barPat == P_DOJI ? 1 : 0)
        cntDoji
    domType = dominant_type_from_counts(cntBullEng, cntBearEng, cntInside, cntOutside, cntHammer, cntShooting, cntDoji, last_pattern_score >= 0)
    domColor = pattern_color_for_type(domType)
    totalCnt = cntBullEng + cntBearEng + cntInside + cntOutside + cntHammer + cntShooting + cntDoji
    domCnt = domType == P_BULL_ENG ? cntBullEng : domType == P_BEAR_ENG ? cntBearEng : domType == P_INSIDE ? cntInside : domType == P_OUTSIDE ? cntOutside : domType == P_HAMMER ? cntHammer : domType == P_SHOOTING ? cntShooting : cntDoji
    structureConf = totalCnt > 0 ? domCnt / totalCnt : 0.0
    strengthConf = clamp(math.abs(last_pattern_score), 0.0, 1.0)
    apex_pat_conf := clamp(100.0 * (0.6 * strengthConf + 0.4 * structureConf), 0, 99)
    apex_pat_name := pattern_name(domType)
    if show_range_box
        base_trans = 100 - pattern_opacity
        live_trans = pattern_adaptive_color ? math.max(20, base_trans - int(math.abs(last_pattern_score) * 40)) : base_trans
        styleForRange = pattern_style == 'Minimal' ? 'Body' : pattern_style == 'Dynamic' ? 'Full' : pattern_style
        [rTop, rBot] = pattern_box_top_bottom(styleForRange, pattern_high, pattern_low, open, close)
        if na(pattern_range_live)
            pattern_range_live := box.new(pattern_start, rTop, bar_index, rBot, bgcolor = color.new(domColor, live_trans), border_color = domColor, border_width = 1)
            pattern_range_live
        else
            box.set_left(pattern_range_live, pattern_start)
            box.set_right(pattern_range_live, bar_index)
            box.set_top(pattern_range_live, rTop)
            box.set_bottom(pattern_range_live, rBot)
            box.set_bgcolor(pattern_range_live, color.new(domColor, live_trans))
            box.set_border_color(pattern_range_live, domColor)
        if pattern_glow and math.abs(last_pattern_score) > 0.45
            gTrans = math.min(98, live_trans + 28)
            if na(pattern_glow_live)
                pattern_glow_live := box.new(pattern_start - 1, rTop * 1.001, bar_index + 1, rBot * 0.999, bgcolor = color.new(domColor, gTrans), border_color = color.new(domColor, 75), border_width = 2)
                pattern_glow_live
            else
                box.set_left(pattern_glow_live, pattern_start - 1)
                box.set_right(pattern_glow_live, bar_index + 1)
                box.set_top(pattern_glow_live, rTop * 1.001)
                box.set_bottom(pattern_glow_live, rBot * 0.999)
                box.set_bgcolor(pattern_glow_live, color.new(domColor, gTrans))
                box.set_border_color(pattern_glow_live, color.new(domColor, 75))
        else
            if not na(pattern_glow_live)
                box.delete(pattern_glow_live)
                pattern_glow_live := na
                pattern_glow_live
        if array.size(pattern_layers_live) == 0
            for layer = 1 to 5 by 1
                inset = 0.0002 * layer
                lt = rTop * (1 + inset)
                lb = rBot * (1 - inset)
                layerBox = box.new(pattern_start, lt, bar_index, lb, bgcolor = color.new(domColor, math.min(95, live_trans + 5 * layer)), border_color = na, border_width = 0)
                array.push(pattern_layers_live, layerBox)
        else
            for i = 0 to array.size(pattern_layers_live) - 1 by 1
                inset = 0.0002 * (i + 1)
                lt = rTop * (1 + inset)
                lb = rBot * (1 - inset)
                bx = array.get(pattern_layers_live, i)
                box.set_left(bx, pattern_start)
                box.set_right(bx, bar_index)
                box.set_top(bx, lt)
                box.set_bottom(bx, lb)
                box.set_bgcolor(bx, color.new(domColor, math.min(95, live_trans + 5 * (i + 1))))
        mid = (rTop + rBot) / 2
        u = rTop - (rTop - mid) * 0.5
        l = rBot + (mid - rBot) * 0.5
        if na(pattern_spine_mid)
            pattern_spine_mid := line.new(pattern_start, mid, bar_index, mid, color = color.new(domColor, 30), width = 2, style = line.style_dotted)
            pattern_spine_u := line.new(pattern_start, u, bar_index, u, color = color.new(domColor, 45), width = 1, style = line.style_dashed)
            pattern_spine_l := line.new(pattern_start, l, bar_index, l, color = color.new(domColor, 45), width = 1, style = line.style_dashed)
            pattern_spine_l
        else
            line.set_xy1(pattern_spine_mid, pattern_start, mid)
            line.set_xy2(pattern_spine_mid, bar_index, mid)
            line.set_xy1(pattern_spine_u, pattern_start, u)
            line.set_xy2(pattern_spine_u, bar_index, u)
            line.set_xy1(pattern_spine_l, pattern_start, l)
            line.set_xy2(pattern_spine_l, bar_index, l)
        tagTxt = apex_pat_name + '  ' + str.tostring(int(apex_pat_conf)) + '%'
        if na(pattern_tag_live)
            pattern_tag_live := label.new(bar_index, rTop, tagTxt, style = label.style_label_left, color = color.new(color.black, 100), textcolor = domColor, size = size.tiny)
            pattern_tag_live
        else
            label.set_x(pattern_tag_live, bar_index)
            label.set_y(pattern_tag_live, rTop)
            label.set_text(pattern_tag_live, tagTxt)
            label.set_textcolor(pattern_tag_live, domColor)
else if pattern_active
    field_weakening = math.abs(FieldScore) < math.abs(last_pattern_score) * 0.4
    pattern_reversal = last_pattern_score > 0 and FieldScore < -0.3 or last_pattern_score < 0 and FieldScore > 0.3
    pattern_should_end = field_weakening or pattern_reversal
    if pattern_should_end
        keep_pattern = pattern_length >= pattern_min_bars
        if keep_pattern
            if show_range_box and not na(pattern_range_live)
                array.push(pattern_boxes, pattern_range_live)
                finalTxt = '‚ñà ' + apex_pat_name + ' (' + str.tostring(pattern_length) + 'b) ‚Ä¢ ' + str.tostring(int(apex_pat_conf)) + '%'
                lbl = label.new(box.get_right(pattern_range_live), box.get_top(pattern_range_live), finalTxt, style = label.style_label_left, color = color.new(color.black, 100), textcolor = pattern_color_for_type(dominant_type_from_counts(cntBullEng, cntBearEng, cntInside, cntOutside, cntHammer, cntShooting, cntDoji, last_pattern_score >= 0)), size = size.tiny)
                array.push(pattern_labels, lbl)
                while array.size(pattern_boxes) > pattern_history
                    box.delete(array.shift(pattern_boxes))
                while array.size(pattern_labels) > pattern_history
                    label.delete(array.shift(pattern_labels))
                pattern_range_live := na
                pattern_range_live
        else
            if not na(pattern_range_live)
                box.delete(pattern_range_live)
                pattern_range_live := na
                pattern_range_live
        if not na(pattern_glow_live)
            box.delete(pattern_glow_live)
            pattern_glow_live := na
            pattern_glow_live
        if array.size(pattern_layers_live) > 0
            for ii = 0 to array.size(pattern_layers_live) - 1 by 1
                box.delete(array.get(pattern_layers_live, ii))
            array.clear(pattern_layers_live)
        if not na(pattern_spine_mid)
            line.delete(pattern_spine_mid)
            pattern_spine_mid := na
            pattern_spine_mid
        if not na(pattern_spine_u)
            line.delete(pattern_spine_u)
            pattern_spine_u := na
            pattern_spine_u
        if not na(pattern_spine_l)
            line.delete(pattern_spine_l)
            pattern_spine_l := na
            pattern_spine_l
        if not na(pattern_tag_live)
            label.delete(pattern_tag_live)
            pattern_tag_live := na
            pattern_tag_live
        pattern_active := false
        pattern_length := 0
        pattern_start := na
        pattern_high := na
        pattern_low := na
        last_pattern_score := 0.0
        cntBullEng := 0
        cntBearEng := 0
        cntInside := 0
        cntOutside := 0
        cntHammer := 0
        cntShooting := 0
        cntDoji := 0
        apex_pat_name := 'None'
        apex_pat_conf := 0.0
        apex_pat_conf
if pattern_active and pattern_length > pattern_max_bars
    if show_range_box and not na(pattern_range_live)
        array.push(pattern_boxes, pattern_range_live)
        while array.size(pattern_boxes) > pattern_history
            box.delete(array.shift(pattern_boxes))
        pattern_range_live := na
        pattern_range_live
    if not na(pattern_glow_live)
        box.delete(pattern_glow_live)
        pattern_glow_live := na
        pattern_glow_live
    if array.size(pattern_layers_live) > 0
        for ii = 0 to array.size(pattern_layers_live) - 1 by 1
            box.delete(array.get(pattern_layers_live, ii))
        array.clear(pattern_layers_live)
    if not na(pattern_spine_mid)
        line.delete(pattern_spine_mid)
        pattern_spine_mid := na
        pattern_spine_mid
    if not na(pattern_spine_u)
        line.delete(pattern_spine_u)
        pattern_spine_u := na
        pattern_spine_u
    if not na(pattern_spine_l)
        line.delete(pattern_spine_l)
        pattern_spine_l := na
        pattern_spine_l
    if not na(pattern_tag_live)
        label.delete(pattern_tag_live)
        pattern_tag_live := na
        pattern_tag_live
    pattern_active := false
    pattern_length := 0
    pattern_start := na
    pattern_high := na
    pattern_low := na
    last_pattern_score := 0.0
    cntBullEng := 0
    cntBearEng := 0
    cntInside := 0
    cntOutside := 0
    cntHammer := 0
    cntShooting := 0
    cntDoji := 0
    apex_pat_name := 'None'
    apex_pat_conf := 0.0
    apex_pat_conf
    //==============================================================================
    // SUPPORT/RESISTANCE LEVELS
    //==============================================================================
var line sr_res_line = na
var line sr_sup_line = na
var label sr_res_label = na
var label sr_sup_label = na
if show_sr
    bsl = ta.highest(high, sr_lookback)
    ssl = ta.lowest(low, sr_lookback)
    xLeft = bar_index
    xRight = bar_index + rr_len
    if na(sr_res_line)
        sr_res_line := line.new(xLeft, bsl, xRight, bsl, extend = extend.none, color = color.red, width = 2)
        sr_res_label := label.new(xLeft, bsl, 'Resistance', style = label.style_label_right, textcolor = color.red, color = color.new(color.black, 100), size = size.small)
        sr_res_label
    else
        line.set_xy1(sr_res_line, xLeft, bsl)
        line.set_xy2(sr_res_line, xRight, bsl)
        line.set_color(sr_res_line, color.red)
        label.set_x(sr_res_label, xLeft)
        label.set_y(sr_res_label, bsl)
        label.set_text(sr_res_label, 'Resistance')
        label.set_textcolor(sr_res_label, color.red)
    if na(sr_sup_line)
        sr_sup_line := line.new(xLeft, ssl, xRight, ssl, extend = extend.none, color = color.blue, width = 2)
        sr_sup_label := label.new(xLeft, ssl, 'Support', style = label.style_label_right, textcolor = color.blue, color = color.new(color.black, 100), size = size.small)
        sr_sup_label
    else
        line.set_xy1(sr_sup_line, xLeft, ssl)
        line.set_xy2(sr_sup_line, xRight, ssl)
        line.set_color(sr_sup_line, color.blue)
        label.set_x(sr_sup_label, xLeft)
        label.set_y(sr_sup_label, ssl)
        label.set_text(sr_sup_label, 'Support')
        label.set_textcolor(sr_sup_label, color.blue)
else
    if not na(sr_res_line)
        line.delete(sr_res_line)
        sr_res_line := na
        sr_res_line
    if not na(sr_sup_line)
        line.delete(sr_sup_line)
        sr_sup_line := na
        sr_sup_line
    if not na(sr_res_label)
        label.delete(sr_res_label)
        sr_res_label := na
        sr_res_label
    if not na(sr_sup_label)
        label.delete(sr_sup_label)
        sr_sup_label := na
        sr_sup_label
        //==============================================================================
        // RISK/REWARD DYNAMIC RAILS
        //==============================================================================
var line rr_entry = na
var line rr_t1 = na
var line rr_t2 = na
var line rr_sl = na
var label rr_entry_tag = na
var label rr_t1_tag = na
var label rr_t2_tag = na
var label rr_sl_tag = na
var float active_entry = na
var float active_t1 = na
var float active_t2 = na
var float active_sl = na
var bool active_is_long = false
if active_is_long
    if active_is_long
        if high >= active_t2 and not na(rr_t2)
            line.delete(rr_t2)
            rr_t2 := na
            if not na(rr_t2_tag)
                label.delete(rr_t2_tag)
                rr_t2_tag := na
                rr_t2_tag
            active_t2 := na
            active_t2
        else if high >= active_t1 and not na(rr_t1)
            line.delete(rr_t1)
            rr_t1 := na
            if not na(rr_t1_tag)
                label.delete(rr_t1_tag)
                rr_t1_tag := na
                rr_t1_tag
            active_t1 := na
            active_t1
        if low <= active_sl
            if not na(rr_entry)
                line.delete(rr_entry)
                rr_entry := na
                rr_entry
            if not na(rr_t1)
                line.delete(rr_t1)
                rr_t1 := na
                rr_t1
            if not na(rr_t2)
                line.delete(rr_t2)
                rr_t2 := na
                rr_t2
            if not na(rr_sl)
                line.delete(rr_sl)
                rr_sl := na
                rr_sl
            if not na(rr_entry_tag)
                label.delete(rr_entry_tag)
                rr_entry_tag := na
                rr_entry_tag
            if not na(rr_t1_tag)
                label.delete(rr_t1_tag)
                rr_t1_tag := na
                rr_t1_tag
            if not na(rr_t2_tag)
                label.delete(rr_t2_tag)
                rr_t2_tag := na
                rr_t2_tag
            if not na(rr_sl_tag)
                label.delete(rr_sl_tag)
                rr_sl_tag := na
                rr_sl_tag
            active_entry := na
            active_t1 := na
            active_t2 := na
            active_sl := na
            active_is_long := false
            active_is_long
    else
        if low <= active_t2 and not na(rr_t2)
            line.delete(rr_t2)
            rr_t2 := na
            if not na(rr_t2_tag)
                label.delete(rr_t2_tag)
                rr_t2_tag := na
                rr_t2_tag
            active_t2 := na
            active_t2
        else if low <= active_t1 and not na(rr_t1)
            line.delete(rr_t1)
            rr_t1 := na
            if not na(rr_t1_tag)
                label.delete(rr_t1_tag)
                rr_t1_tag := na
                rr_t1_tag
            active_t1 := na
            active_t1
        if high >= active_sl
            if not na(rr_entry)
                line.delete(rr_entry)
                rr_entry := na
                rr_entry
            if not na(rr_t1)
                line.delete(rr_t1)
                rr_t1 := na
                rr_t1
            if not na(rr_t2)
                line.delete(rr_t2)
                rr_t2 := na
                rr_t2
            if not na(rr_sl)
                line.delete(rr_sl)
                rr_sl := na
                rr_sl
            if not na(rr_entry_tag)
                label.delete(rr_entry_tag)
                rr_entry_tag := na
                rr_entry_tag
            if not na(rr_t1_tag)
                label.delete(rr_t1_tag)
                rr_t1_tag := na
                rr_t1_tag
            if not na(rr_t2_tag)
                label.delete(rr_t2_tag)
                rr_t2_tag := na
                rr_t2_tag
            if not na(rr_sl_tag)
                label.delete(rr_sl_tag)
                rr_sl_tag := na
                rr_sl_tag
            active_entry := na
            active_t1 := na
            active_t2 := na
            active_sl := na
            active_is_long := false
            active_is_long
            //==============================================================================
            // SIGNAL GENERATION ENGINE
            //==============================================================================
modeMult = mode_signal == 'Conservative' ? 1.35 : mode_signal == 'Balanced' ? 1.0 : mode_signal == 'Elite' ? 1.15 : 0.85
minProb = mode_signal == 'Conservative' ? 85 : mode_signal == 'Balanced' ? 70 : mode_signal == 'Elite' ? 75 : 60
longGate = not lock_direction or FieldScore > 0
shortGate = not lock_direction or FieldScore < 0
conf_long = 0
conf_long := conf_long + (FieldScore >= field_long_thr and longGate ? 2 : 0)
conf_long := conf_long + (wave_align > 0.15 ? 1 : 0)
conf_long := conf_long + (H_weighted > 0.55 ? 1 : 0)
conf_long := conf_long + (FDI_score > 0.2 ? 1 : 0)
conf_long := conf_long + (Ent_score > -0.2 ? 1 : 0)
conf_long := conf_long + (TE_sc > 0.02 ? 1 : 0)
conf_long := conf_long + (use_mtf_ctx and mtf_align_score > 0 ? 1 : 0)
conf_long := conf_long + (macdLine > signalLine ? 1 : 0)
conf_short = 0
conf_short := conf_short + (FieldScore <= field_short_thr and shortGate ? 2 : 0)
conf_short := conf_short + (wave_align < -0.15 ? 1 : 0)
conf_short := conf_short + (H_weighted < 0.45 ? 1 : 0)
conf_short := conf_short + (FDI_score < -0.2 ? 1 : 0)
conf_short := conf_short + (Ent_score > -0.2 ? 1 : 0)
conf_short := conf_short + (TE_sc < -0.02 ? 1 : 0)
conf_short := conf_short + (use_mtf_ctx and mtf_align_score < 0 ? 1 : 0)
conf_short := conf_short + (macdLine < signalLine ? 1 : 0)
regimeFactor = dyn_conf ? regime == 'Transitional' ? dyn_range_factor : dyn_trend_factor : 1.0
adjConfL = int(conf_long * modeMult * regimeFactor)
adjConfS = int(conf_short * modeMult * regimeFactor)
probL = clamp(int(adjConfL * 12 + 20 + 25 * math.abs(FieldScore)), 0, 99)
probS = clamp(int(adjConfS * 12 + 20 + 25 * math.abs(FieldScore)), 0, 99)
var int lastSignalBar2 = na
canSignal = na(lastSignalBar2) or bar_index - lastSignalBar2 > cooldownBars
longCand = longGate and adjConfL >= min_confluence and probL >= minProb
shortCand = shortGate and adjConfS >= min_confluence and probS >= minProb
longSignal = false
shortSignal = false
if canSignal
    if prefer_best_side and longCand and shortCand
        priL = probL + 5 * adjConfL + 40 * math.max(FieldScore, 0)
        priS = probS + 5 * adjConfS + 40 * math.max(-FieldScore, 0)
        if priL >= priS
            longSignal := true
            longSignal
        else
            shortSignal := true
            shortSignal
    else
        longSignal := longCand
        shortSignal := shortCand
        shortSignal
        //==============================================================================
        // DRAW RR RAILS ON SIGNAL
        //==============================================================================
risk_stop_long = close - atr14 * risk_atrMultSL
risk_stop_short = close + atr14 * risk_atrMultSL
R_long = close - risk_stop_long
R_short = risk_stop_short - close
t1_long = close + R_long * risk_t1R
t2_long = close + R_long * risk_t2R
t1_short = close - R_short * risk_t1R
t2_short = close - R_short * risk_t2R
if plot_signals and longSignal and probL >= min_prob_plot
    lastSignalBar2 := bar_index
    if not na(rr_entry)
        line.delete(rr_entry)
        rr_entry := na
        rr_entry
    if not na(rr_t1)
        line.delete(rr_t1)
        rr_t1 := na
        rr_t1
    if not na(rr_t2)
        line.delete(rr_t2)
        rr_t2 := na
        rr_t2
    if not na(rr_sl)
        line.delete(rr_sl)
        rr_sl := na
        rr_sl
    if not na(rr_entry_tag)
        label.delete(rr_entry_tag)
        rr_entry_tag := na
        rr_entry_tag
    if not na(rr_t1_tag)
        label.delete(rr_t1_tag)
        rr_t1_tag := na
        rr_t1_tag
    if not na(rr_t2_tag)
        label.delete(rr_t2_tag)
        rr_t2_tag := na
        rr_t2_tag
    if not na(rr_sl_tag)
        label.delete(rr_sl_tag)
        rr_sl_tag := na
        rr_sl_tag
    x0 = bar_index
    x1 = bar_index + rr_len
    colT = color.new(cBull, 55)
    colT2 = color.new(cBull, 35)
    colSL = color.new(cBear, 55)
    colEN = color.new(cNeut, 70)
    rr_entry := line.new(x0, close, x1, close, color = colEN, style = line.style_dotted, width = 3)
    rr_t1 := line.new(x0, t1_long, x1, t1_long, color = colT, style = line.style_dashed, width = 2)
    rr_t2 := line.new(x0, t2_long, x1, t2_long, color = colT2, style = line.style_dashed, width = 2)
    rr_sl := line.new(x0, risk_stop_long, x1, risk_stop_long, color = colSL, style = line.style_dashed, width = 2)
    if right_tags
        xo = 4
        rr_entry_tag := label.new(x1 + xo, close, 'Entry', style = label.style_label_left, color = color.new(color.black, 100), textcolor = cNeut, size = size.normal)
        rr_sl_tag := label.new(x1 + xo, risk_stop_long, 'SL', style = label.style_label_left, color = color.new(color.black, 100), textcolor = cBear, size = size.normal)
        rr_t1_tag := label.new(x1 + xo, t1_long, 'T1', style = label.style_label_left, color = color.new(color.black, 100), textcolor = cBull, size = size.normal)
        rr_t2_tag := label.new(x1 + xo, t2_long, 'T2', style = label.style_label_left, color = color.new(color.black, 100), textcolor = cBull, size = size.normal)
        rr_t2_tag
    active_entry := close
    active_t1 := t1_long
    active_t2 := t2_long
    active_sl := risk_stop_long
    active_is_long := true
    active_is_long
if plot_signals and shortSignal and probS >= min_prob_plot
    lastSignalBar2 := bar_index
    if not na(rr_entry)
        line.delete(rr_entry)
        rr_entry := na
        rr_entry
    if not na(rr_t1)
        line.delete(rr_t1)
        rr_t1 := na
        rr_t1
    if not na(rr_t2)
        line.delete(rr_t2)
        rr_t2 := na
        rr_t2
    if not na(rr_sl)
        line.delete(rr_sl)
        rr_sl := na
        rr_sl
    if not na(rr_entry_tag)
        label.delete(rr_entry_tag)
        rr_entry_tag := na
        rr_entry_tag
    if not na(rr_t1_tag)
        label.delete(rr_t1_tag)
        rr_t1_tag := na
        rr_t1_tag
    if not na(rr_t2_tag)
        label.delete(rr_t2_tag)
        rr_t2_tag := na
        rr_t2_tag
    if not na(rr_sl_tag)
        label.delete(rr_sl_tag)
        rr_sl_tag := na
        rr_sl_tag
    x0 = bar_index
    x1 = bar_index + rr_len
    colT = color.new(cBear, 55)
    colT2 = color.new(cBear, 35)
    colSL = color.new(cBear, 55)
    colEN = color.new(cNeut, 70)
    rr_entry := line.new(x0, close, x1, close, color = colEN, style = line.style_dotted, width = 3)
    rr_t1 := line.new(x0, t1_short, x1, t1_short, color = colT, style = line.style_dashed, width = 2)
    rr_t2 := line.new(x0, t2_short, x1, t2_short, color = colT2, style = line.style_dashed, width = 2)
    rr_sl := line.new(x0, risk_stop_short, x1, risk_stop_short, color = colSL, style = line.style_dashed, width = 2)
    if right_tags
        xo = 4
        rr_entry_tag := label.new(x1 + xo, close, 'Entry', style = label.style_label_left, color = color.new(color.black, 100), textcolor = cNeut, size = size.normal)
        rr_sl_tag := label.new(x1 + xo, risk_stop_short, 'SL', style = label.style_label_left, color = color.new(color.black, 100), textcolor = cBear, size = size.normal)
        rr_t1_tag := label.new(x1 + xo, t1_short, 'T1', style = label.style_label_left, color = color.new(color.black, 100), textcolor = cBear, size = size.normal)
        rr_t2_tag := label.new(x1 + xo, t2_short, 'T2', style = label.style_label_left, color = color.new(color.black, 100), textcolor = cBear, size = size.normal)
        rr_t2_tag
    active_entry := close
    active_t1 := t1_short
    active_t2 := t2_short
    active_sl := risk_stop_short
    active_is_long := false
    active_is_long
    //==============================================================================
    // SIGNAL MARKERS
    //==============================================================================
shouldPlot = plot_signals and (longSignal and probL >= min_prob_plot or shortSignal and probS >= min_prob_plot)
if shouldPlot
    if longSignal
        label.new(bar_index, low - atr14 * 2.0, signal_labels ? '‚ñ≤\n' + str.tostring(probL) + '%' : '‚ñ≤', color = color.new(color.black, 100), style = label.style_none, textcolor = cGold, size = size.normal)
    if shortSignal
        label.new(bar_index, high + atr14 * 1.0, signal_labels ? str.tostring(probS) + '%\n‚ñº' : '‚ñº', color = color.new(color.black, 100), style = label.style_none, textcolor = cGold, size = size.normal)
        //==============================================================================
        // ANALYTICS DASHBOARD
        //==============================================================================
var table dash = na
dashLoc = dash_pos == 'Top Right' ? position.top_right : dash_pos == 'Top Left' ? position.top_left : dash_pos == 'Bottom Right' ? position.bottom_right : position.bottom_left
volRatio = volume / volSMA20
if show_dashboard2 and barstate.islast
    if not na(dash)
        table.delete(dash)
    dash := table.new(dashLoc, 3, 22, border_width = 2)
    bgColor = theme == 'Dark' ? color.new(#1a1a1a, 20) : theme == 'Light' ? color.new(#f5f5f5, 20) : color.new(#000033, 20)
    textColor = theme == 'Light' ? color.black : color.white
    headerColor = theme == 'Neon' ? color.new(#00ff00, 0) : cGold
    row = 0
    table.merge_cells(dash, 0, row, 2, row)
    table.cell(dash, 0, row, 'üìä IGMD FIELD ANALYTICS', text_color = headerColor, text_size = size.normal, bgcolor = bgColor)
    row := row + 1
    table.merge_cells(dash, 0, row, 2, row)
    table.cell(dash, 0, row, '‚îÅ‚îÅ‚îÅ Field Analysis ‚îÅ‚îÅ‚îÅ', text_color = color.new(textColor, 50), text_size = size.tiny, bgcolor = bgColor)
    row := row + 1
    table.cell(dash, 0, row, 'Field Score', text_color = textColor, text_size = size.small, bgcolor = bgColor)
    table.cell(dash, 1, row, str.tostring(FieldScore, '#.00'), text_color = FieldScore > 0 ? cBull : cBear, text_size = size.small, bgcolor = bgColor)
    table.cell(dash, 2, row, regime, text_color = cInfo, text_size = size.tiny, bgcolor = bgColor)
    row := row + 1
    table.cell(dash, 0, row, 'Wave Align', text_color = textColor, text_size = size.small, bgcolor = bgColor)
    table.cell(dash, 1, row, str.tostring(wave_align, '#.00'), text_color = wave_align >= 0 ? cBull : cBear, text_size = size.small, bgcolor = bgColor)
    table.cell(dash, 2, row, 'H(w) ' + (na(H_weighted) ? 'N/A' : str.tostring(H_weighted, '#.00')), text_color = cInfo, text_size = size.tiny, bgcolor = bgColor)
    row := row + 1
    table.merge_cells(dash, 0, row, 2, row)
    table.cell(dash, 0, row, '‚îÅ‚îÅ‚îÅ Complexity ‚îÅ‚îÅ‚îÅ', text_color = color.new(textColor, 50), text_size = size.tiny, bgcolor = bgColor)
    row := row + 1
    table.cell(dash, 0, row, 'FDI', text_color = textColor, text_size = size.small, bgcolor = bgColor)
    table.cell(dash, 1, row, str.tostring(FDI, '#.00'), text_color = FDI_score > 0 ? cBull : cBear, text_size = size.small, bgcolor = bgColor)
    table.cell(dash, 2, row, 'Score ' + str.tostring(FDI_score, '#.00'), text_color = cInfo, text_size = size.tiny, bgcolor = bgColor)
    row := row + 1
    table.cell(dash, 0, row, 'Entropy', text_color = textColor, text_size = size.small, bgcolor = bgColor)
    table.cell(dash, 1, row, na(EntropyN) ? 'N/A' : str.tostring(EntropyN, '#.00'), text_color = Ent_score > 0 ? cBull : cBear, text_size = size.small, bgcolor = bgColor)
    table.cell(dash, 2, row, 'Z ' + str.tostring(entZ, '#.00'), text_color = cGray, text_size = size.tiny, bgcolor = bgColor)
    row := row + 1
    table.cell(dash, 0, row, 'TE dir', text_color = textColor, text_size = size.small, bgcolor = bgColor)
    table.cell(dash, 1, row, str.tostring(TE_sc, '#.00'), text_color = TE_sc > 0 ? cBull : cBear, text_size = size.small, bgcolor = bgColor)
    table.cell(dash, 2, row, 'throttle x' + str.tostring(te_step), text_color = cGray, text_size = size.tiny, bgcolor = bgColor)
    row := row + 1
    table.cell(dash, 0, row, 'MTF Align', text_color = textColor, text_size = size.small, bgcolor = bgColor)
    table.cell(dash, 1, row, use_mtf_ctx ? str.tostring(mtf_align_score, '#.00') : 'off', text_color = mtf_align_score > 0 ? cBull : mtf_align_score < 0 ? cBear : cNeut, text_size = size.small, bgcolor = bgColor)
    table.cell(dash, 2, row, ref_tf1 + '/' + ref_tf2, text_color = cGray, text_size = size.tiny, bgcolor = bgColor)
    row := row + 1
    table.merge_cells(dash, 0, row, 2, row)
    table.cell(dash, 0, row, '‚îÅ‚îÅ‚îÅ Market Context ‚îÅ‚îÅ‚îÅ', text_color = color.new(textColor, 50), text_size = size.tiny, bgcolor = bgColor)
    row := row + 1
    table.cell(dash, 0, row, 'RSI', text_color = textColor, text_size = size.small, bgcolor = bgColor)
    rsiColor = rsi14 > 70 ? cBear : rsi14 < 30 ? cBull : cNeut
    table.cell(dash, 1, row, str.tostring(rsi14, '#'), text_color = rsiColor, text_size = size.small, bgcolor = bgColor)
    table.cell(dash, 2, row, rsi14 > 70 ? 'Overbought' : rsi14 < 30 ? 'Oversold' : 'Neutral', text_color = rsiColor, text_size = size.tiny, bgcolor = bgColor)
    row := row + 1
    table.cell(dash, 0, row, 'Volume', text_color = textColor, text_size = size.small, bgcolor = bgColor)
    table.cell(dash, 1, row, str.tostring(volRatio, '#.##') + 'x', text_color = volRatio > 1.5 ? cBull : cNeut, text_size = size.small, bgcolor = bgColor)
    volState = volRatio > 2 ? 'Extreme' : volRatio > 1.5 ? 'High' : volRatio < 0.5 ? 'Low' : 'Normal'
    table.cell(dash, 2, row, volState, text_color = volRatio > 1.5 ? cBull : cNeut, text_size = size.tiny, bgcolor = bgColor)
    row := row + 1
    table.cell(dash, 0, row, 'ATR', text_color = textColor, text_size = size.small, bgcolor = bgColor)
    table.cell(dash, 1, row, str.tostring(atr14, format.mintick), text_color = cNeut, text_size = size.small, bgcolor = bgColor)
    table.cell(dash, 2, row, str.tostring(atr14 / close * 100, '#.#') + '%', text_color = cGray, text_size = size.tiny, bgcolor = bgColor)
    row := row + 1
    table.merge_cells(dash, 0, row, 2, row)
    table.cell(dash, 0, row, '‚îÅ‚îÅ‚îÅ Signals ‚îÅ‚îÅ‚îÅ', text_color = color.new(textColor, 50), text_size = size.tiny, bgcolor = bgColor)
    row := row + 1
    table.cell(dash, 0, row, 'Confluence L/S', text_color = textColor, text_size = size.small, bgcolor = bgColor)
    table.cell(dash, 1, row, str.tostring(adjConfL) + '/' + str.tostring(adjConfS), text_color = textColor, text_size = size.small, bgcolor = bgColor)
    table.cell(dash, 2, row, 'Min ' + str.tostring(min_confluence), text_color = cGray, text_size = size.tiny, bgcolor = bgColor)
    row := row + 1
    table.cell(dash, 0, row, 'Probability', text_color = textColor, text_size = size.small, bgcolor = bgColor)
    table.cell(dash, 1, row, str.tostring(probL) + '%', text_color = cBull, text_size = size.small, bgcolor = bgColor)
    table.cell(dash, 2, row, str.tostring(probS) + '%', text_color = cBear, text_size = size.small, bgcolor = bgColor)
    row := row + 1
    table.cell(dash, 0, row, 'Pattern', text_color = textColor, text_size = size.small, bgcolor = bgColor)
    patColor = apex_pat_name == 'None' ? cNeut : FieldScore >= 0 ? cBull : cBear
    table.cell(dash, 1, row, apex_pat_name, text_color = patColor, text_size = size.small, bgcolor = bgColor)
    table.cell(dash, 2, row, str.tostring(int(apex_pat_conf)) + '%', text_color = patColor, text_size = size.small, bgcolor = bgColor)
    row := row + 1
    table.cell(dash, 0, row, 'Mode', text_color = textColor, text_size = size.small, bgcolor = bgColor)
    table.cell(dash, 1, row, mode_signal, text_color = cInfo, text_size = size.small, bgcolor = bgColor)
    signalStatus = longSignal ? 'LONG' : shortSignal ? 'SHORT' : 'WAIT'
    statusColor = longSignal ? cBull : shortSignal ? cBear : cGray
    table.cell(dash, 2, row, signalStatus, text_color = statusColor, text_size = size.small, bgcolor = bgColor)
    row := row + 1
    table.merge_cells(dash, 0, row, 2, row)
    table.cell(dash, 0, row, '‚ñ≤ Entry ‚Ä¢ ‚îÅ RR Rails ‚Ä¢ ‚ñà Pattern Box', text_color = color.new(textColor, 50), text_size = size.tiny, bgcolor = bgColor)
    row := row + 1
    row := row + 1
    table.merge_cells(dash, 0, row, 2, row)
    table.cell(dash, 0, row, '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ', text_color = color.new(headerColor, 50), text_size = size.tiny, bgcolor = bgColor)
    row := row + 1
    table.merge_cells(dash, 0, row, 2, row)
    table.cell(dash, 0, row, '-- ‚ö° Dskyz (DAFE) Trading Systems --', text_color = color.new(headerColor, 30), text_size = size.tiny, bgcolor = bgColor)
    //==============================================================================
    // ALERTS
    //==============================================================================
alertcondition(longSignal, title = 'IGMD Long Signal', message = 'IGMD Long Signal Triggered - Check Dashboard for Details')
alertcondition(shortSignal, title = 'IGMD Short Signal', message = 'IGMD Short Signal Triggered - Check Dashboard for Details')
alertcondition(longSignal or shortSignal, title = 'IGMD Any Signal', message = 'IGMD Signal Triggered')
alertcondition(FieldScore > 0.5, title = 'Strong Bullish Field', message = 'IGMD: Strong Bullish Field Detected')
alertcondition(FieldScore < -0.5, title = 'Strong Bearish Field', message = 'IGMD: Strong Bearish Field Detected')
alertcondition(pattern_trigger, title = 'Pattern Formation', message = 'IGMD: New Pattern Formation Detected')
//==============================================================================
// PLOT EXPORTS
//==============================================================================
plot(FieldScore, title = 'Field Score', display = display.none)
plot(probL, title = 'Long Probability', display = display.none)
plot(probS, title = 'Short Probability', display = display.none)
plot(H_weighted, title = 'Hurst Exponent', display = display.none)
plot(FDI, title = 'Fractal Dimension', display = display.none)
plot(EntropyN, title = 'Shannon Entropy', display = display.none)
plot(TE_sc, title = 'Transfer Entropy', display = display.none)

























// // This Pine Script‚Ñ¢ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// // ¬© WhaleMoves

// //‚ñë‚ñà‚ñà‚ïó‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó‚ñë‚ñë‚ñà‚ñà‚ïó‚ñë‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñë‚ñà‚ñà‚ïó‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ïó‚ñë‚ñë‚ñë‚ñà‚ñà‚ñà‚ïó‚ñë‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñë‚ñà‚ñà‚ïó‚ñë‚ñë‚ñë‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó
// //‚ñë‚ñà‚ñà‚ïë‚ñë‚ñë‚ñà‚ñà‚ïó‚ñë‚ñë‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñë‚ñë‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ñà‚ñà‚ïó‚ñë‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ñë‚ñë‚ñë‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù
// //‚ñë‚ïö‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñë‚ñë  ‚ñà‚ñà‚ïî‚ñà‚ñà‚ñà‚ñà‚ïî‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñë‚ñë‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïó‚ñë‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñë‚ñë‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñë
// //‚ñë‚ñë‚ñà‚ñà‚ñà‚ñà‚ïî‚ïê‚ñà‚ñà‚ñà‚ñà‚ïë‚ñë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù‚ñë‚ñë  ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñë‚ñë‚ñà‚ñà‚ïë‚ñë‚ïö‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù‚ñë‚ñë‚ñë‚ïö‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó
// //‚ñë‚ñë‚ïö‚ñà‚ñà‚ïî‚ïù‚ñë‚ïö‚ñà‚ñà‚ïî‚ïù‚ñë‚ñà‚ñà‚ïë‚ñë‚ñë‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñë‚ñë‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë‚ñë‚ïö‚ïê‚ïù‚ñë‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñë‚ñë‚ïö‚ñà‚ñà‚ïî‚ïù‚ñë‚ñë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù
// //‚ñë‚ñë‚ñë‚ïö‚ïê‚ïù‚ñë‚ñë‚ñë‚ïö‚ïê‚ïù‚ñë‚ñë‚ïö‚ïê‚ïù‚ñë‚ñë‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù‚ñë‚ñë‚ïö‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ñë‚ñë‚ñë‚ñë‚ñë‚ïö‚ïê‚ïù‚ñë‚ïö‚ïê‚ïê‚ïê‚ïê‚ïù‚ñë‚ñë‚ñë‚ñë‚ïö‚ïê‚ïù‚ñë‚ñë‚ñë‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ñë

// //@version=6

// ///indicator('üêãüî∞üêãWhale Supertrend (V1.2)', overlay = true)

// superTrendCount = input.int(4, title = 'Super Trend Count', tooltip = 'Number of Supertrends required to trigger a signal')

// atrPeriod = input.int(10, title = 'ATR Period', minval = 1, group = 'Supertrend 1')

// factor = input.float(3.0, title = 'Factor', step = 0.1, minval = 0.1, group = 'Supertrend 1')

// atrPeriod1 = input.int(10, title = 'ATR Period', minval = 1, group = 'Supertrend 2')

// factor1 = input.float(4.0, title = 'Factor', step = 0.1, minval = 0.1, group = 'Supertrend 2')

// atrPeriod2 = input.int(10, title = 'ATR Period', minval = 1, group = 'Supertrend 3')

// factor2 = input.float(6.0, title = 'Factor', step = 0.1, minval = 0.1, group = 'Supertrend 3')

// atrPeriod3 = input.int(10, title = 'ATR Period', minval = 1, group = 'Supertrend 4')

// factor3 = input.float(9.0, title = 'Factor', step = 0.1, minval = 0.1, group = 'Supertrend 4')

// atrPeriod4 = input.int(10, title = 'ATR Period', minval = 1, group = 'Supertrend 5')

// factor4 = input.float(13.0, title = 'Factor', step = 0.1, minval = 0.1, group = 'Supertrend 5')

// atrPeriod5 = input.int(10, title = 'ATR Period', minval = 1, group = 'Supertrend 6')

// factor5 = input.float(18.0, title = 'Factor', step = 0.1, minval = 0.1, group = 'Supertrend 6')

// [supertrend, direction] = ta.supertrend(factor, atrPeriod)

// supertrend := barstate.isfirst ? na : supertrend

// upTrend = plot(direction < 0 ? supertrend : na, 'Up Trend', color = #00FFFF, style = plot.style_linebr, editable = true)

// downTrend = plot(direction < 0 ? na : supertrend, 'Down Trend', color = #ED9FFF, style = plot.style_linebr, editable = true)

// bodyMiddle = plot(barstate.isfirst ? na : (open + close) / 2, 'Body Middle', display = display.none, editable = false)

// fill(bodyMiddle, upTrend, color.new(#00FFFF, 90), fillgaps = false, editable = true)

// fill(bodyMiddle, downTrend, color.new(#ED9FFF, 90), fillgaps = false, editable = true)

// [supertrend1, direction1] = ta.supertrend(factor1, atrPeriod1)

// supertrend1 := barstate.isfirst ? na : supertrend1

// upTrend1 = plot(direction1 < 0 ? supertrend1 : na, 'Up Trend', color = #00FFFF, style = plot.style_linebr, editable = true)

// downTrend1 = plot(direction1 < 0 ? na : supertrend1, 'Down Trend', color = #ED9FFF, style = plot.style_linebr, editable = true)

// bodyMiddle1 = plot(barstate.isfirst ? na : (open + close) / 2, 'Body Middle', display = display.none, editable = false)

// fill(bodyMiddle1, upTrend1, color.new(#00FFFF, 90), fillgaps = false, editable = true)

// fill(bodyMiddle1, downTrend1, color.new(#ED9FFF, 90), fillgaps = false, editable = true)

// [supertrend2, direction2] = ta.supertrend(factor2, atrPeriod2)

// supertrend2 := barstate.isfirst ? na : supertrend2

// upTrend2 = plot(direction2 < 0 ? supertrend2 : na, 'Up Trend', color = #00FFFF, style = plot.style_linebr, editable = true)

// downTrend2 = plot(direction2 < 0 ? na : supertrend2, 'Down Trend', color = #ED9FFF, style = plot.style_linebr, editable = true)

// bodyMiddle2 = plot(barstate.isfirst ? na : (open + close) / 2, 'Body Middle', display = display.none, editable = false)

// fill(bodyMiddle2, upTrend2, color.new(#00FFFF, 90), fillgaps = false, editable = true)

// fill(bodyMiddle2, downTrend2, color.new(#ED9FFF, 90), fillgaps = false, editable = true)

// [supertrend3, direction3] = ta.supertrend(factor3, atrPeriod3)

// supertrend3 := barstate.isfirst ? na : supertrend3

// upTrend3 = plot(direction3 < 0 ? supertrend3 : na, 'Up Trend', color = #00FFFF, style = plot.style_linebr, editable = true)

// downTrend3 = plot(direction3 < 0 ? na : supertrend3, 'Down Trend', color = #ED9FFF, style = plot.style_linebr, editable = true)

// bodyMiddle3 = plot(barstate.isfirst ? na : (open + close) / 2, 'Body Middle', display = display.none, editable = false)

// fill(bodyMiddle3, upTrend3, color.new(#00FFFF, 90), fillgaps = false, editable = true)

// fill(bodyMiddle3, downTrend3, color.new(#ED9FFF, 90), fillgaps = false, editable = true)

// [supertrend4, direction4] = ta.supertrend(factor4, atrPeriod4)

// supertrend4 := barstate.isfirst ? na : supertrend4

// upTrend4 = plot(direction4 < 0 ? supertrend4 : na, 'Up Trend', color = #00FFFF, style = plot.style_linebr, editable = true)

// downTrend4 = plot(direction4 < 0 ? na : supertrend4, 'Down Trend', color = #ED9FFF, style = plot.style_linebr, editable = true)

// bodyMiddle4 = plot(barstate.isfirst ? na : (open + close) / 2, 'Body Middle', display = display.none, editable = false)

// fill(bodyMiddle4, upTrend4, color.new(#00FFFF, 90), fillgaps = false, editable = true)

// fill(bodyMiddle4, downTrend4, color.new(#ED9FFF, 90), fillgaps = false, editable = true)

// [supertrend5, direction5] = ta.supertrend(factor5, atrPeriod5)

// supertrend5 := barstate.isfirst ? na : supertrend5

// upTrend5 = plot(direction5 < 0 ? supertrend5 : na, 'Up Trend', color = #00FFFF, style = plot.style_linebr, editable = true)

// downTrend5 = plot(direction5 < 0 ? na : supertrend5, 'Down Trend', color = #ED9FFF, style = plot.style_linebr, editable = true)

// bodyMiddle5 = plot(barstate.isfirst ? na : (open + close) / 2, 'Body Middle', display = display.none, editable = false)

// fill(bodyMiddle5, upTrend5, color.new(#00FFFF, 90), fillgaps = false, editable = true)

// fill(bodyMiddle5, downTrend5, color.new(#ED9FFF, 90), fillgaps = false, editable = true)

// bullishCount = (direction < 0 ? 1 : 0) + (direction1 < 0 ? 1 : 0) + (direction2 < 0 ? 1 : 0) + (direction3 < 0 ? 1 : 0) + (direction4 < 0 ? 1 : 0) + (direction5 < 0 ? 1 : 0)

// bearishCount = (direction >= 0 ? 1 : 0) + (direction1 >= 0 ? 1 : 0) + (direction2 >= 0 ? 1 : 0) + (direction3 >= 0 ? 1 : 0) + (direction4 >= 0 ? 1 : 0) + (direction5 >= 0 ? 1 : 0)

// buySignal = bullishCount >= superTrendCount

// sellSignal = bearishCount >= superTrendCount

// alertcondition(buySignal, title = 'Buy Alert', message = 'Buy signal detected')

// alertcondition(sellSignal, title = 'Sell Alert', message = 'Sell signal detected')

// var bool prevBuySignal = false

// var bool prevSellSignal = false

// triggerBuy = buySignal and not prevBuySignal

// triggerSell = sellSignal and not prevSellSignal

// prevBuySignal := buySignal

// prevSellSignal := sellSignal

// plotshape(series = triggerBuy, title = 'Buy Signal', location = location.belowbar, color = #00FFFF, style = shape.labelup, text = '‚ñ≤', textcolor = color.white, size = size.small)

// plotshape(series = triggerSell, title = 'Sell Signal', location = location.abovebar, color = #ED9FFF, style = shape.labeldown, text = '‚ñº', textcolor = color.white, size = size.small)

// var int lastSignal = na

// if triggerBuy
//     lastSignal := 1
//     lastSignal
// if triggerSell
//     lastSignal := -1
//     lastSignal

// barColor = lastSignal == 1 ? #00FF13 : lastSignal == -1 ? #FF0000 : na

// plotcandle(open = open, high = high, low = low, close = close, color = barColor, wickcolor = barColor, bordercolor = barColor, title = 'Colored Candles')












//@version=6
//indicator("Quantura - Liquidity Sweep & Run Levels", overlay=true, max_lines_count=500)

// === INPUTS ===
// Calculation
//@version=6
///indicator("Swing Breaker (Quantura Edition)", overlay = true)

// === INPUTS ===
mode_quantura      = input.string("Sweep", "Mode", options = ["Run", "Sweep"], group = "Calculations")
swingLen_quantura  = input.int(10, "Swing Length", minval = 1, group = "Calculations")

colorBull_quantura = input.color(#75fbfe, "Bullish Color", group = "Overlays")
colorBear_quantura = input.color(#f23645, "Bearish Color", group = "Overlays")

showSign_quantura  = input.bool(true, "Signals", group = "Signals")

// === ARRAYS ===
var float[] swingHighs_quantura        = array.new_float()
var line[]  swingHighLines_quantura    = array.new_line()
var bool[]  swingHighBroken_quantura   = array.new_bool()
var bool[]  swingHighRetested_quantura = array.new_bool()

var float[] swingLows_quantura         = array.new_float()
var line[]  swingLowLines_quantura     = array.new_line()
var bool[]  swingLowBroken_quantura    = array.new_bool()
var bool[]  swingLowRetested_quantura  = array.new_bool()

// === FUNCTIONS ===
isSwingHigh() => ta.highest(high, swingLen_quantura*3) == high[swingLen_quantura]
isSwingLow()  => ta.lowest(low, swingLen_quantura*3) == low[swingLen_quantura]

// === SWING DETECTION ===
if isSwingHigh()
    array.push(swingHighs_quantura, high[swingLen_quantura])
    ln = line.new(bar_index-swingLen_quantura, high[swingLen_quantura], last_bar_index, high[swingLen_quantura], color=colorBear_quantura, width=1)
    array.push(swingHighLines_quantura, ln)
    array.push(swingHighBroken_quantura, false)
    array.push(swingHighRetested_quantura, false)

if isSwingLow()
    array.push(swingLows_quantura, low[swingLen_quantura])
    ln = line.new(bar_index-swingLen_quantura, low[swingLen_quantura], last_bar_index, low[swingLen_quantura], color=colorBull_quantura, width=1)
    array.push(swingLowLines_quantura, ln)
    array.push(swingLowBroken_quantura, false)
    array.push(swingLowRetested_quantura, false)

// === LINE FIXING AT BREAK ===
// Swing Highs
for idx = 0 to array.size(swingHighs_quantura) - 1
    if array.size(swingHighs_quantura) > 0 and idx < array.size(swingHighs_quantura)
        level = array.get(swingHighs_quantura, idx)
        ln = array.get(swingHighLines_quantura, idx)
        broken = array.get(swingHighBroken_quantura, idx)
        if not broken and high > level
            array.set(swingHighBroken_quantura, idx, true)
            line.set_x2(ln, bar_index)
            line.set_y2(ln, level)
            line.set_extend(ln, extend.none)

// Swing Lows
for idx = 0 to array.size(swingLows_quantura) - 1
    if array.size(swingLows_quantura) > 0 and idx < array.size(swingLows_quantura)
        level = array.get(swingLows_quantura, idx)
        ln = array.get(swingLowLines_quantura, idx)
        broken = array.get(swingLowBroken_quantura, idx)
        if not broken and low < level
            array.set(swingLowBroken_quantura, idx, true)
            line.set_x2(ln, bar_index)
            line.set_y2(ln, level)
            line.set_extend(ln, extend.none)

// === SIGNAL GENERATION ===
longSignal_quantura = false
shortSignal_quantura = false

for idx = 0 to array.size(swingLows_quantura) - 1
    if array.size(swingLows_quantura) > 0 and idx < array.size(swingLows_quantura)
        level = array.get(swingLows_quantura, idx)
        broken = array.get(swingLowBroken_quantura, idx)
        retested = array.get(swingLowRetested_quantura, idx)
        if broken and not retested
            if (mode_quantura == "Sweep") and (close > level and low < level)
                longSignal_quantura := true
                array.set(swingLowRetested_quantura, idx, true)
                break
            if (mode_quantura == "Run") and (close < level and close[1] > level)
                shortSignal_quantura := true
                array.set(swingLowRetested_quantura, idx, true)
                break

for idx = 0 to array.size(swingHighs_quantura) - 1
    if array.size(swingHighs_quantura) > 0 and idx < array.size(swingHighs_quantura)
        level = array.get(swingHighs_quantura, idx)
        broken = array.get(swingHighBroken_quantura, idx)
        retested = array.get(swingHighRetested_quantura, idx)
        if broken and not retested
            if (mode_quantura == "Sweep") and (close < level and high > level)
                shortSignal_quantura := true
                array.set(swingHighRetested_quantura, idx, true)
                break
            if (mode_quantura == "Run") and (close > level and close[1] < level)
                longSignal_quantura := true
                array.set(swingHighRetested_quantura, idx, true)
                break

// === ENTRY SHAPES ===
plotshape(series = showSign_quantura ? longSignal_quantura : false, title="Bullish Signal", text = '‚ñ≤', style = shape.labelup, location = location.belowbar, color = colorBull_quantura, textcolor = color.white, size = size.tiny, editable = false)
plotshape(series = showSign_quantura ? shortSignal_quantura : false, title="Bearish Signal", text = '‚ñº', style = shape.labeldown, location = location.abovebar, color = colorBear_quantura, textcolor = color.white, size = size.tiny, editable = false)





















//@version=5
//indicator("Order Block Matrix [Alpha Extract]", overlay=true, max_bars_back=5000, max_boxes_count=500, max_lines_count=500)

formatVolume(vol) =>
    vol >= 1000000 ? str.tostring(math.round(vol / 1000000, 2)) + "M" :
         vol >= 1000 ? str.tostring(math.round(vol / 1000, 2)) + "K" :
         str.tostring(math.round(vol, 2))

// === ORDER BLOCKS INPUTS ===
obLookback = input.int(10, "Order Block Breadth", minval=1, group="Order Blocks")
obmode = input.string("Full", "Method", options=["Breadth", "Full"], 
     tooltip="[Breadth] Use Breadth to adjust coordinate of the orderblocks\n[Full] Use whole candle body", group="Order Blocks")
obmiti = input.string("Close", "Risk Method", options=["Close", "Wick"], 
     tooltip="Risk method for when to trigger order blocks", group="Order Blocks")
obMaxBlocks = input.int(6, "Maximum Order Blocks", minval=1, maxval=500, group="Order Blocks")

windowsis = true
mswindow = 1000

amountOfBoxes = input.int(7, "Number of Grid Segments", minval=3, maxval=20, group="VISUAL SETTINGS")
showBorder = input.bool(true, "Show Block Borders", group="VISUAL SETTINGS")
borderWidth = input.int(1, "Border Width", minval=0, maxval=4, group="VISUAL SETTINGS")
showVolume = input.bool(true, "Show Volume Text", group="VISUAL SETTINGS")
volumePosition = input.float(0.80, "Volume Text Position (0-1)", minval=0.1, maxval=5.1, step=0.05, group="VISUAL SETTINGS") 

obHighVolumeColor = color.new(#089981, 10)
obLowVolumeColor = color.new(#089981, 85)
obBearHighVolumeColor = color.new(#f23645, 10)
obBearLowVolumeColor = color.new(#f23645, 85)
obBullBorderColor = color.new(#089981, 20)
obBearBorderColor = color.new(#ffa8af, 20)
obBullFillColor = color.new(#089981, 65)
obBearFillColor = color.new(#f23645, 65)
volumeTextColor = input.color(color.white, "Volume Text Color", group="VISUAL SETTINGS")

// === SCREENER TABLE INPUTS ===
showScreener = input.bool(true, "Show Screener Table", group="Screener")
tablePosition = input.string("Top Right", "Table Position", 
     options=["Top Left", "Top Right", "Bottom Left", "Bottom Right"], group="Screener")
tableSize = input.string("Small", "Table Size", 
     options=["Small", "Normal", "Large"], group="Screener")
     
// Table position mapping
var position = 
     tablePosition == "Top Left" ? position.top_left :
     tablePosition == "Top Right" ? position.top_right :
     tablePosition == "Bottom Left" ? position.bottom_left :
     position.bottom_right

// Table size mapping
var tSize = 
     tableSize == "Small" ? size.small :
     tableSize == "Large" ? size.large :
     size.normal

// === ENHANCED ORDER BLOCK TYPE ===
type orderBlock
    array<box> boxArray
    array<float> boxVolumes
    float topValue
    float botValue
    int leftTime
    int rightTime
    string direction
    float totalVolume
    label volumeLabel
    line volumeLine
    bool mitigated
    line topLine
    line botLine
    linefill bgFill

var float atr = ta.atr(14)
atr := ta.atr(14)

var array<orderBlock> bullBlocks = array.new<orderBlock>()
var array<orderBlock> bearBlocks = array.new<orderBlock>()

var float last_bull_volume = 0.0
var float last_bear_volume = 0.0
var string dom_block = "None"
var float block_strength = 0.0
var float price_distance = 0.0
var int touch_count = 0
var float block_size = 0.0
var float size_ratio = 1.0

var bool bull_touch = false
var bool bear_touch = false
var bool bull_reject = false
var bool bear_reject = false
var bool new_bull = false
var bool new_bear = false

bull_touch := false
bear_touch := false
bull_reject := false
bear_reject := false
new_bull := false
new_bear := false

generateBorderLines(orderBlock block, topValue, botValue) =>
    if showBorder
        borderColor = block.direction == "Bull" ? obBullBorderColor : obBearBorderColor
        fillColor = block.direction == "Bull" ? obBullFillColor : obBearFillColor
        
        newTopLine = line.new(
             x1 = block.leftTime, 
             y1 = topValue, 
             x2 = time, 
             y2 = topValue, 
             xloc = xloc.bar_time, 
             extend = extend.none, 
             color = borderColor, 
             style = line.style_solid, 
             width = borderWidth)
        
        newbotLine = line.new(
             x1 = block.leftTime, 
             y1 = botValue, 
             x2 = time, 
             y2 = botValue, 
             xloc = xloc.bar_time, 
             extend = extend.none, 
             color = borderColor, 
             style = line.style_solid, 
             width = borderWidth)
        
        newlinefill = linefill.new(newTopLine, newbotLine, fillColor)
        [newTopLine, newbotLine, newlinefill]
    else
        [na, na, na]

// Generate volume boxes for an order block
generateVolumeBoxes(orderBlock block, float orderVolume) =>
    volumeArray = array.new_float(amountOfBoxes, 0)
    array.set(volumeArray, 0, orderVolume)
    
    boxesArray = array.new_box()
    
    startValue = block.topValue
    increment = (block.topValue - block.botValue) / amountOfBoxes
    
    highestVolume = orderVolume
    timeLength = time - block.leftTime
    
    timeRatio = highestVolume > 0 ? timeLength / highestVolume * 0.9 : 0
    
    for i = 0 to amountOfBoxes - 1
        topOfGrid = startValue - (increment * i)
        botOfGrid = startValue - (increment * (i + 1))
        
        multiplier = 1.0
        if i == 0 or i == amountOfBoxes - 1
            multiplier := 0.4
        else if i == 1 or i == amountOfBoxes - 2
            multiplier := 0.6
        else if i == 2 or i == amountOfBoxes - 3
            multiplier := 0.8
        else
            multiplier := 1.0
            
        segmentVolume = orderVolume * multiplier / amountOfBoxes * 2
        array.set(volumeArray, i, segmentVolume)
        
        color highVol = block.direction == "Bull" ? obHighVolumeColor : obBearHighVolumeColor
        color lowVol = block.direction == "Bull" ? obLowVolumeColor : obBearLowVolumeColor
        
        color boxColor = color.from_gradient(multiplier, 0.2, 1.0, lowVol, highVol)
        
        maxWidth = math.min(timeLength * 1.2, segmentVolume * timeRatio)
        
        newBox = box.new(
             left = block.leftTime, 
             top = topOfGrid, 
             right = block.leftTime + math.round(maxWidth), 
             bottom = botOfGrid, 
             border_color = boxColor, 
             border_width = 1, 
             xloc = xloc.bar_time, 
             bgcolor = boxColor, 
             extend = extend.none)
        
        array.push(boxesArray, newBox)
    
    [boxesArray, volumeArray, array.sum(volumeArray)]

updateBoxes(orderBlock block, currentTime) =>
    if array.size(block.boxArray) > 0
        highestVolume = array.max(block.boxVolumes)
        timeLength = currentTime - block.leftTime
        timeRatio = highestVolume > 0 ? timeLength / highestVolume * 0.9 : 0
        
        for i = 0 to math.min(amountOfBoxes - 1, array.size(block.boxArray) - 1)
            if i < array.size(block.boxVolumes)
                boxVolume = array.get(block.boxVolumes, i)
                if not na(boxVolume)
                    maxWidth = math.min(timeLength * 1.2, boxVolume * timeRatio)
                    box.set_right(array.get(block.boxArray, i), block.leftTime + math.round(maxWidth))
    
    if not na(block.topLine) and not na(block.botLine)
        line.set_x2(block.topLine, currentTime)
        line.set_x2(block.botLine, currentTime)
    
    if not na(block.volumeLine) and not na(block.volumeLabel) and showVolume
        blockCenter = (block.topValue + block.botValue) / 2
        lineStartX = block.leftTime + math.round((currentTime - block.leftTime) * 0.95)
        lineEndX = lineStartX + math.round((currentTime - block.leftTime) * 0.2)
        
        lineEndY = block.direction == "Bull" ? 
             blockCenter + (block.topValue - block.botValue) * 0.3 :
             blockCenter - (block.topValue - block.botValue) * 0.3
            
        line.set_x1(block.volumeLine, lineStartX)
        line.set_y1(block.volumeLine, blockCenter)
        line.set_x2(block.volumeLine, lineEndX)
        line.set_y2(block.volumeLine, lineEndY)
        
        label.set_x(block.volumeLabel, lineEndX)
        label.set_y(block.volumeLabel, lineEndY)

wipeBlock(orderBlock block) =>
    if not na(block.topLine)
        line.delete(block.topLine)
    if not na(block.botLine)
        line.delete(block.botLine)
    if not na(block.bgFill)
        linefill.delete(block.bgFill)
    
    if not na(block.volumeLabel)
        label.delete(block.volumeLabel)
    
    if not na(block.volumeLine)
        line.delete(block.volumeLine)
    
    if array.size(block.boxArray) > 0
        for i = array.size(block.boxArray) - 1 to 0
            selectedBox = array.get(block.boxArray, i)
            box.delete(selectedBox)

checkObCondition(tuning)=>
    bear = false
    for i = tuning - 1 to 0
        start = tuning - 1
        if i == start
            if close[i] <= open[i]
                break
        else
            if close[i] > open[i]
                break
            
            if i == 0
                bear := true

    bull = false
    for i = tuning - 1 to 0
        start = tuning - 1
        if i == start
            if close[i] >= open[i]
                break
        else
            if close[i] < open[i]
                break
            
            if i == 0
                bull := true
    
    bullAlt = (high[tuning] - low[tuning]) > atr[tuning] * 0.8 and close[tuning] > open[tuning] and low[tuning] < low[tuning+1]
    bearAlt = (high[tuning] - low[tuning]) > atr[tuning] * 0.8 and close[tuning] < open[tuning] and high[tuning] > high[tuning+1]
    
    [bear or bearAlt, bull or bullAlt]

inWindowRange = windowsis ? bar_index > (last_bar_index - mswindow) : true
processBar = inWindowRange or not windowsis

if barstate.isfirst
    if bullBlocks.size() > 0
        for i = bullBlocks.size() - 1 to 0
            block = bullBlocks.get(i)
            wipeBlock(block)
    
    if bearBlocks.size() > 0
        for i = bearBlocks.size() - 1 to 0
            block = bearBlocks.get(i)
            wipeBlock(block)
    
    bullBlocks.clear()
    bearBlocks.clear()

if processBar
    [is_bearish, is_bullish] = checkObCondition(obLookback)
    
    if barstate.isconfirmed
        if is_bullish
            new_bull := true
            
            topValue = high[obLookback - 1]
            botValue = obmode == "Breadth" ? 
               (low[obLookback - 1] + atr * 1) > high[obLookback - 1] ? 
                  high[obLookback - 1] : (low[obLookback - 1] + atr * 1) : 
               low[obLookback - 1]
                
            leftTime = time[obLookback - 1]
            
            createNewBlock = true
            if bullBlocks.size() > 0
                for i = bullBlocks.size() - 1 to 0
                    block = bullBlocks.get(i)
                    if math.max(block.botValue, botValue) <= math.min(block.topValue, topValue)
                        wipeBlock(block)
                        bullBlocks.remove(i)
                        createNewBlock := true
            
            if createNewBlock
                orderVolume = volume[obLookback - 1]
                
                newBlock = orderBlock.new(
                     array.new_box(), 
                     array.new_float(amountOfBoxes, 0), 
                     topValue,        
                     botValue,        
                     leftTime,        
                     time,            
                     "Bull",          
                     orderVolume,     
                     na,              
                     na,              
                     false,           
                     na,              
                     na,              
                     na)              
                
                [topLine, botLine, bgFill] = generateBorderLines(newBlock, topValue, botValue)
                newBlock.topLine := topLine
                newBlock.botLine := botLine
                newBlock.bgFill := bgFill
                
                [boxArray, volumeArray, totalVolume] = generateVolumeBoxes(newBlock, orderVolume)
                newBlock.boxArray := boxArray
                newBlock.boxVolumes := volumeArray
                newBlock.totalVolume := totalVolume
                
                if showVolume
                    blockCenter = (topValue + botValue) / 2
                    lineStartX = leftTime + math.round((time - leftTime) * 0.95)
                    lineEndX = lineStartX + math.round((time - leftTime) * 0.2)
                    lineEndY = blockCenter + (topValue - botValue) * 0.3
                    
                    newBlock.volumeLine := line.new(
                         x1 = lineStartX,
                         y1 = blockCenter,
                         x2 = lineEndX,
                         y2 = lineEndY,
                         xloc = xloc.bar_time,
                          extend = extend.none,
                         color = color.new(volumeTextColor, 20),
                         style = line.style_solid,
                         width = 1)
                    
                    formattedVolume = formatVolume(orderVolume) + " " + syminfo.basecurrency
                    newBlock.volumeLabel := label.new(
                         x = lineEndX,
                         y = lineEndY,
                         text = formattedVolume,
                         textcolor = volumeTextColor,
                         style = label.style_none,
                         xloc = xloc.bar_time,
                         size = size.normal)
                
                array.push(bullBlocks, newBlock)
                last_bull_volume := orderVolume
        
        if is_bearish
            new_bear := true
            
            topValue = obmode == "Breadth" ? 
               (high[obLookback - 1] - atr * 1) < low[obLookback - 1] ? 
                  low[obLookback - 1] : (high[obLookback - 1] - atr * 1) : 
               high[obLookback - 1]
                
            botValue = low[obLookback - 1]
            leftTime = time[obLookback - 1]
            
            createNewBlock = true
            if bearBlocks.size() > 0
                for i = bearBlocks.size() - 1 to 0
                    block = bearBlocks.get(i)
                    if math.max(block.botValue, botValue) <= math.min(block.topValue, topValue)
                        wipeBlock(block)
                        bearBlocks.remove(i)
                        createNewBlock := true
            
            if createNewBlock
                orderVolume = volume[obLookback - 1]
                
                newBlock = orderBlock.new(
                     array.new_box(), 
                     array.new_float(amountOfBoxes, 0), 
                     topValue,        
                     botValue,        
                     leftTime,
                     time,            
                     "Bear",          
                     orderVolume,    
                     na,              
                     na,              
                     false,          
                     na,             
                     na,              
                     na)              
                
                [topLine, botLine, bgFill] = generateBorderLines(newBlock, topValue, botValue)
                newBlock.topLine := topLine
                newBlock.botLine := botLine
                newBlock.bgFill := bgFill
                
                [boxArray, volumeArray, totalVolume] = generateVolumeBoxes(newBlock, orderVolume)
                newBlock.boxArray := boxArray
                newBlock.boxVolumes := volumeArray
                newBlock.totalVolume := totalVolume
                
                if showVolume
                    blockCenter = (topValue + botValue) / 2
                    lineStartX = leftTime + math.round((time - leftTime) * 0.95)
                    lineEndX = lineStartX + math.round((time - leftTime) * 0.2)
                    lineEndY = blockCenter - (topValue - botValue) * 0.3
                    
                    newBlock.volumeLine := line.new(
                         x1 = lineStartX,
                         y1 = blockCenter,
                         x2 = lineEndX,
                         y2 = lineEndY,
                         xloc = xloc.bar_time,
                         extend = extend.none,
                         color = color.new(volumeTextColor, 20),
                         style = line.style_solid,
                         width = 1)
                    
                    formattedVolume = formatVolume(orderVolume) + " " + syminfo.basecurrency
                    newBlock.volumeLabel := label.new(
                         x = lineEndX,
                         y = lineEndY,
                         text = formattedVolume,
                          textcolor = volumeTextColor,
                         style = label.style_none,
                         xloc = xloc.bar_time,
                         size = size.normal)
                
                array.push(bearBlocks, newBlock)
                last_bear_volume := orderVolume
    
    if bullBlocks.size() > 0
        for i = bullBlocks.size() - 1 to 0
            if i < bullBlocks.size()
                block = bullBlocks.get(i)
                
                if not block.mitigated
                    mitigated = obmiti == "Close" ? 
                       math.min(close, open) < block.botValue : 
                       obmiti == "Wick" ? 
                          low < block.botValue : 
                          obmiti == "Avg" ? 
                             low < (block.topValue + block.botValue) / 2 : 
                             false
                                
                    if mitigated
                        block.mitigated := true
                        
                        wipeBlock(block)
                        
                        bullBlocks.remove(i)
                        continue
                
                if close <= block.topValue and close >= block.botValue
                    bull_touch := true
                
                if low <= block.botValue and close >= block.botValue
                    bull_reject := true
                
                updateBoxes(block, time)
    
    if bearBlocks.size() > 0
        for i = bearBlocks.size() - 1 to 0
            if i < bearBlocks.size()
                block = bearBlocks.get(i)
                
                if not block.mitigated
                    mitigated = obmiti == "Close" ? 
                       math.max(close, open) > block.topValue : 
                       obmiti == "Wick" ? 
                          high > block.topValue : 
                          obmiti == "Avg" ? 
                             high > (block.topValue + block.botValue) / 2 : 
                             false
                                
                    if mitigated
                        block.mitigated := true
                        
                        wipeBlock(block)
                        
                        bearBlocks.remove(i)
                        continue
                
                if close <= block.topValue and close >= block.botValue
                    bear_touch := true
                
                if high >= block.topValue and close <= block.topValue
                    bear_reject := true
                
                updateBoxes(block, time)
    
    if bullBlocks.size() > obMaxBlocks
        bullBlocks_to_remove = bullBlocks.size() - obMaxBlocks
        
        for _ = 0 to bullBlocks_to_remove - 1
            if bullBlocks.size() <= 0
                break
                
            oldestIdx = 0
            oldestTime = time_close + 999999999  
            
            for i = 0 to bullBlocks.size() - 1
                block = bullBlocks.get(i)
                if block.leftTime < oldestTime
                    oldestTime := block.leftTime
                    oldestIdx := i
            
            if oldestIdx < bullBlocks.size()
                oldBlock = bullBlocks.get(oldestIdx)
                
                wipeBlock(oldBlock)
                
                bullBlocks.remove(oldestIdx)
    
    while bearBlocks.size() > obMaxBlocks
        oldestIdx = 0
        oldestTime = time
        
        for i = 0 to bearBlocks.size() - 1
            block = bearBlocks.get(i)
            if block.leftTime < oldestTime
                oldestTime := block.leftTime
                oldestIdx := i
        
        oldBlock = bearBlocks.get(oldestIdx)
        
        wipeBlock(oldBlock)
        
        bearBlocks.remove(oldestIdx)

if barstate.islast
    float nearest_bull_distance = 1000000.0
    float nearest_bear_distance = 1000000.0
    int nearest_bull_idx = -1
    int nearest_bear_idx = -1

    if bullBlocks.size() > 0
        for i = 0 to bullBlocks.size() - 1
            block = bullBlocks.get(i)
            if close > block.botValue
                float dist = (close - block.botValue) / close * 100
                if dist < nearest_bull_distance
                    nearest_bull_distance := dist
                    nearest_bull_idx := i
    
    if bearBlocks.size() > 0
        for i = 0 to bearBlocks.size() - 1
            block = bearBlocks.get(i)
            if close < block.topValue
                float dist = (block.topValue - close) / close * 100
                if dist < nearest_bear_distance
                    nearest_bear_distance := dist
                    nearest_bear_idx := i
    
    if nearest_bull_distance < nearest_bear_distance and nearest_bull_idx >= 0
        dom_block := "Bullish"
        if nearest_bull_idx < bullBlocks.size()
            bullBlock = bullBlocks.get(nearest_bull_idx)
            block_strength := bullBlock.totalVolume / ta.sma(volume, 20)
            price_distance := nearest_bull_distance
            block_size := bullBlock.topValue - bullBlock.botValue
            size_ratio := block_size / atr
    else if nearest_bear_distance < nearest_bull_distance and nearest_bear_idx >= 0
        dom_block := "Bearish"
        if nearest_bear_idx < bearBlocks.size()
            bearBlock = bearBlocks.get(nearest_bear_idx)
            block_strength := bearBlock.totalVolume / ta.sma(volume, 20)
            price_distance := nearest_bear_distance
            block_size := bearBlock.topValue - bearBlock.botValue
            size_ratio := block_size / atr
    else
        dom_block := "None"
    
    // Create screener table
    if showScreener
        var table screener = table.new(position, 7, 3, color.new(#000000, 0), border_color=color.white, border_width=1, frame_color=color.white, frame_width=1)
        
        table.set_border_color(screener, color.white)
        table.set_border_width(screener, 1)
        
        table.clear(screener, 0, 0, 6, 2)    
        color headerBg = color.new(#000000, 0)
        color bullishBg = color.new(#008060, 0)  
        
        table.merge_cells(screener, 0, 0, 6, 0)
        table.cell(screener, 0, 0, "Order Blocks Screener" + (windowsis ? " (Window Mode)" : ""), text_color=color.white, bgcolor=headerBg, text_size=tSize)
        
        // Header row
        table.cell(screener, 0, 1, "Symbol", text_color=color.white, bgcolor=headerBg, text_size=tSize)
        table.cell(screener, 1, 1, "Timeframe", text_color=color.white, bgcolor=headerBg, text_size=tSize)
        table.cell(screener, 2, 1, "Order Block", text_color=color.white, bgcolor=headerBg, text_size=tSize)
        table.cell(screener, 3, 1, "Status", text_color=color.white, bgcolor=headerBg, text_size=tSize)
        table.cell(screener, 4, 1, "Retests", text_color=color.white, bgcolor=headerBg, text_size=tSize)
        table.cell(screener, 5, 1, "Bullish Volume", text_color=color.new(#02ffe6, 0), bgcolor=headerBg, text_size=tSize)
        table.cell(screener, 6, 1, "Bearish Volume", text_color=color.new(#ff4040, 0), bgcolor=headerBg, text_size=tSize)
        
        // Data row
        table.cell(screener, 0, 2, syminfo.ticker, text_color=color.white, bgcolor=bullishBg, text_size=tSize)
        table.cell(screener, 1, 2, timeframe.period, text_color=color.white, bgcolor=bullishBg, text_size=tSize)
        
        string blockEmoji = dom_block == "Bullish" ? "üü¢" : dom_block == "Bearish" ? "üî¥" : "‚ö™"
        string blockText = dom_block + " " + blockEmoji
        color blockTextColor = dom_block == "Bullish" ? color.rgb(255, 255, 255) : dom_block == "Bearish" ? color.red : color.gray
        table.cell(screener, 2, 2, blockText, text_color=blockTextColor, bgcolor=bullishBg, text_size=tSize)
        
        string status = ""
        if price_distance < 1.0
            status := "Near"
        else if price_distance < 3.0
            status := "Medium"
        else
            status := "Far"
        table.cell(screener, 3, 2, status, text_color=color.white, bgcolor=bullishBg, text_size=tSize)
        
        // Retests count
        string retestText = touch_count > 0 ? str.tostring(touch_count) : "None"
        table.cell(screener, 4, 2, retestText, text_color=color.white, bgcolor=bullishBg, text_size=tSize)
        
        // Volume information
        table.cell(screener, 5, 2, formatVolume(last_bull_volume), text_color=color.white, bgcolor=bullishBg, text_size=tSize)
        table.cell(screener, 6, 2, formatVolume(last_bear_volume), text_color=color.white, bgcolor=bullishBg, text_size=tSize)

// Alert conditions
alertcondition(condition = bull_touch, title = "Price Inside Bullish Max Volume Zone")
alertcondition(condition = bear_touch, title = "Price Inside Bearish Max Volume Zone")
alertcondition(condition = bull_reject, title = "Confirmed Rejection Off Bullish Max Volume Zone")
alertcondition(condition = bear_reject, title = "Confirmed Rejection Off Bearish Max Volume Zone")
alertcondition(condition = new_bull, title = "New Bullish Order Block")
alertcondition(condition = new_bear, title = "New Bearish Order Block")





















// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// ¬© melodicfish

// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// ¬© melodicfish

//@version=6
// indicator('Hermonic ABC finder', shorttitle = 'ABC', overlay = true)
// _display = display.none
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ INPUTS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
t_col_hermonic_abc = input.color(color.new(color.gray, 25), 'Trend Line Color', inline = '6', display = _display)
tl_col_hermonic_abc = input.color(color.new(color.white, 100), 'Trade Line Color', inline = '6', display = _display)
pl_colL_hermonic_abc = input.color(color.new(color.yellow, 0), 'Long Setup Line Color', inline = '5', display = _display)
pl_colS_hermonic_abc = input.color(color.new(#ff933b, 0), 'Short Setup Line Color', inline = '5', display = _display)
lab_colL_hermonic_abc = input.color(color.new(color.green, 0), 'Label Color Long Setup', inline = '4', display = _display)
lab_colS_hermonic_abc = input.color(color.new(color.red, 0), 'Label Color Short Setup', inline = '4', display = _display)
tarBox_col_hermonic_abc = input.color(color.new(color.green, 55), 'Target Box Color', inline = '7', display = _display)
stopBox_col_hermonic_abc = input.color(color.new(color.red, 55), 'Stop Box Color', inline = '7', display = _display)

barsR_hermonic_abc = 0
barsL_hermonic_abc = input.int(10, 'Bars Back', tooltip = 'Number of bars left of the Pivot', display = _display)
tl_wth_hermonic_abc = input.int(3, 'Trade Line Width', inline = '1', display = _display)
extTradeL_hermonic_abc = input.bool(false, 'Extend Trade Line to Right', display = _display)
pl_wth_hermonic_abc = input.int(6, 'ABC Line Width', inline = '1', display = _display)
show_hermonic_abc = input.bool(false, 'Show Fib Lines', display = _display)
useFibSetups_hermonic_abc = input.bool(false, 'Use Fib Based Trade Management', display = _display)

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ VARIABLES ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
var pvl_col_hermonic_abc = color.new(color.blue, 100)
var lastPivotType_hermonic_abc = 0
var phIndex_hermonic_abc = 0
var plIndex_hermonic_abc = 0
var ph_hermonic_abc = 0.0
var pl_hermonic_abc = 0.0
var highp_hermonic_abc = 0.0
var lowp_hermonic_abc = 0.0
var lastLine_hermonic_abc = line.new(0, 0, 0, 0)

var patL1L_hermonic_abc = line.new(0, 0, 0, 0, color = pl_colL_hermonic_abc, width = pl_wth_hermonic_abc)
var patL2L_hermonic_abc = line.new(0, 0, 0, 0, color = pl_colL_hermonic_abc, width = pl_wth_hermonic_abc)
var patL3L_hermonic_abc = line.new(0, 0, 0, 0, color = pl_colL_hermonic_abc, width = pl_wth_hermonic_abc)
var patL1S_hermonic_abc = line.new(0, 0, 0, 0, color = pl_colS_hermonic_abc, width = pl_wth_hermonic_abc)
var patL2S_hermonic_abc = line.new(0, 0, 0, 0, color = pl_colS_hermonic_abc, width = pl_wth_hermonic_abc)
var patL3S_hermonic_abc = line.new(0, 0, 0, 0, color = pl_colS_hermonic_abc, width = pl_wth_hermonic_abc)

var tradeLineL_hermonic_abc = line.new(0, 0, 0, 0, extend = extTradeL_hermonic_abc ? extend.right : extend.none, color = tl_col_hermonic_abc, width = tl_wth_hermonic_abc)
var tradeLineS_hermonic_abc = line.new(0, 0, 0, 0, extend = extTradeL_hermonic_abc ? extend.right : extend.none, color = tl_col_hermonic_abc, width = tl_wth_hermonic_abc)

var l0_hermonic_abc = line.new(0, 0, 0, 0, extend = extend.right, color = pvl_col_hermonic_abc, width = 1)
var l1_hermonic_abc = line.new(0, 0, 0, 0, extend = extend.right, color = pvl_col_hermonic_abc, width = 1)
var l2_hermonic_abc = line.new(0, 0, 0, 0, extend = extend.right, color = pvl_col_hermonic_abc, width = 1)
var l3_hermonic_abc = line.new(0, 0, 0, 0, extend = extend.right, color = pvl_col_hermonic_abc, width = 1)
var l4_hermonic_abc = line.new(0, 0, 0, 0, extend = extend.right, color = pvl_col_hermonic_abc, width = 1)

var lines_hermonic_abc = array.new_line(5)
array.set(lines_hermonic_abc, 0, l0_hermonic_abc)
array.set(lines_hermonic_abc, 1, l1_hermonic_abc)
array.set(lines_hermonic_abc, 2, l2_hermonic_abc)
array.set(lines_hermonic_abc, 3, l3_hermonic_abc)
array.set(lines_hermonic_abc, 4, l4_hermonic_abc)

// === PIVOTS ===
ph_hermonic_abc := ta.pivothigh(high, barsL_hermonic_abc, barsR_hermonic_abc)
pl_hermonic_abc := ta.pivotlow(low, barsL_hermonic_abc, barsR_hermonic_abc)

// Update holding variables
if pl_hermonic_abc > 0
    highp_hermonic_abc := ph_hermonic_abc
    highp_hermonic_abc
if pl_hermonic_abc > 0
    lowp_hermonic_abc := pl_hermonic_abc
    lowp_hermonic_abc

// Get the new index
phIndex_hermonic_abc := bool(ph_hermonic_abc) ? bar_index - barsR_hermonic_abc : phIndex_hermonic_abc[1]
plIndex_hermonic_abc := bool(pl_hermonic_abc) ? bar_index - barsR_hermonic_abc : plIndex_hermonic_abc[1]

// Update direction type
lastPivotType_hermonic_abc := bool(ph_hermonic_abc) ? 1 : bool(pl_hermonic_abc) ? -1 : barstate.isfirst ? 0 : lastPivotType_hermonic_abc[1]



// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ CREATE NEW LINE SET XY2 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
if lastPivotType_hermonic_abc != lastPivotType_hermonic_abc[1] and lastPivotType_hermonic_abc == 1
    line.set_x1(array.get(lines_hermonic_abc, 4), line.get_x2(array.get(lines_hermonic_abc, 1)) - 1)
    line.set_y1(array.get(lines_hermonic_abc, 4), line.get_y2(array.get(lines_hermonic_abc, 1)))
    line.set_x2(array.get(lines_hermonic_abc, 4), line.get_x2(array.get(lines_hermonic_abc, 1)) + 1)
    line.set_y2(array.get(lines_hermonic_abc, 4), line.get_y2(array.get(lines_hermonic_abc, 1)))

    lastLine_hermonic_abc := line.new(line.get_x1(lastLine_hermonic_abc), line.get_y1(lastLine_hermonic_abc), phIndex_hermonic_abc, high[bar_index - phIndex_hermonic_abc])


    line.set_x1(array.get(lines_hermonic_abc, 1), line.get_x1(lastLine_hermonic_abc))
    line.set_y1(array.get(lines_hermonic_abc, 1), line.get_y1(lastLine_hermonic_abc))
    line.set_x2(array.get(lines_hermonic_abc, 1), line.get_x1(lastLine_hermonic_abc) + 1)
    line.set_y2(array.get(lines_hermonic_abc, 1), line.get_y1(lastLine_hermonic_abc))
    line.set_x1(array.get(lines_hermonic_abc, 0), line.get_x2(lastLine_hermonic_abc))
    line.set_y1(array.get(lines_hermonic_abc, 0), line.get_y2(lastLine_hermonic_abc))
    line.set_x2(array.get(lines_hermonic_abc, 0), line.get_x2(lastLine_hermonic_abc) + 1)
    line.set_y2(array.get(lines_hermonic_abc, 0), line.get_y2(lastLine_hermonic_abc))
    line.set_color(lastLine_hermonic_abc, t_col_hermonic_abc)


// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ CREATE NEW LINE SET XY1 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
if lastPivotType_hermonic_abc != lastPivotType_hermonic_abc[1] and lastPivotType_hermonic_abc == -1
    line.set_x1(array.get(lines_hermonic_abc, 3), line.get_x2(array.get(lines_hermonic_abc, 2)) - 1)
    line.set_y1(array.get(lines_hermonic_abc, 3), line.get_y2(array.get(lines_hermonic_abc, 2)))
    line.set_x2(array.get(lines_hermonic_abc, 3), line.get_x2(array.get(lines_hermonic_abc, 2)) + 1)
    line.set_y2(array.get(lines_hermonic_abc, 3), line.get_y2(array.get(lines_hermonic_abc, 2)))

    lastLine_hermonic_abc := line.new(plIndex_hermonic_abc, low[bar_index - plIndex_hermonic_abc], line.get_x2(lastLine_hermonic_abc), line.get_y2(lastLine_hermonic_abc))


    line.set_x1(array.get(lines_hermonic_abc, 0), line.get_x1(lastLine_hermonic_abc))
    line.set_y1(array.get(lines_hermonic_abc, 0), line.get_y1(lastLine_hermonic_abc))
    line.set_x2(array.get(lines_hermonic_abc, 0), line.get_x1(lastLine_hermonic_abc) + 1)
    line.set_y2(array.get(lines_hermonic_abc, 0), line.get_y1(lastLine_hermonic_abc))
    line.set_x1(array.get(lines_hermonic_abc, 2), line.get_x2(lastLine_hermonic_abc))
    line.set_y1(array.get(lines_hermonic_abc, 2), line.get_y2(lastLine_hermonic_abc))
    line.set_x2(array.get(lines_hermonic_abc, 2), line.get_x2(lastLine_hermonic_abc) + 1)
    line.set_y2(array.get(lines_hermonic_abc, 2), line.get_y2(lastLine_hermonic_abc))
    line.set_color(lastLine_hermonic_abc, t_col_hermonic_abc)


// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ UPDATE TREND DOWN LINE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
if lastPivotType_hermonic_abc == lastPivotType_hermonic_abc[1] and lastPivotType_hermonic_abc == -1 and pl_hermonic_abc < lowp_hermonic_abc[1]
    line.set_x1(lastLine_hermonic_abc[1], plIndex_hermonic_abc)
    line.set_y1(lastLine_hermonic_abc[1], low[bar_index - plIndex_hermonic_abc])
    line.set_color(lastLine_hermonic_abc[1], t_col_hermonic_abc)

    line.set_x1(array.get(lines_hermonic_abc, 0), line.get_x1(lastLine_hermonic_abc))
    line.set_y1(array.get(lines_hermonic_abc, 0), line.get_y1(lastLine_hermonic_abc))
    line.set_x2(array.get(lines_hermonic_abc, 0), line.get_x1(lastLine_hermonic_abc) + 1)
    line.set_y2(array.get(lines_hermonic_abc, 0), line.get_y1(lastLine_hermonic_abc))


// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ UPDATE TREND UP LINE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
if lastPivotType_hermonic_abc == lastPivotType_hermonic_abc[1] and lastPivotType_hermonic_abc == 1 and ph_hermonic_abc > highp_hermonic_abc[1]
    line.set_x2(lastLine_hermonic_abc[1], phIndex_hermonic_abc)
    line.set_y2(lastLine_hermonic_abc[1], high[bar_index - phIndex_hermonic_abc])
    line.set_color(lastLine_hermonic_abc[1], t_col_hermonic_abc)

    line.set_x1(array.get(lines_hermonic_abc, 0), line.get_x2(lastLine_hermonic_abc))
    line.set_y1(array.get(lines_hermonic_abc, 0), line.get_y2(lastLine_hermonic_abc))
    line.set_x2(array.get(lines_hermonic_abc, 0), line.get_x2(lastLine_hermonic_abc) + 1)
    line.set_y2(array.get(lines_hermonic_abc, 0), line.get_y2(lastLine_hermonic_abc))


// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ LABELS AND TRADE VARIABLES ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
var s_lab_hermonic_abc = label.new(0, 0, text = 'Short Below Here', color = lab_colS_hermonic_abc, style = label.style_label_lower_right, textcolor = color.white)
var l_lab_hermonic_abc = label.new(0, 0, text = 'Long Above Here', color = lab_colL_hermonic_abc, style = label.style_label_upper_right, textcolor = color.white)
var lpl_hermonic_abc = 0.0
var spl_hermonic_abc = 0.0
var long_hermonic_abc = false
var short_hermonic_abc = false
var current_hermonic_abc = 0
var currentIndex_hermonic_abc = 0
var boxStart_hermonic_abc = 0
var boxEnd_hermonic_abc = 0
var patTop_hermonic_abc = 0.0
var patBottom_hermonic_abc = 0.0


// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ DRAW LONG ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
if barstate.isconfirmed and line.get_y1(array.get(lines_hermonic_abc, 3)) > line.get_y1(array.get(lines_hermonic_abc, 2)) and line.get_y1(array.get(lines_hermonic_abc, 2)) > line.get_y1(array.get(lines_hermonic_abc, 1)) and line.get_y1(array.get(lines_hermonic_abc, 1)) > line.get_y1(array.get(lines_hermonic_abc, 0))

    line.set_xy1(patL1L_hermonic_abc, line.get_x1(array.get(lines_hermonic_abc, 3)), line.get_y1(array.get(lines_hermonic_abc, 3)))
    line.set_xy2(patL1L_hermonic_abc, line.get_x1(array.get(lines_hermonic_abc, 1)), line.get_y1(array.get(lines_hermonic_abc, 1)))

    line.set_xy1(patL2L_hermonic_abc, line.get_x1(array.get(lines_hermonic_abc, 1)), line.get_y1(array.get(lines_hermonic_abc, 1)))
    line.set_xy2(patL2L_hermonic_abc, line.get_x1(array.get(lines_hermonic_abc, 2)), line.get_y1(array.get(lines_hermonic_abc, 2)))

    line.set_xy1(patL3L_hermonic_abc, line.get_x1(array.get(lines_hermonic_abc, 2)), line.get_y1(array.get(lines_hermonic_abc, 2)))
    line.set_xy2(patL3L_hermonic_abc, line.get_x1(array.get(lines_hermonic_abc, 0)), line.get_y1(array.get(lines_hermonic_abc, 0)))

    line.set_xy1(tradeLineL_hermonic_abc, line.get_x1(array.get(lines_hermonic_abc, 1)), line.get_y1(array.get(lines_hermonic_abc, 1)))
    line.set_xy2(tradeLineL_hermonic_abc, line.get_x1(array.get(lines_hermonic_abc, 0)) + 15, line.get_y1(array.get(lines_hermonic_abc, 1)))

    label.set_xy(l_lab_hermonic_abc, line.get_x1(tradeLineL_hermonic_abc), line.get_y1(tradeLineL_hermonic_abc))
    label.set_text(l_lab_hermonic_abc, 'Long Above ' + str.tostring(line.get_y1(tradeLineL_hermonic_abc)))

    lpl_hermonic_abc := line.get_y1(tradeLineL_hermonic_abc)

    if lpl_hermonic_abc[1] != lpl_hermonic_abc
        alert('LONG SETUP DETECTED Long Above: ' + str.tostring(line.get_y1(tradeLineL_hermonic_abc)), alert.freq_once_per_bar)
        current_hermonic_abc := 1
        currentIndex_hermonic_abc := bar_index
        currentIndex_hermonic_abc

    boxStart_hermonic_abc := line.get_x1(tradeLineL_hermonic_abc)
    boxEnd_hermonic_abc := line.get_x2(tradeLineL_hermonic_abc)
    patTop_hermonic_abc := line.get_y1(patL1L_hermonic_abc)
    patBottom_hermonic_abc := line.get_y2(patL1L_hermonic_abc) // line.get_y2(patL3L_hermonic_abc)
    patBottom_hermonic_abc




// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ DRAW SHORT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
if barstate.isconfirmed and line.get_y1(array.get(lines_hermonic_abc, 4)) < line.get_y1(array.get(lines_hermonic_abc, 2)) and line.get_y1(array.get(lines_hermonic_abc, 1)) < line.get_y1(array.get(lines_hermonic_abc, 2)) and line.get_y1(array.get(lines_hermonic_abc, 2)) < line.get_y1(array.get(lines_hermonic_abc, 0)) and line.get_y1(array.get(lines_hermonic_abc, 1)) > line.get_y1(array.get(lines_hermonic_abc, 4))

    line.set_xy1(patL1S_hermonic_abc, line.get_x1(array.get(lines_hermonic_abc, 4)), line.get_y1(array.get(lines_hermonic_abc, 4)))
    line.set_xy2(patL1S_hermonic_abc, line.get_x1(array.get(lines_hermonic_abc, 2)), line.get_y1(array.get(lines_hermonic_abc, 2)))

    line.set_xy1(patL2S_hermonic_abc, line.get_x1(array.get(lines_hermonic_abc, 2)), line.get_y1(array.get(lines_hermonic_abc, 2)))
    line.set_xy2(patL2S_hermonic_abc, line.get_x1(array.get(lines_hermonic_abc, 1)), line.get_y1(array.get(lines_hermonic_abc, 1)))

    line.set_xy1(patL3S_hermonic_abc, line.get_x1(array.get(lines_hermonic_abc, 1)), line.get_y1(array.get(lines_hermonic_abc, 1)))
    line.set_xy2(patL3S_hermonic_abc, line.get_x1(array.get(lines_hermonic_abc, 0)), line.get_y1(array.get(lines_hermonic_abc, 0)))

    line.set_xy1(tradeLineS_hermonic_abc, line.get_x1(array.get(lines_hermonic_abc, 2)), line.get_y1(array.get(lines_hermonic_abc, 2)))
    line.set_xy2(tradeLineS_hermonic_abc, line.get_x1(array.get(lines_hermonic_abc, 0)) + 15, line.get_y1(array.get(lines_hermonic_abc, 2)))

    label.set_xy(s_lab_hermonic_abc, line.get_x1(tradeLineS_hermonic_abc), line.get_y1(tradeLineS_hermonic_abc))
    label.set_text(s_lab_hermonic_abc, 'Short Below ' + str.tostring(line.get_y1(tradeLineS_hermonic_abc)))

    spl_hermonic_abc := line.get_y1(tradeLineS_hermonic_abc)

    if spl_hermonic_abc[1] != spl_hermonic_abc
        alert('SHORT SETUP DETECTED Short Below: ' + str.tostring(line.get_y1(tradeLineS_hermonic_abc)), alert.freq_once_per_bar)
        current_hermonic_abc := -1
        currentIndex_hermonic_abc := bar_index
        currentIndex_hermonic_abc

    boxStart_hermonic_abc := line.get_x1(tradeLineS_hermonic_abc)
    boxEnd_hermonic_abc := line.get_x2(tradeLineS_hermonic_abc)
    patTop_hermonic_abc := line.get_y1(patL1S_hermonic_abc)
    patBottom_hermonic_abc := line.get_y2(patL1S_hermonic_abc) // line.get_y2(patL3S_hermonic_abc)
    patBottom_hermonic_abc







// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ TABLE & TRADE MANAGEMENT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
t_percent_hermonic_abc = input(3.0, title = 'Target Percentage', inline = '3')
s_percent_hermonic_abc = input(1.5, title = 'Stop Percentage', inline = '3')
buff_hermonic_abc = input(0.005, title = 'Position Entry buffer amount', inline = '0')
isVal_hermonic_abc = input(false, title = 'Is a Value?', inline = '0', tooltip = 'If enabled the script will interpret the value entered as a dollar value. Disabled it will be interpreted as a percentage value')

var e_txt_hermonic_abc = ''
var t_txt_hermonic_abc = ''
var s_txt_hermonic_abc = ''

var target_col_hermonic_abc = color.silver
var stop_col_hermonic_abc = color.silver

// var t_hermonic_abc = table.new(position.bottom_right, 2, 3, bgcolor = #434651, frame_color = #434651, frame_width = 5, border_color = #434651, border_width = 1)
// table.cell(t_hermonic_abc, 0, 0, text = 'Entry', text_color = color.white)
// table.cell(t_hermonic_abc, 0, 1, text = 'Target', text_color = color.white)
// table.cell(t_hermonic_abc, 0, 2, text = 'Stop', text_color = color.white)

var tar_hermonic_abc = 0.0
var stop_hermonic_abc = 0.0
var y1_hermonic_abc = 0.0

if current_hermonic_abc == 1
    if isVal_hermonic_abc
        y1_hermonic_abc := line.get_y1(tradeLineL_hermonic_abc) + buff_hermonic_abc
        y1_hermonic_abc
    else
        y1_hermonic_abc := line.get_y1(tradeLineL_hermonic_abc) * (1 + buff_hermonic_abc / 100)
        y1_hermonic_abc

    e_txt_hermonic_abc := str.tostring(close > 10 ? math.round(y1_hermonic_abc, 2) : y1_hermonic_abc)
    tar_hermonic_abc := y1_hermonic_abc * (1 + t_percent_hermonic_abc / 100)
    stop_hermonic_abc := y1_hermonic_abc * (1 - s_percent_hermonic_abc / 100)
    t_txt_hermonic_abc := str.tostring(close > 10 ? math.round(tar_hermonic_abc, 2) : tar_hermonic_abc)
    s_txt_hermonic_abc := str.tostring(close > 10 ? math.round(stop_hermonic_abc, 2) : stop_hermonic_abc)
    target_col_hermonic_abc := lab_colL_hermonic_abc
    stop_col_hermonic_abc := lab_colS_hermonic_abc
    boxStart_hermonic_abc := line.get_x1(tradeLineL_hermonic_abc)
    boxEnd_hermonic_abc := line.get_x2(tradeLineL_hermonic_abc)
    boxEnd_hermonic_abc

else if current_hermonic_abc == -1
    if isVal_hermonic_abc
        y1_hermonic_abc := line.get_y1(tradeLineS_hermonic_abc) - buff_hermonic_abc
        y1_hermonic_abc
    else
        y1_hermonic_abc := line.get_y1(tradeLineS_hermonic_abc) * (1 - buff_hermonic_abc / 100)
        y1_hermonic_abc

    y1_hermonic_abc := close > 10 ? math.round(y1_hermonic_abc, 2) : y1_hermonic_abc
    e_txt_hermonic_abc := str.tostring(y1_hermonic_abc)
    stop_hermonic_abc := y1_hermonic_abc * (1 + s_percent_hermonic_abc / 100)
    tar_hermonic_abc := y1_hermonic_abc * (1 - t_percent_hermonic_abc / 100)
    s_txt_hermonic_abc := str.tostring(close > 10 ? math.round(stop_hermonic_abc, 2) : stop_hermonic_abc)
    t_txt_hermonic_abc := str.tostring(close > 10 ? math.round(tar_hermonic_abc, 2) : tar_hermonic_abc)
    target_col_hermonic_abc := lab_colS_hermonic_abc
    stop_col_hermonic_abc := lab_colL_hermonic_abc
    boxStart_hermonic_abc := line.get_x1(tradeLineS_hermonic_abc)
    boxEnd_hermonic_abc := line.get_x2(tradeLineS_hermonic_abc)
    boxEnd_hermonic_abc

// // Update table
// table.cell(t_hermonic_abc, 1, 0, text = e_txt_hermonic_abc, text_color = color.white)
// table.cell(t_hermonic_abc, 1, 1, text = t_txt_hermonic_abc, text_color = color.white)
// table.cell(t_hermonic_abc, 1, 2, text = s_txt_hermonic_abc, text_color = color.white)

// // Set cell colors
// table.cell_set_bgcolor(t_hermonic_abc, 0, 0, target_col_hermonic_abc)
// table.cell_set_bgcolor(t_hermonic_abc, 1, 0, target_col_hermonic_abc)
// table.cell_set_bgcolor(t_hermonic_abc, 0, 1, target_col_hermonic_abc)
// table.cell_set_bgcolor(t_hermonic_abc, 1, 1, target_col_hermonic_abc)
// table.cell_set_bgcolor(t_hermonic_abc, 0, 2, stop_col_hermonic_abc)
// table.cell_set_bgcolor(t_hermonic_abc, 1, 2, stop_col_hermonic_abc)

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ LINES AND BOXES ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
var tarLine_hermonic_abc = line.new(0, 0, 0, 0)
var stopLine_hermonic_abc = line.new(0, 0, 0, 0)
var entryLine_hermonic_abc = line.new(0, 0, 0, 0, color = color.white)

var targetBox_hermonic_abc = box.new(0, 0, 0, 0, bgcolor = tarBox_col_hermonic_abc, border_color = color.white)
var stopBox_hermonic_abc = box.new(0, 0, 0, 0, bgcolor = stopBox_col_hermonic_abc, border_color = color.white)

if current_hermonic_abc == 1
    box.set_left(targetBox_hermonic_abc, boxStart_hermonic_abc)
    box.set_top(targetBox_hermonic_abc, tar_hermonic_abc)
    box.set_right(targetBox_hermonic_abc, boxStart_hermonic_abc + 25)
    box.set_bottom(targetBox_hermonic_abc, y1_hermonic_abc)

    box.set_left(stopBox_hermonic_abc, boxStart_hermonic_abc)
    box.set_top(stopBox_hermonic_abc, y1_hermonic_abc)
    box.set_right(stopBox_hermonic_abc, boxStart_hermonic_abc + 25)
    box.set_bottom(stopBox_hermonic_abc, stop_hermonic_abc)

else if current_hermonic_abc == -1
    box.set_left(targetBox_hermonic_abc, boxStart_hermonic_abc)
    box.set_top(targetBox_hermonic_abc, y1_hermonic_abc)
    box.set_right(targetBox_hermonic_abc, boxStart_hermonic_abc + 25)
    box.set_bottom(targetBox_hermonic_abc, tar_hermonic_abc)

    box.set_left(stopBox_hermonic_abc, boxStart_hermonic_abc)
    box.set_top(stopBox_hermonic_abc, stop_hermonic_abc)
    box.set_right(stopBox_hermonic_abc, boxStart_hermonic_abc + 25)
    box.set_bottom(stopBox_hermonic_abc, y1_hermonic_abc)

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ FIBONACCI LINES ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
var fib1_hermonic_abc = line.new(0, 0, 0, 0, color = color.green)
var fib2_hermonic_abc = line.new(0, 0, 0, 0, color = color.blue)
var fib3_hermonic_abc = line.new(0, 0, 0, 0, color = color.orange)
var fibStopLine_hermonic_abc = line.new(0, 0, 0, 0, color = color.red)
var clear_col_hermonic_abc = color.new(color.white, 100)

Fib_hermonic_abc(ratio_hermonic_abc) =>
    valueRange_hermonic_abc = patTop_hermonic_abc - patBottom_hermonic_abc
    patTop_hermonic_abc - valueRange_hermonic_abc * ratio_hermonic_abc

line.set_xy1(fib1_hermonic_abc, boxStart_hermonic_abc, Fib_hermonic_abc(0.382))
line.set_xy2(fib1_hermonic_abc, boxStart_hermonic_abc + 25, Fib_hermonic_abc(0.382))
line.set_color(fib1_hermonic_abc, show_hermonic_abc ? color.green : clear_col_hermonic_abc)

line.set_xy1(fib2_hermonic_abc, boxStart_hermonic_abc, Fib_hermonic_abc(0.5))
line.set_xy2(fib2_hermonic_abc, boxStart_hermonic_abc + 25, Fib_hermonic_abc(0.5))
line.set_color(fib2_hermonic_abc, show_hermonic_abc ? color.blue : clear_col_hermonic_abc)

line.set_xy1(fib3_hermonic_abc, boxStart_hermonic_abc, Fib_hermonic_abc(0.618))
line.set_xy2(fib3_hermonic_abc, boxStart_hermonic_abc + 25, Fib_hermonic_abc(0.618))
line.set_color(fib3_hermonic_abc, show_hermonic_abc ? color.orange : clear_col_hermonic_abc)

line.set_xy1(fibStopLine_hermonic_abc, boxStart_hermonic_abc, patBottom_hermonic_abc - (Fib_hermonic_abc(0.618) - patBottom_hermonic_abc))
line.set_xy2(fibStopLine_hermonic_abc, boxStart_hermonic_abc + 25, patBottom_hermonic_abc - (Fib_hermonic_abc(0.618) - patBottom_hermonic_abc))
line.set_color(fibStopLine_hermonic_abc, show_hermonic_abc ? color.red : clear_col_hermonic_abc)

// Use Fib Setups if enabled
if useFibSetups_hermonic_abc
    if current_hermonic_abc == 1
        box.set_top(targetBox_hermonic_abc, line.get_y1(fib1_hermonic_abc))
        box.set_bottom(stopBox_hermonic_abc, line.get_y1(fibStopLine_hermonic_abc))
    else if current_hermonic_abc == -1
        box.set_bottom(targetBox_hermonic_abc, line.get_y1(fib1_hermonic_abc))
        box.set_top(stopBox_hermonic_abc, line.get_y1(fibStopLine_hermonic_abc))




















// This Pine Script‚Ñ¢ code is subject to the terms of the Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) https://creativecommons.org/licenses/by-nc-sa/4.0/
// ¬© UAlgo
//@version=6
//indicator(title='Wave Surge [UAlgo]', shorttitle='Wave Surge [UAlgo]', overlay=true, max_labels_count = 5, max_lines_count = 500, max_boxes_count = 500)

// Input Parameters
var string GROUP_NAME = "Wave Surge Settings"
wave_period_Surge = input(5, 'Wave Period', group=GROUP_NAME)
baseline_length = input(14, 'Baseline Length', group=GROUP_NAME)
baseline_type = input.string('ema', 'Baseline Type', options=['vwma', 'ema', 'sma', 'hma'], group=GROUP_NAME)
source_type = input.string('hlc3', 'Source Type', options=['close', 'hlc3', 'hl2'], group=GROUP_NAME)

// Threshold Settings
use_adaptive_threshold = input.bool(true, 'Use Adaptive Threshold', group=GROUP_NAME)
adaptive_period = input(500, 'Adaptive Period', group=GROUP_NAME)
sensitivity = input.float(0.001, 'Sensitivity Factor', group=GROUP_NAME)

// Volume Analysis
use_volume_analysis = input.bool(true, 'Use Volume Analysis', group=GROUP_NAME)
volume_scan_period = input.int(5, 'Volume Scan Period', group=GROUP_NAME)
volume_factor = input.float(1.0, 'Volume Factor', group=GROUP_NAME)

// Wave Calculations
waveH = ta.ema(high, wave_period_Surge)
waveL = ta.ema(low, wave_period_Surge)
waveC = ta.ema(close, wave_period_Surge)
priorWaveH = ta.valuewhen(true, waveH, 1)
priorWaveL = ta.valuewhen(true, waveL, 1)
priorWaveC = ta.valuewhen(true, waveC, 1)
deltaH = high - priorWaveH
deltaL = low - priorWaveL
deltaC = close - priorWaveC

// Volume Analysis Implementation
volume_average = ta.sma(volume, volume_scan_period)
volume_ratio = volume / ta.valuewhen(true, volume_average, 1)

// Adaptive Threshold Implementation
adaptive_level = use_adaptive_threshold ? ta.sma(hlc3, adaptive_period) * sensitivity : 0

// Signal Generation
threshold_prior = ta.valuewhen(true, adaptive_level, 1)
high_signal = deltaH > threshold_prior ? 1 : 0
low_signal = deltaL > threshold_prior ? 1 : 0
close_signal = deltaC > threshold_prior ? 1 : 0

wave_pattern = high_signal * 4 + low_signal * 2 + close_signal

final_pattern = use_volume_analysis ? volume_ratio > volume_factor ? wave_pattern : 0 : wave_pattern

// Baseline Calculation
var float baseline = na

if baseline_type == 'vwma'
    baseline := ta.vwma(source_type == 'close' ? close : source_type == 'hlc3' ? hlc3 : hl2, baseline_length)
else if baseline_type == 'ema'
    baseline := ta.ema(source_type == 'close' ? close : source_type == 'hlc3' ? hlc3 : hl2, baseline_length)
else if baseline_type == 'sma'
    baseline := ta.sma(source_type == 'close' ? close : source_type == 'hlc3' ? hlc3 : hl2, baseline_length)
else if baseline_type == 'hma'
    baseline := ta.hma(source_type == 'close' ? close : source_type == 'hlc3' ? hlc3 : hl2, baseline_length)

baseline_rising = baseline > baseline[1]
baseline_falling = baseline < baseline[1]

// Visual Signals
plotshape(final_pattern == 1 and baseline_falling ? low : na, title='Wave1', style=shape.labelup, location=location.absolute, text='ü°π', color=color(na), size=size.normal, textcolor=color.new(color.aqua, 10))
plotshape(final_pattern == 3 and baseline_rising ? high : na, title='Wave3', style=shape.labeldown, location=location.absolute, text='ü°ª', color=color(na), size=size.normal, textcolor=color.new(color.red, 10))
plotshape(final_pattern == 4 and baseline_rising ? high : na, title='Wave4', style=shape.labeldown, location=location.absolute, text='ü°ª', color=color(na), size=size.normal, textcolor=color.new(color.red, 10))
plotshape(final_pattern == 5 and baseline_falling ? low : na, title='Wave5', style=shape.labelup, location=location.absolute, text='ü°π', color=color(na), size=size.normal, textcolor=color.new(color.aqua, 10))
plotshape(final_pattern == 6 and baseline_rising ? high : na, title='Wave6', style=shape.labeldown, location=location.absolute, text='ü°ª', color=color(na), size=size.normal, textcolor=color.new(color.red, 10))

// Baseline Visualization
baseline_plot = plot(baseline, color=baseline_rising ? color.aqua : color.red, title='Baseline', linewidth=6)
price_plot = plot(hl2, display=display.none)
fill(baseline_plot, price_plot, baseline_rising ? color.new(color.aqua, 85) : color.new(color.red, 85))

// Alert Conditions
alertcondition(final_pattern == 1 and baseline_falling, title="Bullish Wave 1", message="Bullish Wave 1 Signal Detected")
alertcondition(final_pattern == 3 and baseline_rising, title="Bearish Wave 3", message="Bearish Wave 3 Signal Detected")
alertcondition(final_pattern == 4 and baseline_rising, title="Bearish Wave 4", message="Bearish Wave 4 Signal Detected")
alertcondition(final_pattern == 5 and baseline_falling, title="Bullish Wave 5", message="Bullish Wave 5 Signal Detected")
alertcondition(final_pattern == 6 and baseline_rising, title="Bearish Wave 6", message="Bearish Wave 6 Signal Detected")











fi(ki)=>'ra' 
// This work is licensed under a Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) https://creativecommons.org/licenses/by-nc-sa/4.0/
// ¬© fikira

//@version=6
//indicator('Harmonic Pattern Detector (75 patterns)', shorttitle='Hapat 75', max_labels_count=500, max_lines_count=500, max_boxes_count=500, max_polylines_count = 100, max_bars_back=5000, calc_bars_count=10000, overlay=true)
_                                                                                                                                                                                                                                                                                                       ='
                                                                                                  Settings
                                                                                                  --------                                                                                                                                                                                              '
s = '¬†¬†¬†¬†¬†'
t = '¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†'
u = '¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†'
stt        =                       input.int( 5,  'Minimum Swing Length¬†' + t , minval= 1    , maxval= 99, group='Swings', inline='1')
num        =    math.max(stt +1  , input.int(50,  'Maximum Swing Length'  + t , minval= 2    , maxval=100, group='Swings', inline='2'))

ABCD         = input.bool(true , 'ABCD'          , group='Patterns', tooltip='NOT influenced by \'Fibonacci Ratio\'')

iGart        = input.bool(false, 'GARTLEY PATTERNS' , group='Gartley', tooltip='ALL \'Gartley\' patterns can be\ninfluenced by \'Fibonacci Ratio\'\nEXCEPT \'Max Gartley\'')
Gart         = input.bool(true , 'Gartley¬†¬†¬†¬†¬†¬†'    , group='Gartley', inline='1')
GartM        = input.bool(true , 'Max Gartley'      , group='Gartley', inline='1')
AGart        = input.bool(true , 'A Gartley'        , group='Gartley', inline='1')
NNGart       = input.bool(true , 'NN Gartley'       , group='Gartley', inline='2')
NNAGart      = input.bool(true , 'NN A Gartley'     , group='Gartley', inline='2')

iBat         = input.bool(true , 'BAT PATTERNS'  , group='Bat', tooltip='ALL \'Bat\' patterns can be\ninfluenced by \'Fibonacci Ratio\'')
Bat          = input.bool(true , 'Bat¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†' , group='Bat', inline='1')
AltBat       = input.bool(true , 'Alt Bat'       , group='Bat', inline='1')
ABat         = input.bool(true , 'A Bat'         , group='Bat', inline='1')
MaxBat       = input.bool(true , 'Max Bat¬†¬†'     , group='Bat', inline='2')
NNBat        = input.bool(true , 'NN Bat'        , group='Bat', inline='2')
NNAltBat     = input.bool(true , 'NN Alt Bat'    , group='Bat', inline='2')
NNABat       = input.bool(true , 'NN A Bat'      , group='Bat', inline='3')
NNAAltBat    = input.bool(true , 'NN A Alt Bat'  , group='Bat', inline='3')

iButterfly   = input.bool(true , 'BUTTERFLY PATTERNS', group='Butterfly', tooltip='ALL \'Butterfly\' patterns can be\ninfluenced by \'Fibonacci Ratio\'\nEXCEPT \'Max Butterfly\'')
Butterfly    = input.bool(true , 'Butterfly¬†¬†¬†¬†¬†¬†¬†¬†', group='Butterfly', inline='1')
MaxButterfly = input.bool(true , 'Max Butterfly'   , group='Butterfly', inline='1')
Butterfly113 = input.bool(true , 'Butterfly 113'  , group='Butterfly', inline='2')
AButterfly   = input.bool(true , 'A Butterfly'   , group='Butterfly', inline='2')

iCrab        = input.bool(true , 'CRAB PATTERNS' , group='Crab', tooltip='ALL \'Crab\' patterns can be\ninfluenced by \'Fibonacci Ratio\'')
Crab         = input.bool(true , 'Crab'          , group='Crab', inline='1')
DeepCrab     = input.bool(true , 'Deep Crab'     , group='Crab', inline='1')
ACrab        = input.bool(true , 'A Crab'        , group='Crab', inline='1')
NNCrab       = input.bool(true , 'NN Crab'       , group='Crab', inline='1')
NNDeepCrab   = input.bool(true , 'NN Deep Crab'  , group='Crab', inline='2')
NNACrab      = input.bool(true , 'NN A Crab'     , group='Crab', inline='2')
NNADeepCrab  = input.bool(true , 'NN A Deep Crab', group='Crab', inline='2')

iShark       = input.bool(true , 'SHARK PATTERNS', group='Shark', tooltip='ALL \'Shark\' patterns can be\ninfluenced by \'Fibonacci Ratio\'')
Shark1       = input.bool(true , 'Shark 1'       , group='Shark', inline='1')
Shark1Alt    = input.bool(true , 'Shark 1 Alt'   , group='Shark', inline='1')
Shark2       = input.bool(true , 'Shark 2'       , group='Shark', inline='2')
Shark2Alt    = input.bool(true , 'Shark 2 Alt'   , group='Shark', inline='2')

iCypher      = input.bool(true , 'CYPHER PATTERNS', group='Cypher', tooltip='ALL \'Cypher\' patterns can be\ninfluenced by \'Fibonacci Ratio\'')
Cypher       = input.bool(true , 'Cypher'         , group='Cypher', inline='1')
NewCypher    = input.bool(true , 'New Cypher'     , group='Cypher', inline='1')
AntiNewCypher= input.bool(true , 'Anti New Cypher', group='Cypher', inline='1')

iLeonardo    = input.bool(true , 'LEONARDO PATTERNS', group='Leonardo', tooltip='ALL \'Leonardo\' patterns can be\ninfluenced by \'Fibonacci Ratio\'')
Leonardo     = input.bool(true , 'Leonardo'       , group='Leonardo', inline='1')
NNALeonardo  = input.bool(true , 'NN A Leonardo'  , group='Leonardo', inline='1')

i121         = input.bool(false, '121 PATTERNS'  , group='121', tooltip='NOT influenced by \'Fibonacci Ratio\'')
_121         = input.bool(true , '121'           , group='121', inline='1')
A121         = input.bool(true , 'A 121'         , group='121', inline='1')
_121BG       = input.bool(true , '121 BG'        , group='121', inline='1')

iSwan        = input.bool(false, 'SWAN PATTERNS' , group='Swan', tooltip='NOT influenced by \'Fibonacci Ratio\'')
BlackSwan    = input.bool(true , 'Black Swan'    , group='Swan', inline='1')
WhiteSwan    = input.bool(true , 'White Swan'    , group='Swan', inline='1')
NNWhiteSwan  = input.bool(true , 'NN White Swan' , group='Swan', inline='1')

iDavid       = input.bool(false, 'DAVID PATTERNS', group='David', tooltip='DAVID VM 1 & 2 are influenced\nby \'Fibonacci Ratio\'')
Henry_David  = input.bool(true , 'Henry ‚Äì David' , group='David', inline='1')
DAVIDVM1     = input.bool(true , 'DAVID VM 1'    , group='David', inline='1')
DAVIDVM2     = input.bool(true , 'DAVID VM 2'    , group='David', inline='1')

iPartizan    = input.bool(false, 'PARTIZAN PATTERNS', group='Partizan', tooltip='ALL \'Partizan\' patterns can be\ninfluenced by \'Fibonacci Ratio\'\nEXCEPT \'Partizan 2\'')
Partizan     = input.bool(true , 'Partizan¬†¬†¬†¬†¬†¬†¬†'  , group='Partizan', inline='1')
Partizan2    = input.bool(true , 'Partizan 2¬†¬†¬†'    , group='Partizan', inline='1')
Partizan2_1  = input.bool(true , 'Partizan 2.1'     , group='Partizan', inline='1')
Partizan2_2  = input.bool(true , 'Partizan 2.2'    , group='Partizan', inline='2')
Partizan2_3  = input.bool(true , 'Partizan 2.3'   , group='Partizan', inline='2')
Partizan2_4  = input.bool(true , 'Partizan 2.4'  , group='Partizan', inline='2')

iTotal       = input.bool(false, 'TOTAL PATTERNS', group='Total', tooltip='NOT influenced by \'Fibonacci Ratio\'')
total        = input.bool(true , 'Total¬†¬†¬†¬†¬†¬†¬†¬†¬†', group='Total', inline='1')
totalNN      = input.bool(true , 'Total NN¬†¬†¬†¬†'      , group='Total', inline='1')
total_1      = input.bool(true , 'Total 1'       , group='Total', inline='1')
total_2      = input.bool(true , 'Total 2¬†¬†¬†¬†¬†¬†'       , group='Total', inline='2')
total_2NN    = input.bool(true , 'Total 2 NN'    , group='Total', inline='2')
total_3      = input.bool(true , 'Total 3'       , group='Total', inline='2')
total_3NN    = input.bool(true , 'Total 3 NN'    , group='Total', inline='3')
total_4      = input.bool(true , 'Total 4'       , group='Total', inline='3')

iBG          = input.bool(false, 'BG PATTERNS'   , group= 'BG'  , tooltip='ALL \'BG\' patterns can be\ninfluenced by \'Fibonacci Ratio\'')
BG_1         = input.bool(true , 'BG 1'          , group= 'BG'  , inline='1')
BG_2         = input.bool(true , 'BG 2'          , group= 'BG'  , inline='1')
BG_3         = input.bool(true , 'BG 3'          , group= 'BG'  , inline='1')
BG_4         = input.bool(true , 'BG 4'          , group= 'BG'  , inline='1')
BG_5         = input.bool(true , 'BG 5'          , group= 'BG'  , inline='2')
BG_6         = input.bool(true , 'BG 6'          , group= 'BG'  , inline='2')
BG_7         = input.bool(true , 'BG 7'          , group= 'BG'  , inline='2')
BG_8         = input.bool(true , 'BG 8'          , group= 'BG'  , inline='2')

iStar        = input.bool(false, 'STAR PATTERNS' , group= 'Star', tooltip='ALL \'Star\' patterns can be\ninfluenced by \'Fibonacci Ratio\'')
NenStar      = input.bool(true , 'Nen Star'      , group= 'Star', inline='1')
AntiNenStar  = input.bool(true , 'Anti Nen Star' , group= 'Star', inline='1')

i3Drives     = input.bool(false, '3 DRIVES PATTERNS', group= '3 Drives', tooltip='NOT influenced by \'Fibonacci Ratio\'')
_3Drives     = input.bool(true , '3 Drives'       , group= '3 Drives'  , inline='1')
A3Drives     = input.bool(true , 'A 3 Drives'    , group= '3 Drives'  , inline='1')

iOthers      = input.bool(false, 'OTHER PATTERNS', group='Others Patterns', tooltip='NOT influenced by \'Fibonacci Ratio\'\nexcept \'COL Poruchik\'')
_5_0         = input.bool(true , '5-0¬†¬†¬†¬†¬†¬†¬†'    , group='Others Patterns', inline='1')
SeaPony      = input.bool(true , 'Sea Pony'      , group='Others Patterns', inline='1')
Navarro200   = input.bool(true , 'Navarro 200'   , group='Others Patterns', inline='1')
May_00       = input.bool(true , 'May-00'        , group='Others Patterns', inline='2')
SNORM        = input.bool(true , 'SNORM¬†¬†'       , group='Others Patterns', inline='2')
COLPoruchik  = input.bool(true , 'COL Poruchik'  , group='Others Patterns', inline='2')

margin       = input.float(0.5, 'Fibonacci Ratio'   , group='Tolerance'   , minval=0   , maxval=10, step=0.1 ) / 100
surfMult     = input.float(1.5, 'Triangle Area Ratio', group='Tolerance' , minval=1.01            , step=0.01)
labs         = input.string('Pattern Names', 'Labels' , group='Display' , options=['Pattern Names', 'Arrows', 'None' ])
pats         = input.string('Show', 'Patterns'       , group='Display'  , options=[     'Show'    ,    'Hide'        ])
oldL         = input.string('Show', 'Last Line'       , group='Display'  ,options=[     'Show'    ,    'Hide'        ])
colBl        = input.color(#089981cc,'Bullish¬†'+s+t+s, group='Style'    , inline=     'bull'                        )
colBl_       = input.color(#08998113,    ''           , group='Style'   , inline=     'bull'                       )
colBr        = input.color(#f23645cf, 'Bearish'+s+t+s  , group='Style'  , inline=     'bear'                        )
colBr_       = input.color(#f2364513,     ''            , group='Style' , inline=     'bear'                         )
textSize     = str.lower(input.string('Small', 'Text Size', group='Style',options=[  'Tiny'  ,  'Small'  ,  'Normal' ]))

dif          = num - stt
INV          = color(na) 

if not iGart
    GartM        := false, Gart        := false, AGart        := false
    NNGart       := false, NNAGart     := false

if not iBat     
    Bat          := false, AltBat      := false, ABat         := false
    MaxBat       := false, NNBat       := false, NNAltBat     := false
    NNABat       := false, NNAAltBat   := false

if not iButterfly  
    Butterfly    := false, MaxButterfly:= false, Butterfly113 := false
    AButterfly   := false

if not iCrab      
    Crab         := false, DeepCrab    := false, ACrab        := false
    NNCrab       := false, NNDeepCrab  := false, NNACrab      := false
    NNADeepCrab  := false

if not iShark       
    Shark1       := false, Shark1Alt   := false, Shark2       := false
    Shark2Alt    := false

if not iCypher      
    Cypher       := false, NewCypher   := false, AntiNewCypher:= false

if not iLeonardo    
    Leonardo     := false, NNALeonardo := false

if not i121  
    _121         := false, A121        := false, _121BG       := false

if not iSwan      
    BlackSwan    := false, WhiteSwan   := false, NNWhiteSwan  := false

if not iDavid     
    Henry_David  := false, DAVIDVM1    := false, DAVIDVM2     := false

if not iPartizan  
    Partizan     := false, Partizan2   := false, Partizan2_1  := false
    Partizan2_2  := false, Partizan2_3 := false, Partizan2_4  := false

if not iTotal    
    total        := false, totalNN     := false, total_1      := false
    total_2      := false, total_2NN   := false, total_3      := false 
    total_3NN    := false, total_4     := false 

if not iBG    
    BG_1         := false, BG_2        := false, BG_3         := false
    BG_4         := false, BG_5        := false, BG_6         := false 
    BG_7         := false, BG_8        := false 

if not iStar       
    NenStar      := false, AntiNenStar := false 

if not i3Drives       
    _3Drives     := false, A3Drives    := false 

if not iOthers    
    _5_0         := false, SeaPony     := false, Navarro200   := false
    May_00       := false, SNORM       := false, COLPoruchik  := false

_                                                                                                                                                                                                                                                                                                       ='
                                                                                                     UDTs
                                                                                                     ----                                                                                                                                                                                                '

type piv     
    int   d
    int   x 
    float y

type ZZ 
    array<piv>piv

type drawing
    array<chart.point>points
    polyline          poly 
    label             lab
    array<label>     labels
    line             oldLine

type triangle 
    string tri
    float levelL 
    float levelH 

type pat 
    string           name 
    array<triangle> triangles
_                                                                                                                                                                                                                                                                                                       ='
                                                                                                  Variables
                                                                                                  ---------                                                                                                                                                                                             '

int   n   = bar_index

var array<   ZZ    >arrayZZ   = array.new<   ZZ    >() 
var array< drawing >drawings3 = array.new< drawing >()
var array< drawing >drawings4 = array.new< drawing >()
var array<  pat    > patterns = array.new<  pat    >() 
labelCount = array.from(0)

min = 1 - margin 
max = 1 + margin

height  = ta.highest(1000) - ta.lowest (1000)

method pushPat(bool toggle, pat pat) => 
    if toggle 
        patterns.push(pat)

if barstate.isfirst 
    ABCD         .pushPat(pat.new('ABCD'           , array.from(triangle.new('bcd', 1.272    , 1.618    ), triangle.new('abc', 0.618    , 0.786    )                                                                                      )))
    _5_0         .pushPat(pat.new('5-0'            , array.from(triangle.new('bcd', 0.5  *min, 0.5  *max), triangle.new('abc', 1.618    , 2.24     ), triangle.new('xab', 1.13     , 1.618    )                                           )))
    GartM        .pushPat(pat.new('Max Gartley'    , array.from(triangle.new('bcd', 1.128    , 2.236    ), triangle.new('abc', 0.382    , 0.886    ), triangle.new('xab', 0.382    , 0.618    ), triangle.new('xad', 0.618    , 0.786    ))))
    Gart         .pushPat(pat.new('Gartley'        , array.from(triangle.new('bcd', 1.272    , 1.618    ), triangle.new('abc', 0.382    , 0.886    ), triangle.new('xab', 0.618*min, 0.618*max), triangle.new('xad', 0.786*min, 0.786*max))))
    AGart        .pushPat(pat.new('A Gartley'      , array.from(triangle.new('bcd', 1.618*min, 1.618*max), triangle.new('abc', 1.128    , 2.618    ), triangle.new('xab', 0.618    , 0.786    ), triangle.new('xad', 1.272*min, 1.272*max))))
    NNGart       .pushPat(pat.new('NN Gartley'     , array.from(triangle.new('bcd', 1.128    , 1.618    ), triangle.new('abc', 0.382    , 0.886    ), triangle.new('xab', 0.618*min, 0.618*max), triangle.new('xad', 0.786*min, 0.786*max))))
    NNAGart      .pushPat(pat.new('NN A Gartley'   , array.from(triangle.new('bcd', 1.618*min, 1.618*max), triangle.new('abc', 1.128    , 2.618    ), triangle.new('xab', 0.618    , 0.786    ), triangle.new('xad', 1.272*min, 1.272*max))))
    Bat          .pushPat(pat.new('Bat'            , array.from(triangle.new('bcd', 1.618    , 2.618    ), triangle.new('abc', 0.382    , 0.886    ), triangle.new('xab', 0.382    , 0.5      ), triangle.new('xad', 0.886*min, 0.886*max))))
    AltBat       .pushPat(pat.new('Alt Bat'        , array.from(triangle.new('bcd', 2.0      , 3.618    ), triangle.new('abc', 0.382    , 0.886    ), triangle.new('xab', 0.382*min, 0.382*max), triangle.new('xad', 1.128*min, 1.128*max))))
    ABat         .pushPat(pat.new('A Bat'          , array.from(triangle.new('bcd', 2.0      , 2.618    ), triangle.new('abc', 1.128    , 2.618    ), triangle.new('xab', 0.382    , 0.618    ), triangle.new('xad', 1.128*min, 1.128*max))))
    MaxBat       .pushPat(pat.new('Max Bat'        , array.from(triangle.new('bcd', 1.272    , 2.618    ), triangle.new('abc', 0.382    , 0.886    ), triangle.new('xab', 0.382    , 0.618    ), triangle.new('xad', 0.886*min, 0.886*max))))
    NNBat        .pushPat(pat.new('NN Bat'         , array.from(triangle.new('bcd', 1.618    , 2.618    ), triangle.new('abc', 0.382    , 0.886    ), triangle.new('xab', 0.382    , 0.5      ), triangle.new('xad', 0.886*min, 0.886*max))))
    NNAltBat     .pushPat(pat.new('NN Alt Bat'     , array.from(triangle.new('bcd', 2.0      , 4.236    ), triangle.new('abc', 0.382    , 0.886    ), triangle.new('xab', 0.382*min, 0.382*max), triangle.new('xad', 1.128*min, 1.128*max))))
    NNABat       .pushPat(pat.new('NN A Bat'       , array.from(triangle.new('bcd', 2.0      , 2.618    ), triangle.new('abc', 1.128    , 2.618    ), triangle.new('xab', 0.382    , 0.618    ), triangle.new('xad', 1.128*min, 1.128*max))))
    NNAAltBat    .pushPat(pat.new('NN A Alt Bat'   , array.from(triangle.new('bcd', 2.618*min, 2.618*max), triangle.new('abc', 1.128    , 2.618    ), triangle.new('xab', 0.236    , 0.5      ), triangle.new('xad', 0.886*min, 0.886*max))))
    Butterfly    .pushPat(pat.new('Butterfly'      , array.from(triangle.new('bcd', 1.618    , 2.618    ), triangle.new('abc', 0.382    , 0.886    ), triangle.new('xab', 0.786*min, 0.786*max), triangle.new('xad', 1.272    , 1.618    ))))
    MaxButterfly .pushPat(pat.new('Max Butterfly'  , array.from(triangle.new('bcd', 1.272    , 2.618    ), triangle.new('abc', 0.382    , 0.886    ), triangle.new('xab', 0.618    , 0.886    ), triangle.new('xad', 1.272    , 1.618    ))))
    Butterfly113 .pushPat(pat.new('Butterfly 113'  , array.from(triangle.new('bcd', 1.128    , 1.618    ), triangle.new('abc', 0.618    , 1.0      ), triangle.new('xab', 0.786    , 1.0      ), triangle.new('xad', 1.128*min, 1.128*max))))
    AButterfly   .pushPat(pat.new('A Butterfly'    , array.from(triangle.new('bcd', 1.272*min, 1.272*max), triangle.new('abc', 1.128    , 2.618    ), triangle.new('xab', 0.382    , 0.618    ), triangle.new('xad', 0.618    , 0.786    ))))
    Crab         .pushPat(pat.new('Crab'           , array.from(triangle.new('bcd', 2.24     , 3.618    ), triangle.new('abc', 0.382    , 0.886    ), triangle.new('xab', 0.382    , 0.618    ), triangle.new('xad', 1.618*min, 1.618*max))))
    DeepCrab     .pushPat(pat.new('Deep Crab'      , array.from(triangle.new('bcd', 2.618    , 3.618    ), triangle.new('abc', 0.382    , 0.886    ), triangle.new('xab', 0.886*min, 0.886*max), triangle.new('xad', 1.618*min, 1.618*max))))
    ACrab        .pushPat(pat.new('A Crab'         , array.from(triangle.new('bcd', 1.618    , 2.618    ), triangle.new('abc', 1.128    , 2.618    ), triangle.new('xab', 0.276    , 0.446    ), triangle.new('xad', 0.618*min, 0.618*max))))
    NNCrab       .pushPat(pat.new('NN Crab'        , array.from(triangle.new('bcd', 2.236    , 4.236    ), triangle.new('abc', 0.382    , 0.886    ), triangle.new('xab', 0.382    , 0.618    ), triangle.new('xad', 1.618*min, 1.618*max))))
    NNDeepCrab   .pushPat(pat.new('NN Deep Crab'   , array.from(triangle.new('bcd', 2.618    , 4.236    ), triangle.new('abc', 0.382    , 0.886    ), triangle.new('xab', 0.886*min, 0.886*max), triangle.new('xad', 1.618*min, 1.618*max))))
    NNACrab      .pushPat(pat.new('NN A Crab'      , array.from(triangle.new('bcd', 1.128    , 2.618    ), triangle.new('abc', 1.128    , 2.618    ), triangle.new('xab', 0.236    , 0.447    ), triangle.new('xad', 0.618*min, 0.618*max))))
    NNADeepCrab  .pushPat(pat.new('NN A Deep Crab' , array.from(triangle.new('bcd', 1.128*min, 1.128*max), triangle.new('abc', 1.128    , 2.618    ), triangle.new('xab', 0.236    , 0.382    ), triangle.new('xad', 0.618*min, 0.618*max))))
    Cypher       .pushPat(pat.new('Cypher'         , array.from(triangle.new('bcd', 1.272    , 2.00     ), triangle.new('abc', 1.13     , 1.414    ), triangle.new('xab', 0.382    , 0.618    ), triangle.new('xad', 0.786*min, 0.786*max))))
    NewCypher    .pushPat(pat.new('New Cypher'     , array.from(triangle.new('bcd', 1.272    , 2.00     ), triangle.new('abc', 1.414    , 2.14     ), triangle.new('xab', 0.382    , 0.618    ), triangle.new('xad', 0.786*min, 0.786*max))))
    AntiNewCypher.pushPat(pat.new('Anti New Cypher', array.from(triangle.new('bcd', 1.618    , 2.618    ), triangle.new('abc', 0.467    , 0.707    ), triangle.new('xab', 0.5      , 0.786    ), triangle.new('xad', 1.272*min, 1.272*max))))
    Shark1       .pushPat(pat.new('Shark 1'        , array.from(triangle.new('bcd', 1.618    , 2.236    ), triangle.new('abc', 1.128    , 1.618    ), triangle.new('xab', 0.382    , 0.618    ), triangle.new('xad', 0.886*min, 0.886*max))))
    Shark1Alt    .pushPat(pat.new('Shark 1 Alt'    , array.from(triangle.new('bcd', 1.618    , 2.618    ), triangle.new('abc', 0.618    , 0.886    ), triangle.new('xab', 0.446    , 0.618    ), triangle.new('xad', 1.128*min, 1.128*max))))
    Shark2       .pushPat(pat.new('Shark 2'        , array.from(triangle.new('bcd', 1.618    , 2.236    ), triangle.new('abc', 1.128    , 1.618    ), triangle.new('xab', 0.382    , 0.618    ), triangle.new('xad', 1.128*min, 1.128*max))))
    Shark2Alt    .pushPat(pat.new('Shark 2 Alt'    , array.from(triangle.new('bcd', 1.618    , 2.618    ), triangle.new('abc', 0.618    , 0.886    ), triangle.new('xab', 0.446    , 0.618    ), triangle.new('xad', 0.886*min, 0.886*max))))
    Leonardo     .pushPat(pat.new('Leonardo'       , array.from(triangle.new('bcd', 1.128    , 2.618    ), triangle.new('abc', 0.382    , 0.886    ), triangle.new('xab', 0.5*min  , 0.5*max  ), triangle.new('xad', 0.786*min, 0.786*max))))
    NNALeonardo  .pushPat(pat.new('NN A Leonardo'  , array.from(triangle.new('bcd', 2.0*min  , 2.0*max  ), triangle.new('abc', 1.128    , 2.618    ), triangle.new('xab', 0.382    , 0.886    ), triangle.new('xad', 1.272*min, 1.272*max))))
    NenStar      .pushPat(pat.new('Nen Star'       , array.from(triangle.new('bcd', 1.272    , 2.0      ), triangle.new('abc', 1.414    , 2.14     ), triangle.new('xab', 0.382    , 0.618    ), triangle.new('xad', 1.272*min, 1.272*max))))
    AntiNenStar  .pushPat(pat.new('Anti Nen Star'  , array.from(triangle.new('bcd', 1.618    , 2.618    ), triangle.new('abc', 0.467    , 0.707    ), triangle.new('xab', 0.5      , 0.786    ), triangle.new('xad', 0.786*min, 0.786*max))))
    _3Drives     .pushPat(pat.new('3 Drives'       , array.from(triangle.new('bcd', 1.272    , 1.618    ), triangle.new('abc', 0.618    , 0.786    ), triangle.new('xab', 1.272    , 1.618    ), triangle.new('xad', 1.618    , 2.618    ))))
    A3Drives     .pushPat(pat.new('A 3 Drives'     , array.from(triangle.new('bcd', 0.618    , 0.786    ), triangle.new('abc', 1.272    , 1.618    ), triangle.new('xab', 0.618    , 0.786    ), triangle.new('xad', 0.13     , 0.886    ))))
    _121         .pushPat(pat.new('121'            , array.from(triangle.new('bcd', 0.382    , 0.786    ), triangle.new('abc', 1.128    , 3.618    ), triangle.new('xab', 0.5      , 0.786    ), triangle.new('xad', 0.382    , 0.786    ))))
    A121         .pushPat(pat.new('A 121'          , array.from(triangle.new('bcd', 1.272    , 2.0      ), triangle.new('abc', 0.5      , 0.786    ), triangle.new('xab', 1.272    , 2.0      ), triangle.new('xad', 1.272    , 2.618    ))))
    _121BG       .pushPat(pat.new('121 BG'         , array.from(triangle.new('bcd', 0.618    , 0.707    ), triangle.new('abc', 1.128    , 1.733    ), triangle.new('xab', 0.5      , 0.577    ), triangle.new('xad', 0.447    , 0.786    ))))
    BlackSwan    .pushPat(pat.new('Black Swan'     , array.from(triangle.new('bcd', 1.128    , 2.0      ), triangle.new('abc', 0.236    , 0.5      ), triangle.new('xab', 1.382    , 2.618    ), triangle.new('xad', 1.128    , 2.618    ))))
    WhiteSwan    .pushPat(pat.new('White Swan'     , array.from(triangle.new('bcd', 0.5      , 0.886    ), triangle.new('abc', 2.0      , 4.237    ), triangle.new('xab', 0.382    , 0.786    ), triangle.new('xad', 0.238    , 0.886    ))))
    NNWhiteSwan  .pushPat(pat.new('NN White Swan'  , array.from(triangle.new('bcd', 0.5      , 0.886    ), triangle.new('abc', 2.0      , 4.236    ), triangle.new('xab', 0.382    , 0.724    ), triangle.new('xad', 0.382    , 0.886    ))))
    SeaPony      .pushPat(pat.new('Sea Pony'       , array.from(triangle.new('bcd', 1.618    , 2.618    ), triangle.new('abc', 0.382    , 0.5      ), triangle.new('xab', 0.128    , 3.618    ), triangle.new('xad', 0.618    , 3.618    ))))
    Navarro200   .pushPat(pat.new('Navarro 200'    , array.from(triangle.new('bcd', 0.886    , 3.618    ), triangle.new('abc', 0.886    , 1.128    ), triangle.new('xab', 0.382    , 0.786    ), triangle.new('xad', 0.886    , 1.128    ))))
    May_00       .pushPat(pat.new('May-00'         , array.from(triangle.new('bcd', 0.5      , 0.618    ), triangle.new('abc', 1.618    , 2.236    ), triangle.new('xab', 1.128    , 1.618    ), triangle.new('xad', 0.5      , 0.618    ))))
    SNORM        .pushPat(pat.new('SNORM'          , array.from(triangle.new('bcd', 0.9      , 1.1      ), triangle.new('abc', 0.9      , 1.1      ), triangle.new('xab', 0.9      , 1.1      ), triangle.new('xad', 0.618    , 1.618    ))))
    COLPoruchik  .pushPat(pat.new('COL Poruchik'   , array.from(triangle.new('bcd', 1.0  *min, 1.0  *max), triangle.new('abc', 0.382    , 2.618    ), triangle.new('xab', 0.128    , 3.618    ), triangle.new('xad', 0.618    , 3.618    ))))
    Henry_David  .pushPat(pat.new('Henry ‚Äì David'  , array.from(triangle.new('bcd', 0.618    , 0.886    ), triangle.new('abc', 0.44     , 0.618    ), triangle.new('xab', 0.128    , 2.0      ), triangle.new('xad', 0.618    , 1.618    ))))
    DAVIDVM1     .pushPat(pat.new('DAVID VM 1'     , array.from(triangle.new('bcd', 1.618    , 1.618    ), triangle.new('abc', 0.382*min, 0.382*max), triangle.new('xab', 0.128    , 1.618    ), triangle.new('xad', 0.618    , 3.618    ))))
    DAVIDVM2     .pushPat(pat.new('DAVID VM 2'     , array.from(triangle.new('bcd', 1.618    , 1.618    ), triangle.new('abc', 0.382*min, 0.382*max), triangle.new('xab', 1.618    , 3.618    ), triangle.new('xad', 0.618    , 7.618    ))))
    Partizan     .pushPat(pat.new('Partizan'       , array.from(triangle.new('bcd', 1.618*min, 1.618*max), triangle.new('abc', 0.382*min, 0.382*max), triangle.new('xab', 0.128    , 3.618    ), triangle.new('xad', 0.618    , 3.618    ))))
    Partizan2    .pushPat(pat.new('Partizan 2'     , array.from(triangle.new('bcd', 1.618    , 2.236    ), triangle.new('abc', 1.128    , 1.618    ), triangle.new('xab', 0.128    , 3.618    ), triangle.new('xad', 1.618    , 3.618    ))))
    Partizan2_1  .pushPat(pat.new('Partizan 2.1'   , array.from(triangle.new('bcd', 1.618*min, 1.618*max), triangle.new('abc', 1.128*min, 1.128*max), triangle.new('xab', 0.128    , 3.618    ), triangle.new('xad', 0.618    , 3.618    ))))
    Partizan2_2  .pushPat(pat.new('Partizan 2.2'   , array.from(triangle.new('bcd', 2.236*min, 2.236*max), triangle.new('abc', 1.128*min, 1.128*max), triangle.new('xab', 0.128    , 3.618    ), triangle.new('xad', 0.618    , 3.618    ))))
    Partizan2_3  .pushPat(pat.new('Partizan 2.3'   , array.from(triangle.new('bcd', 1.618*min, 1.618*max), triangle.new('abc', 0.618    , 1.618    ), triangle.new('xab', 0.128    , 3.618    ), triangle.new('xad', 0.618    , 3.618    ))))
    Partizan2_4  .pushPat(pat.new('Partizan 2.4'   , array.from(triangle.new('bcd', 2.236*min, 2.236*max), triangle.new('abc', 1.618*min, 1.618*max), triangle.new('xab', 0.128    , 3.618    ), triangle.new('xad', 0.618    , 3.618    ))))
    total        .pushPat(pat.new('TOTAL'          , array.from(triangle.new('bcd', 1.272    , 3.618    ), triangle.new('abc', 0.382    , 2.618    ), triangle.new('xab', 0.276    , 0.786    ), triangle.new('xad', 0.618    , 1.618    ))))
    totalNN      .pushPat(pat.new('TOTAL NN'       , array.from(triangle.new('bcd', 1.272    , 4.236    ), triangle.new('abc', 0.382    , 2.618    ), triangle.new('xab', 0.236    , 0.786    ), triangle.new('xad', 0.618    , 1.618    ))))
    total_1      .pushPat(pat.new('TOTAL 1'        , array.from(triangle.new('bcd', 1.272    , 2.618    ), triangle.new('abc', 0.382    , 0.886    ), triangle.new('xab', 0.382    , 0.786    ), triangle.new('xad', 0.786    , 0.886    ))))
    total_2      .pushPat(pat.new('TOTAL 2'        , array.from(triangle.new('bcd', 1.618    , 3.618    ), triangle.new('abc', 0.382    , 0.886    ), triangle.new('xab', 0.382    , 0.786    ), triangle.new('xad', 1.128    , 1.618    ))))
    total_2NN    .pushPat(pat.new('TOTNN 2NN'      , array.from(triangle.new('bcd', 1.618    , 4.236    ), triangle.new('abc', 0.382    , 0.886    ), triangle.new('xab', 0.382    , 0.786    ), triangle.new('xad', 1.128    , 1.618    ))))
    total_3      .pushPat(pat.new('TOTAL 3'        , array.from(triangle.new('bcd', 1.272    , 2.618    ), triangle.new('abc', 1.128    , 2.618    ), triangle.new('xab', 0.276    , 0.618    ), triangle.new('xad', 0.618    , 0.886    ))))
    total_3NN    .pushPat(pat.new('TOTNN 3NN'      , array.from(triangle.new('bcd', 1.272    , 2.618    ), triangle.new('abc', 1.128    , 2.618    ), triangle.new('xab', 0.236    , 0.618    ), triangle.new('xad', 0.618    , 0.886    ))))
    total_4      .pushPat(pat.new('TOTAL 4'        , array.from(triangle.new('bcd', 1.618    , 2.618    ), triangle.new('abc', 1.128    , 2.618    ), triangle.new('xab', 0.382    , 0.786    ), triangle.new('xad', 1.128    , 1.272    ))))
    BG_1         .pushPat(pat.new('BG 1'           , array.from(triangle.new('bcd', 2.618*min, 2.618*max), triangle.new('abc', 0.382*min, 0.382*max), triangle.new('xab', 0.128    , 0.886    ), triangle.new('xad', 1.0  *min, 1.0  *max))))
    BG_2         .pushPat(pat.new('BG 2'           , array.from(triangle.new('bcd', 2.237*min, 2.237*max), triangle.new('abc', 0.447*min, 0.447*max), triangle.new('xab', 0.128    , 0.886    ), triangle.new('xad', 1.0  *min, 1.0  *max))))
    BG_3         .pushPat(pat.new('BG 3'           , array.from(triangle.new('bcd', 2.0  *min, 2.0  *max), triangle.new('abc', 0.5  *min, 0.5  *max), triangle.new('xab', 0.128    , 0.886    ), triangle.new('xad', 1.0  *min, 1.0  *max))))
    BG_4         .pushPat(pat.new('BG 4'           , array.from(triangle.new('bcd', 1.618*min, 1.618*max), triangle.new('abc', 0.618*min, 0.618*max), triangle.new('xab', 0.128    , 0.886    ), triangle.new('xad', 1.0  *min, 1.0  *max))))
    BG_5         .pushPat(pat.new('BG 5'           , array.from(triangle.new('bcd', 1.414*min, 1.414*max), triangle.new('abc', 0.707*min, 0.707*max), triangle.new('xab', 0.128    , 0.886    ), triangle.new('xad', 1.0  *min, 1.0  *max))))
    BG_6         .pushPat(pat.new('BG 6'           , array.from(triangle.new('bcd', 1.272*min, 1.272*max), triangle.new('abc', 0.786*min, 0.786*max), triangle.new('xab', 0.128    , 0.886    ), triangle.new('xad', 1.0  *min, 1.0  *max))))
    BG_7         .pushPat(pat.new('BG 7'           , array.from(triangle.new('bcd', 1.171*min, 1.171*max), triangle.new('abc', 0.854*min, 0.854*max), triangle.new('xab', 0.128    , 0.886    ), triangle.new('xad', 1.0  *min, 1.0  *max))))
    BG_8         .pushPat(pat.new('BG 8'           , array.from(triangle.new('bcd', 1.128*min, 1.128*max), triangle.new('abc', 0.886*min, 0.886*max), triangle.new('xab', 0.128    , 0.886    ), triangle.new('xad', 1.0  *min, 1.0  *max))))

if barstate.isfirst 
    //First bar
    line.new(n, close, n, close + syminfo.mintick, extend=extend.both)
    for i = 0 to dif -1
        ZZnew = ZZ.new(array.new<piv>())
        for j = 0 to 5 
            ZZnew.piv.unshift(piv.new(0, 0, high))

        arrayZZ.unshift(ZZnew) 
_                                                                                                                                                                                                                                                                                                       ='
                                                                                                  Methods
                                                                                                  -------                                                                                                                                                                                               '

method in_out(ZZ aZZ, int d, int Dx, float Dy) => aZZ.piv.unshift(piv.new(d, Dx, Dy)), aZZ.piv.pop()

method n(float v) => not na(v) 

method lab(array<triangle>triangles, int Bx, float By, int Cx, float Cy, int Dx, float Dy, color col) => 
    labels = array.new<label>() 
    sz     = triangles.size() 
    switch sz
        2 => 
            labels.push(label.new(Cx, Cy, style=label.style_label_center, text='\n\nbla', textcolor=INV, color=INV, size=size.normal, tooltip = str.format("C = [{0} - {1}] of A-B", triangles.get(1).levelL, triangles.get(1).levelH)))
            labels.push(label.new(Dx, Dy, style=label.style_label_center, text='\n\nbla', textcolor=INV, color=INV, size=size.normal, tooltip = str.format("D = [{0} - {1}] of B-C", triangles.get(0).levelL, triangles.get(0).levelH)))

        => 
            Dtxt     =    sz == 3    ? str.format("D = [{0} - {1}] of B-C"                                                                          , triangles.get(0).levelL, triangles.get(0).levelH) 
                                     : str.format("D = [{0} - {1}] of B-C\nD = [{2} - {3}] of X-A", triangles.get(0).levelL, triangles.get(0).levelH, triangles.get(3).levelL, triangles.get(3).levelH)
            labels.push(label.new(Bx, By, style=label.style_label_center, text='\n\nbla', textcolor=INV, color=INV, size=size.normal, tooltip = str.format("B = [{0} - {1}] of X-A", triangles.get(2).levelL, triangles.get(2).levelH)))
            labels.push(label.new(Cx, Cy, style=label.style_label_center, text='\n\nbla', textcolor=INV, color=INV, size=size.normal, tooltip = str.format("C = [{0} - {1}] of A-B", triangles.get(1).levelL, triangles.get(1).levelH)))
            labels.push(label.new(Dx, Dy, style=label.style_label_center, text='\n\nbla', textcolor=INV, color=INV, size=size.normal, tooltip =                                      Dtxt                                             ))
    labels 

method ret(float levelL, float levelH, float By, float Cy, float Dy) => 
    isValid = switch Cy > By 
        true => distance = Cy - By, Dy >= Cy - distance * levelH and Dy <= Cy - distance * levelL
        =>      distance = By - Cy, Dy >= Cy + distance * levelL and Dy <= Cy + distance * levelH

method zigzag(array<ZZ>arrZZ, int index, int left, int right) =>
    aZZ      = arrZZ.get(index)
    ph       = ta.pivothigh(left, right)
    pl       = ta.pivotlow (left, right)

    if ph.n()
        piv  = aZZ.piv.first()
        dr_  = piv.d 
        Cx_  = piv.x 
        Cy_  = piv.y 
        Dx_  = n  - right
        Dy_  = high[right]
        //
        if Dy_ > Cy_
            if dr_ <  1  // if previous point was a pl, add, and change direction ( 1)
                aZZ.in_out( 1, Dx_, Dy_)
            else
                if dr_ ==  1 and ph > Cy_
                    piv.x := Dx_, piv.y := Dy_   

    if pl.n() 
        piv  = aZZ.piv.first()
        dr_  = piv.d 
        Cx_  = piv.x 
        Cy_  = piv.y 
        Dx_  = n  - right
        Dy_  = low [right]
        //
        if Dy_ < Cy_
            if dr_ > -1  // if previous point was a ph, add, and change direction (-1)
                aZZ.in_out(-1, Dx_, Dy_)
            else
                if dr_ == -1 and pl < Cy_ 
                    piv.x := Dx_, piv.y := Dy_    

    Y = aZZ.piv.get(5), Yx = Y.x, Yy = Y.y
    X = aZZ.piv.get(4), Xx = X.x, Xy = X.y
    A = aZZ.piv.get(3), Ax = A.x, Ay = A.y
    B = aZZ.piv.get(2), Bx = B.x, By = B.y
    C = aZZ.piv.get(1), Cx = C.x, Cy = C.y
    D = aZZ.piv.get(0), Dx = D.x, Dy = D.y, dir = D.d 

    float opp1 = na    
    float opp2 = na

    if pl.n() or ph.n()
        indices = array.new<int>()
        indices_= array.new<int>()

        col = Dy > Cy ? colBr : colBl
        col_= Dy > Cy ? colBr_: colBl_

        //STEP 1
        for [i, pattern] in patterns
            tri = pattern.triangles
            if tri.get(0).levelL.ret(tri.get(0).levelH, By, Cy, Dy) 
                indices.push(i)
        
        //STEP 2
        if indices.size() > 0 
            for i in indices
                tri = patterns.get(i).triangles
                if tri.get(1).levelL.ret(tri.get(1).levelH, Ay, By, Cy) 
                    if tri.size() == 2 

                        //yDiffA-B normalized ~ 1000 (Height)
                        sideA = math.sqrt( math.pow(Bx-Ax, 2) + math.pow(1000 / (height / (By-Ay)), 2))
                        sideB = math.sqrt( math.pow(Cx-Bx, 2) + math.pow(1000 / (height / (Cy-By)), 2))
                        sideC = math.sqrt( math.pow(Cx-Ax, 2) + math.pow(1000 / (height / (Cy-Ay)), 2))
                        sideD = math.sqrt( math.pow(Dx-Bx, 2) + math.pow(1000 / (height / (Dy-By)), 2))
                        sideE = math.sqrt( math.pow(Dx-Cx, 2) + math.pow(1000 / (height / (Dy-Cy)), 2))

                        //Heron's formula
                        s1 = (sideA + sideB + sideC) / 2
                        s2 = (sideB + sideD + sideE) / 2
                        area1 = math.sqrt( s1 * (s1 - sideA) * (s1 - sideB) * (s1 - sideC) )
                        area2 = math.sqrt( s2 * (s2 - sideB) * (s2 - sideD) * (s2 - sideE) )

                        if math.max(area1, area2) <= math.min(area1, area2) * surfMult //When good Triangle Ratio
                            isValid = true
                            size3 = drawings3.size()
                            if size3 > 0 
                                for j = 0 to size3 -1
                                    get = drawings3.get(j)
                                    drawDx = get.points.get(4).index                                    
                                    drawDy = get.points.get(4).price       
                                    //If old pattern is too far, exit loop                                  
                                    if drawDx < Cx 
                                        break 
                                    else 
                                        if   Cx == get.points.get(3).index 
                                         and Bx == get.points.get(2).index                                     
                                         and Ax == get.points.get(1).index 
                                            //No new pattern will be added
                                            isValid := false 
                                            //If this drawing is exectly the same than the old one, exit loop
                                            if Dx == drawDx 
                                                break 
                                            else 
                                                //If this drawing is the same than the old one, except point D, update pattern
                                                get.poly.delete()   
                                                if labs != 'None'        
                                                    space = '' 
                                                    count = labelCount.first()
                                                    //If there is already a label, add \n (top/bottom depending on Dy > Cy)
                                                    if count > 0 
                                                        for c = 1 to count
                                                            space += '\n'                             
                                                        get.lab.set_text((Dy > Cy ? '' : space) + get.lab.get_text() + (Dy > Cy ? space : ''))
                                                    get.lab.set_xy(Dx, Dy)
                                                    labelCount.set(0, labelCount.first() +1)
                                                if oldL == 'Show'
                                                    //If old dashed line present, update D
                                                    if not na(get.oldLine)
                                                        get.oldLine.set_xy2(drawDx, drawDy)
                                                    //Else, make new line
                                                    else
                                                        get.oldLine := line.new(Cx, Cy, drawDx, drawDy, color= color.new(col, 50), style=line.style_dashed) 

                                                getPoints4 = get.points.get(4)
                                                getPoints4.index := Dx 
                                                getPoints4.price := Dy 

                                                get.poly := polyline.new(get.points
                                                 , line_color = col
                                                 , fill_color = col_
                                                 )
                            //New pattern
                            if isValid and Dx != 0
                                pt = drawing.new()
                                pt.points := array.from(
                                   chart.point.from_index(Cx, Cy)
                                 , chart.point.from_index(Ax, Ay)
                                 , chart.point.from_index(Bx, By)
                                 , chart.point.from_index(Cx, Cy)
                                 , chart.point.from_index(Dx, Dy)                         
                                 , chart.point.from_index(Bx, By)
                                 )
                                pt.labels :=  tri.lab(Bx, By, Cx, Cy, Dx, Dy, col)
                                if labs != 'None'
                                    space = '' 
                                    count = labelCount.first()
                                    if count > 0 
                                        for c = 1 to count
                                            space += '\n'
                                    pt.lab  := label.new(Dx, Dy, style = Dy > Cy ? label.style_label_down : label.style_label_up, color=INV
                                     , size = textSize, textcolor = col, text= labs == 'Pattern Names' ? patterns.get(i).name + (Dy > Cy ? space : '') : Dy > Cy ? '‚ñº' : '‚ñ≤')
                                    labelCount.set(0, count +1)

                                if pats == 'Show'
                                    pt.poly := polyline.new(pt.points
                                     , line_color = col
                                     , fill_color = col_
                                     )
                                drawings3.unshift(pt)
                                //triangle array size 2 -> stop at STEP 2
                                0
                    else 
                        indices_.push(i)
                        0
        //STEP 3
        if indices_.size() > 0 
            for i in indices_
                tri = patterns.get(i).triangles
                if tri.get(2).levelL.ret(tri.get(2).levelH, Xy, Ay, By) 

                    //yDiffA-B normalized ~ 1000 (Height)
                    sideA = math.sqrt( math.pow(Bx-Ax, 2) + math.pow(1000 / (height / (By-Ay)), 2))
                    sideB = math.sqrt( math.pow(Bx-Xx, 2) + math.pow(1000 / (height / (By-Xy)), 2))
                    sideC = math.sqrt( math.pow(Ax-Xx, 2) + math.pow(1000 / (height / (Ay-Xy)), 2))
                    sideD = math.sqrt( math.pow(Dx-Bx, 2) + math.pow(1000 / (height / (Dy-By)), 2))
                    sideE = math.sqrt( math.pow(Cx-Bx, 2) + math.pow(1000 / (height / (Cy-By)), 2))
                    sideF = math.sqrt( math.pow(Dx-Cx, 2) + math.pow(1000 / (height / (Dy-Cy)), 2))

                    //Heron's formula
                    s1 = (sideA + sideB + sideC) / 2
                    s2 = (sideD + sideE + sideF) / 2
                    area1 = math.sqrt( s1 * (s1 - sideA) * (s1 - sideB) * (s1 - sideC) )
                    area2 = math.sqrt( s2 * (s2 - sideD) * (s2 - sideE) * (s2 - sideF) )

                    if math.max(area1, area2) <= math.min(area1, area2) * surfMult //When good Triangle Ratio
                        if tri.size() == 3
                            isValid = true
                            size4 = drawings4.size()
                            if size4 > 0 
                                for j = 0 to size4 -1
                                    get = drawings4.get(j)
                                    drawDx = get.points.get(4).index                                    
                                    drawDy = get.points.get(4).price       
                                    //If old pattern is too far, exit loop                         
                                    if drawDx < Cx 
                                        break 
                                    else 
                                        if   Cx == get.points.get(5).index 
                                         and Bx == get.points.get(3).index                                     
                                         and Ax == get.points.get(2).index 
                                         and Xx == get.points.get(1).index 
                                            //No new pattern will be added
                                            isValid := false 
                                            //If this drawing is exectly the same than the old one, exit loop
                                            if Dx == drawDx 
                                                break 
                                            else 
                                                //If this drawing is the same than the old one, except point D, update pattern
                                                get.poly.delete()   
                                                if labs != 'None'              
                                                    space = '' 
                                                    count = labelCount.first()
                                                    if count > 0 
                                                        for c = 1 to count
                                                            space += '\n'                             
                                                        get.lab.set_text((Dy > Cy ? '' : space) + get.lab.get_text() + (Dy > Cy ? space : ''))                           
                                                    get.lab.set_xy(Dx, Dy)
                                                    labelCount.set(0, labelCount.first() +1)
                                                if oldL == 'Show'
                                                    //If old dashed line present, update D
                                                    if not na(get.oldLine)
                                                        get.oldLine.set_xy2(drawDx, drawDy)
                                                    //Else, make new line
                                                    else
                                                        get.oldLine := line.new(Cx, Cy, drawDx, drawDy, color= color.new(col, 50), style=line.style_dashed) 

                                                getPoints4 = get.points.get(4)
                                                getPoints4.index := Dx 
                                                getPoints4.price := Dy 

                                                get.poly := polyline.new(get.points
                                                 , line_color = col
                                                 , fill_color = col_
                                                 )
                            //New pattern
                            if isValid and Dx != 0
                                pt = drawing.new()
                                pt.points := array.from(
                                   chart.point.from_index(Bx, By)
                                 , chart.point.from_index(Xx, Xy)
                                 , chart.point.from_index(Ax, Ay)
                                 , chart.point.from_index(Bx, By)
                                 , chart.point.from_index(Dx, Dy)                         
                                 , chart.point.from_index(Cx, Cy)                                 
                                 , chart.point.from_index(Bx, By)
                                 )
                                pt.labels :=  tri.lab(Bx, By, Cx, Cy, Dx, Dy, col)
                                if labs != 'None'
                                    space = '' 
                                    count = labelCount.first()
                                    if count > 0 
                                        for c = 1 to count
                                            space += '\n'
                                    pt.lab  := label.new(Dx, Dy, style = Dy > Cy ? label.style_label_down : label.style_label_up, color=INV                                
                                     , size = textSize, textcolor = col, text= labs == 'Pattern Names' ? patterns.get(i).name + (Dy > Cy ? space : '') : Dy > Cy ? '‚ñº' : '‚ñ≤')
                                    labelCount.set(0, count +1)

                                if pats == 'Show'
                                    pt.poly := polyline.new(pt.points
                                     , line_color = col
                                     , fill_color = col_
                                     )
                                drawings4.unshift(pt)
                        else 
                            if tri.get(3).levelL.ret(tri.get(3).levelH, Xy, Ay, Dy) 
                                isValid = true
                                size4 = drawings4.size()
                                line ln = line(na)
                                if size4 > 0 
                                    for j = 0 to size4 -1
                                        get = drawings4.get(j)
                                        drawDx = get.points.get(4).index                                    
                                        drawDy = get.points.get(4).price                                
                                        if drawDx < Cx 
                                            break 
                                        else 
                                            if   Cx == get.points.get(5).index 
                                             and Bx == get.points.get(3).index                                     
                                             and Ax == get.points.get(2).index 
                                             and Xx == get.points.get(1).index                                             
                                                isValid := false 
                                                if Dx == drawDx                             
                                                    break 
                                                else 
                                                    get.poly.delete()  
                                                    if labs != 'None'                 
                                                        space = '' 
                                                        count = labelCount.first()
                                                        if count > 0 
                                                            for c = 1 to count
                                                                space += '\n'                             
                                                            get.lab.set_text((Dy > Cy ? '' : space) + get.lab.get_text() + (Dy > Cy ? space : ''))                       
                                                        get.lab.set_xy(Dx, Dy)
                                                        labelCount.set(0, labelCount.first() +1)
                                                    if oldL == 'Show'
                                                        if not na(get.oldLine)
                                                            get.oldLine.set_xy2(drawDx, drawDy)
                                                        else
                                                            get.oldLine := line.new(Cx, Cy, drawDx, drawDy, color= color.new(col, 50), style=line.style_dashed) 

                                                    getPoints4 = get.points.get(4)
                                                    getPoints4.index := Dx 
                                                    getPoints4.price := Dy 

                                                    get.poly := polyline.new(get.points
                                                     , line_color = col
                                                     , fill_color = col_
                                                     )
                                if isValid and Dx != 0
                                    pt = drawing.new()
                                    pt.points := array.from(
                                       chart.point.from_index(Bx, By)
                                     , chart.point.from_index(Xx, Xy)
                                     , chart.point.from_index(Ax, Ay)
                                     , chart.point.from_index(Bx, By)
                                     , chart.point.from_index(Dx, Dy)                         
                                     , chart.point.from_index(Cx, Cy)                                 
                                     , chart.point.from_index(Bx, By)
                                     )
                                    pt.labels :=  tri.lab(Bx, By, Cx, Cy, Dx, Dy, col)
                                    if labs != 'None'
                                        space = '' 
                                        count = labelCount.first()
                                        if count > 0 
                                            for c = 1 to count
                                                space += '\n'
                                        pt.lab  := label.new(Dx, Dy, style = Dy > Cy ? label.style_label_down : label.style_label_up, color=INV
                                         , size = textSize, textcolor = col, text= labs == 'Pattern Names' ? patterns.get(i).name + (Dy > Cy ? space : '') : Dy > Cy ? '‚ñº' : '‚ñ≤')
                                        labelCount.set(0, count +1)

                                    if pats == 'Show'
                                        pt.poly := polyline.new(pt.points
                                         , line_color = col
                                         , fill_color = col_
                                         )
                                    drawings4.unshift(pt)
_                                                                                                                                                                                                                                                                                                       ='
                                                                                                  Execution
                                                                                                  ---------                                                                                                                                                                                             '

for i = dif -1 to 0
    arrayZZ.zigzag(i, stt + i, 1)

while drawings3.size() + drawings4.size() > 100 
    pop = drawings3.size() > drawings4.size() ? drawings3.pop() : drawings4.pop()
    pop.poly.delete() 
    if labs != 'None'
        pop.lab .delete()
_                                                                                                                                                                                                                                                                                                       ='
                                                                                                  ---------                                                                                                                                                                                             '
