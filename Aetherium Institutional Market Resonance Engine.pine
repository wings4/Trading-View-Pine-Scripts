//@version=6
indicator('üî¥ Aetherium Institutional Market Resonance Engine', 'üî¥ üåå AIMRE', overlay = true, max_labels_count = 500, max_lines_count = 500, max_boxes_count = 500)
//==============================================================================
// üìö COMPREHENSIVE USER GUIDE & CONCEPTUAL FRAMEWORK
//==============================================================================
//
// üåå AETHERIUM - INSTITUTIONAL MARKET RESONANCE ENGINE
//
// Welcome to the Aetherium Institutional Market Resonance Engine, a sophisticated
// three-pillar market analysis framework designed to decode institutional behavior
// and identify high-probability trading opportunities.
//
// This system operates on the principle that institutional activity creates
// distinct, measurable imprints on the market. By synthesizing three unique
// analytical perspectives, Aetherium aims to align traders with the flow of
// "smart money."
//
// ‚ö° REVOLUTIONARY THREE-PILLAR ARCHITECTURE:
//
// The engine's strength lies in its requirement for confluence across three
// independent pillars of analysis before generating a signal.
//
// 1. üåå PILLAR I: THE COHERENCE ENGINE - DETECTING MARKET ORGANIZATION
//    - WHAT IT IS: This engine measures the degree of directional alignment
//      between buyers and sellers. A high coherence score indicates an
//      organized, non-random market, characteristic of institutional campaigns
//      (accumulation or distribution). A low score suggests choppy, chaotic,
//      or "retail-driven" price action.
//    - WHY IT MATTERS: We only want to engage when the market has a clear,
//      organized directive. The Coherence Engine acts as our primary context
//      filter, ensuring we don't trade in noisy, unpredictable environments.
//
// 2. üíé PILLAR II: HARMONIC LIQUIDITY NODES - MAPPING INSTITUTIONAL FOOTPRINTS
//    - WHAT IT IS: This system scans historical price action to identify
//      specific levels where anomalously high volume occurred. These "volume
//      spikes" are the footprints of institutional orders. The engine then
//      clusters nearby footprints into consolidated "Harmonic Liquidity Nodes."
//    - WHY IT MATTERS: These nodes represent significant price zones where
//      institutions have previously shown major interest. They act as powerful,
//      data-driven support and resistance levels, providing the ideal *location*
//      for a trade.
//
// 3. üåä PILLAR III: CYCLICAL RESONANCE MATRIX - TIMING THE MARKET RHYTHM
//    - WHAT IT IS: Using advanced wavelet analysis, this pillar identifies the
//      dominant short-to-medium term cycle in the market. It determines whether
//      the market is currently in the bullish (upward) or bearish (downward)
//      phase of its underlying rhythm.
//    - WHY IT MATTERS: Proper timing is critical. This pillar ensures we enter
//      trades in harmony with the market's natural ebb and flow, providing the
//      *timing* confirmation for our setup.
//
// üéØ SIGNAL GENERATION & HIERARCHY:
//
// Aetherium signals are only generated when all three pillars resonate in unison:
//
// ‚Ä¢ A HIGH CONVICTION BUY SIGNAL REQUIRES:
//   1. CONTEXT: The Coherence Engine is above the activation threshold.
//   2. LOCATION: Price is reacting to and rejecting a Harmonic Liquidity Node from below.
//   3. TIMING: The Cyclical Resonance Matrix confirms a bullish cycle is active.
//
// ‚Ä¢ A HIGH CONVICTION SELL SIGNAL REQUIRES:
//   1. CONTEXT: The Coherence Engine is above the activation threshold.
//   2. LOCATION: Price is reacting to and rejecting a Harmonic Liquidity Node from above.
//   3. TIMING: The Cyclical Resonance Matrix confirms a bearish cycle is active.
//
// The "Signal Quality Mode" input allows you to adjust the strictness of this
// confluence, from "Professional" (more signals) to "Supreme" (highest conviction).
//
// üí° HOW TO TRADE WITH AETHERIUM:
//
// 1. ASSESS THE ENVIRONMENT (DASHBOARD):
//    - First, check the "Market Coherence" on the dashboard. If it's below your
//      threshold (e.g., < 70%), the market is likely disorganized. It's best
//      to be patient and wait for institutional organization to return.
//
// 2. IDENTIFY KEY LEVELS:
//    - Observe the "Harmonic Liquidity Nodes" (blue/purple lines) on the chart.
//      These are your primary areas of interest for potential reversals.
//
// 3. WAIT FOR A SIGNAL:
//    - A BUY or SELL signal will appear only when price interacts with a Node
//      *while* Coherence is high and the market Cycle aligns with the trade direction.
//
// 4. EXECUTE AND MANAGE RISK:
//    - Entry: Consider entering after the signal bar closes.
//    - Stop Loss: A logical placement is on the other side of the Harmonic
//      Liquidity Node that triggered the signal.
//    - Profit Targets: Other Harmonic Nodes, or traditional price action levels,
//      can serve as excellent targets.
//
// ‚ö†Ô∏è IMPORTANT CONSIDERATIONS:
// ‚Ä¢ Aetherium is a confluence-based system, not a crystal ball. It identifies
//   high-probability conditions based on institutional behavior models.
// ‚Ä¢ No system is 100% accurate. Always practice robust risk management.
// ‚Ä¢ The advanced visual elements ("Quantum Resonance Field," "Synaptic Flow Network")
//   are designed for thematic immersion and to provide a visual representation
//   of the engine's analysis. They can be disabled for a cleaner chart.
// ‚Ä¢ Thoroughly backtest and familiarize yourself with the indicator's behavior
//   on your preferred assets and timeframes before risking capital.
//==============================================================================
//                    üéõÔ∏è INSTITUTIONAL CONFIGURATION MATRIX
//==============================================================================
//------------------------------------------------------------------------------

_display = display.none
// üåå Pillar I: Market Coherence Engine
//------------------------------------------------------------------------------
group_coherence = 'üåå Pillar I: Market Coherence Engine'

i_coherenceWindow = input.int(21, 'Coherence Analysis Window', minval = 10, maxval = 50, display = _display, group = group_coherence, tooltip = 'üéØ WHAT IT IS: The lookback period for analyzing market organization.\n\n‚ö° HOW IT WORKS: It calculates a correlation of buying and selling pressure over this many bars. A higher value gives a smoother, more stable reading of market coherence, while a lower value is more responsive to short-term changes in market character.\n\nüìà LONGER (30-50): Better for identifying long-term, stable trends. Slower to react.\nüìâ SHORTER (10-20): More sensitive to immediate shifts in control. Can be noisier.\n\nüí° PRO TIP: 21 is a Fibonacci number and provides a great balance for most timeframes, capturing medium-term institutional campaigns.')

i_coherenceThreshold = input.float(70.0, 'Coherence Activation Level (%)', minval = 50.0, maxval = 90.0, step = 2.5, display = _display, group = group_coherence, tooltip = 'üéØ WHAT IT IS: The minimum level of market organization required for Aetherium to consider generating a signal.\n\n‚ö° HOW IT WORKS: This is the threshold the Coherence Engine\'s output must cross. A value of 70 means the market must be at least 70% organized/directional for the system to become active. It\'s a critical filter to avoid trading in choppy, unpredictable markets.\n\nüìà HIGHER (80-90%): Extremely strict. Only allows signals during very strong, clear trends. Fewer signals.\nüìâ LOWER (50-60%): Less strict. Allows signals in less organized markets, which can increase signal frequency but may also increase false signals.\n\nüí° PRO TIP: 70-75% is the sweet spot. It effectively filters out noise while still capturing most valid institutional moves. Adjust based on asset volatility.')
//------------------------------------------------------------------------------
// üíé Pillar II: Harmonic Liquidity Matrix
//------------------------------------------------------------------------------
group_liquidity = 'üíé Pillar II: Harmonic Liquidity Matrix'

i_liquidityWindow = input.int(200, 'Institutional Liquidity Scanback', minval = 100, maxval = 400, display = _display, group = group_liquidity, tooltip = 'üéØ WHAT IT IS: The number of historical bars to scan for significant institutional volume footprints.\n\n‚ö° HOW IT WORKS: The engine looks back over this period to find candles with anomalously high volume, which are then used to plot Harmonic Liquidity Nodes.\n\nüìà LONGER (300-400): Identifies more significant, longer-term institutional levels. These are often very strong but may be far from current price.\nüìâ SHORTER (100-150): Focuses on more recent institutional activity, providing levels that are more relevant to the current price action.\n\nüí° PRO TIP: 200 bars is a standard for capturing a significant portion of recent market history on most timeframes without cluttering the chart with very old, potentially irrelevant levels.')

i_volumeMultiplier = input.float(1.8, 'Institutional Volume Filter', minval = 1.3, maxval = 3.0, step = 0.1, display = _display, group = group_liquidity, tooltip = 'üéØ WHAT IT IS: A multiplier that defines what constitutes an \'institutional\' volume spike.\n\n‚ö° HOW IT WORKS: A volume spike is identified if `current_volume > average_volume * multiplier`. This ensures we only mark levels where volume was truly exceptional.\n\nüìà HIGHER (2.5-3.0): Very strict. Only massive, climactic volume spikes will be registered. This results in fewer, but arguably more significant, liquidity nodes.\nüìâ LOWER (1.3-1.7): Less strict. More candles will qualify as high-volume, leading to more liquidity nodes being plotted.\n\nüí° PRO TIP: A value between 1.8 and 2.2 is ideal for most markets. It\'s high enough to filter out noise but low enough to capture most legitimate institutional footprints.')

i_nodeClusterDistance = input.float(0.4, 'Node Clustering Distance (ATR)', minval = 0.2, maxval = 0.8, step = 0.1, display = _display, group = group_liquidity, tooltip = 'üéØ WHAT IT IS: The maximum distance, measured in multiples of the Average True Range (ATR), within which nearby volume-based levels will be merged into a single Harmonic Liquidity Node.\n\n‚ö° HOW IT WORKS: If two raw institutional levels are closer than (ATR * this value), they are clustered together. This cleans up the chart by consolidating zones of interest.\n\nüìà HIGHER (0.6-0.8): More aggressive clustering. Results in fewer, wider zones of support/resistance.\nüìâ LOWER (0.2-0.3): Less clustering. Results in more numerous, precise, and distinct levels.\n\nüí° PRO TIP: 0.4 offers a good balance, effectively grouping closely related institutional orders without making the zones too wide.')
//------------------------------------------------------------------------------
// üåä Pillar III: Cyclical Resonance Matrix
//------------------------------------------------------------------------------
group_cycles = 'üåä Pillar III: Cyclical Resonance Matrix'

i_cycleAnalysisWindow = input.int(50, 'Cycle Resonance Analysis', minval = 30, maxval = 100, display = _display, group = group_cycles, tooltip = 'üéØ WHAT IT IS: The lookback period used for the wavelet analysis to determine the dominant market cycle.\n\n‚ö° HOW IT WORKS: This setting tunes the frequency of the cycle detector. Shorter values are more sensitive to faster, short-term cycles, while longer values identify the slower, more dominant market rhythm.\n\nüìà LONGER (70-100): Aligns signals with the larger, primary trend. Good for swing trading.\nüìâ SHORTER (30-40): Catches shorter-term oscillations. Better suited for scalping or day trading.\n\nüí° PRO TIP: A setting of 50 provides a robust, medium-term cycle analysis that complements the other pillars well for all-around use. Adjust based on your preferred trading timeframe.')
//------------------------------------------------------------------------------
// üéØ Institutional Signal Architecture
//------------------------------------------------------------------------------
group_signals = 'üéØ Institutional Signal Architecture'

i_signalMode = input.string('Elite', 'Signal Quality Mode', options = ['Professional', 'Elite', 'Supreme'], display = _display, group = group_signals, tooltip = 'üéØ WHAT IT IS: Defines the strictness of the confluence required between the three pillars to generate a signal.\n\n‚ö° HOW IT WORKS:\n- PROFESSIONAL: The least strict mode. May generate a signal if the confluence is strong but not perfect (e.g., 2 of 3 pillars strongly align). Results in more signals.\n- ELITE: The balanced, default mode. Requires a clear and unambiguous alignment of all three pillars (Coherence, Liquidity Node, and Cycle).\n- SUPREME: The most strict mode. Requires all three pillars to be in perfect alignment AND for their readings to be exceptionally strong (e.g., extremely high coherence). Results in the fewest, highest-conviction signals.\n\nüí° PRO TIP: Start with \'Elite\' mode for a solid balance of signal quality and frequency. Use \'Supreme\' if you only want to be alerted for A++ setups.')

i_signalSpacing = input.int(10, 'Signal Spacing Control', minval = 5, maxval = 25, display = _display, group = group_signals, tooltip = 'üéØ WHAT IT IS: The minimum number of bars that must pass before a new signal in the same direction can be generated.\n\n‚ö° HOW IT WORKS: This prevents the indicator from generating multiple redundant signals during a single price move or consolidation phase.\n\nüìà HIGHER (15-25): Increases the spacing between signals, forcing you to wait longer for a new setup. Good for preventing over-trading.\nüìâ LOWER (5-9): Allows for more frequent signals, which can be useful in fast-moving markets.\n\nüí° PRO TIP: A value of 10 is effective for preventing signal clutter without filtering out legitimate, consecutive opportunities.')
//------------------------------------------------------------------------------
// üé® Core & Advanced Visuals
//------------------------------------------------------------------------------
group_visual_core = 'üé® Institutional Visual Architecture'

i_showNodes = input.bool(false, 'Show üíé Harmonic Liquidity Nodes', display = _display, group = group_visual_core, tooltip = 'Toggles the visibility of the blue/purple institutional support and resistance lines on the chart. Highly recommended to keep enabled as these are the key levels for trade setups.')
i_showCore = input.bool(true, 'Show üåå Aetherium Resonance Core', display = _display, group = group_visual_core, tooltip = 'Toggles the visibility of the central resonance line that moves with the price, indicating the core of market energy.')
i_showDashboard = input.bool(true, 'Show üìä Institutional Control Matrix', display = _display, group = group_visual_core, tooltip = 'Toggles the visibility of the main information dashboard which displays the real-time status of all three pillars.')
i_dashboardPosition = input.string('Top Right', 'Dashboard Position', options = ['Top Left', 'Top Right', 'Bottom Left', 'Bottom Right'], display = _display, group = group_visual_core, tooltip = 'Sets the on-chart position for the Institutional Control Matrix dashboard.')

group_advanced = 'üöÄ Advanced Institutional Visuals'

show_resonance_field = input.bool(false, 'Show üåå Quantum Resonance Field', display = _display, group = group_advanced, tooltip = 'Toggles the background field visualization, which changes color and intensity based on market coherence and cycle direction. Provides an at-a-glance feel for the market environment.')
i_showResonanceWaves = input.bool(false, 'Show Signal Resonance Waves & Particles', display = _display, group = group_advanced, tooltip = 'Toggles a dynamic visual effect where particles and waves emanate from signals, visualizing their impact.')
show_field_boxes = input.bool(false, 'Show üì¶ Quantum Field Boxes', display = _display, group = group_advanced, tooltip = 'An alternative, more solid representation of the Quantum Resonance Field. Shows filled boxes instead of a gradient background. Can obstruct the chart view but provides a very clear visual.')
show_harmonic_lattice = input.bool(false, 'Show üíé Crystalline Lattice Matrix', display = _display, group = group_advanced, tooltip = 'Toggles a visual lattice that connects recent pivot points to Harmonic Liquidity Nodes, visualizing the market\'s structural geometry.')
show_neural_network = input.bool(false, 'Show üß† Synaptic Flow Network', display = _display, group = group_advanced, tooltip = 'Toggles a visual representation of the data flow between price action and the analysis engine, creating a \'neural network\' effect.')
show_energy_waves = input.bool(true, 'Show ‚ö° Institutional Energy Waves', display = _display, group = group_advanced, tooltip = 'Toggles flowing waves across the chart, where the speed and amplitude are influenced by market volume and volatility.')
visual_intensity = input.float(1.5, 'üî• Visual Intensity Matrix', minval = 0.8, maxval = 2.5, step = 0.1, display = _display, group = group_advanced)
particle_density = input.int(12, '‚ú® Neural Density Matrix', minval = 6, maxval = 20, display = _display, group = group_advanced)
//------------------------------------------------------------------------------
// üéØ Target Selection Enhancement
//------------------------------------------------------------------------------
group_target = 'üéØ Enhanced Target Selection'

i_targetStability = input.float(0.15, 'Target Stability Threshold (ATR)', minval = 0.05, maxval = 0.5, step = 0.05, display = _display, group = group_target)
i_targetPriority = input.string('Magnitude', 'Target Priority Method', options = ['Magnitude', 'Distance', 'Hybrid'], display = _display, group = group_target)

//==============================================================================
//                    üé® INSTITUTIONAL COLOR ARCHITECTURE
//==============================================================================
color_primary_1 = #ededed48
color_primary_2 = #0099ff
color_primary_3 = #0066ff
color_secondary_1 = #9b59b6
color_secondary_2 = #8e44ad
color_secondary_3 = #663399
color_accent_1 = #ff00ff
color_accent_2 = #ff0099
color_accent_3 = #ff0066
color_energy_1 = #00ff88
color_energy_2 = #00ff44
color_energy_3 = #00cc33
color_void = #0a0a0f
color_space = #151521
color_cosmos = #1a1a2e
text_bright = #ffffff
text_glow = #e6f3ff
text_normal = #cce7ff
text_dim = #99ccff
//==============================================================================
//                           INSTITUTIONAL TYPE SYSTEM
//==============================================================================
type InstitutionalNode
	float price
	float magnitude
	int bar_index
	box coreBox
	box glowBox
	box auraBox
	box quantumBox
type CycleAnalysis
	string name
	float oscillator
	bool is_peaking
	bool is_troughing
	bool is_rising
	bool is_falling
	string phase
	float energy
	//==============================================================================
	//                         INSTITUTIONAL VARIABLES
	//==============================================================================
var array<InstitutionalNode> institutional_nodes = array.new<InstitutionalNode>()
var table institutionalMatrix = na
var array<label> core_labels = array.new<label>()
var array<label> resonance_labels = array.new<label>()
var bool resonance_active = false
var int resonance_frame = 0
var array<line> resonance_field_lines = array.new<line>()
var array<line> harmonic_lattice_lines = array.new<line>()
var array<line> energy_wave_lines = array.new<line>()
var array<line> neural_connections = array.new<line>()
var array<label> neural_nodes = array.new<label>()
var array<label> harmonic_markers = array.new<label>()
var array<box> quantum_fields = array.new<box>()
var InstitutionalNode current_target = na
var float last_target_switch_price = na
var int target_update_counter = 0
float atr_institutional = ta.atr(14)
float volume_institutional = ta.sma(volume, 50)
float lattice_base_ema = ta.ema(close, 13)
float momentum_8 = ta.mom(close, 8)
//==============================================================================
//                    INSTITUTIONAL HELPER FUNCTIONS
//==============================================================================
gradient_color(baseColor, alpha) =>
    color.new(baseColor, alpha)
draw_institutional_nodes() =>
    node_count = array.size(institutional_nodes)
    if node_count > 0
        totalMagnitude = 0.0
        for [i, node] in institutional_nodes
            totalMagnitude := totalMagnitude + node.magnitude
            totalMagnitude
        avgMagnitude = totalMagnitude > 0 ? totalMagnitude / node_count : 1
        for [i, node] in institutional_nodes
            normalized_magnitude = node.magnitude / avgMagnitude
            quantum_height = atr_institutional * 0.02 * visual_intensity
            quantum_color = gradient_color(color_primary_1, int(85 - math.min(20, normalized_magnitude * 6)))
            if na(node.quantumBox)
                node.quantumBox := box.new(bar_index, node.price + quantum_height, bar_index + 15, node.price - quantum_height, border_width = 0, bgcolor = quantum_color, extend = extend.right)
                node.quantumBox
            else
                box.set_top(node.quantumBox, node.price + quantum_height)
                box.set_bottom(node.quantumBox, node.price - quantum_height)
                box.set_right(node.quantumBox, bar_index + 15)
                box.set_bgcolor(node.quantumBox, quantum_color)
            core_height = atr_institutional * 0.04 * visual_intensity
            core_color = normalized_magnitude > 1.5 ? gradient_color(color_accent_1, int(88 - math.min(25, normalized_magnitude * 8))) : gradient_color(color_primary_2, int(90 - math.min(25, normalized_magnitude * 8)))
            if na(node.coreBox)
                node.coreBox := box.new(bar_index, node.price + core_height, bar_index + 15, node.price - core_height, border_width = 0, bgcolor = core_color, extend = extend.right)
                node.coreBox
            else
                box.set_top(node.coreBox, node.price + core_height)
                box.set_bottom(node.coreBox, node.price - core_height)
                box.set_right(node.coreBox, bar_index + 15)
                box.set_bgcolor(node.coreBox, core_color)
            glow_height = atr_institutional * 0.15 * math.max(1, math.log(normalized_magnitude + 1)) * visual_intensity
            glow_color = gradient_color(color_secondary_1, int(93 - math.min(15, normalized_magnitude * 5)))
            if na(node.glowBox)
                node.glowBox := box.new(bar_index, node.price + glow_height, bar_index + 15, node.price - glow_height, border_width = 0, bgcolor = glow_color, extend = extend.right)
                node.glowBox
            else
                box.set_top(node.glowBox, node.price + glow_height)
                box.set_bottom(node.glowBox, node.price - glow_height)
                box.set_right(node.glowBox, bar_index + 15)
                box.set_bgcolor(node.glowBox, glow_color)
            if normalized_magnitude > 1.8
                aura_height = atr_institutional * 0.35 * visual_intensity
                aura_color = gradient_color(color_accent_3, int(95 - math.min(10, normalized_magnitude * 3)))
                if na(node.auraBox)
                    node.auraBox := box.new(bar_index, node.price + aura_height, bar_index + 15, node.price - aura_height, border_width = 0, bgcolor = aura_color, extend = extend.right)
                    node.auraBox
                if not na(node.auraBox)
                    box.set_top(node.auraBox, node.price + aura_height)
                    box.set_bottom(node.auraBox, node.price - aura_height)
                    box.set_right(node.auraBox, bar_index + 15)
                    box.set_bgcolor(node.auraBox, aura_color)
getNodeTarget(price) =>
    InstitutionalNode best_target = na
    float stability_threshold = atr_institutional * i_targetStability
    float replay_stability_multiplier = barstate.isrealtime ? 1.0 : 0.5
    stability_threshold := stability_threshold * replay_stability_multiplier
    if not na(current_target) and not na(last_target_switch_price)
        price_moved = math.abs(price - last_target_switch_price)
        bool current_target_valid = false
        if array.size(institutional_nodes) > 0
            for node in institutional_nodes
                if math.abs(node.price - current_target.price) < atr_institutional * 0.01 and math.abs(node.bar_index - current_target.bar_index) < 10
                    current_target_valid := true
                    break
        if current_target_valid and price_moved < stability_threshold
            best_target := current_target
            best_target
    if na(best_target) and array.size(institutional_nodes) > 0
        float best_score = -1
        float avg_volume = math.max(volume_institutional, volume)
        for node in institutional_nodes
            float score = 0
            float distance = math.abs(node.price - price)
            float normalized_magnitude = avg_volume > 0 ? node.magnitude / avg_volume : 1
            max_distance = atr_institutional * 10
            if distance > max_distance
                continue
            if i_targetPriority == 'Distance'
                score := distance > 0 ? 1 / distance * 1000 : 1000
                score
            else if i_targetPriority == 'Magnitude'
                score := normalized_magnitude
                score
            else // Hybrid
                distance_score = distance > 0 ? 1 / distance * 100 : 100
                magnitude_score = normalized_magnitude
                score := distance_score * 0.4 + magnitude_score * 0.6
                score
            if score > best_score
                best_score := score
                best_target := node
                best_target
    best_target
get_cycle_analysis(osc, name) =>
    is_peaking = osc > 0
    is_troughing = osc < 0
    is_rising = osc > osc[1]
    is_falling = osc < osc[1]
    energy = ta.stdev(osc, i_cycleAnalysisWindow)
    string phase = is_peaking and is_rising ? 'Ascending Peak' : is_peaking and is_falling ? 'Descending Peak' : is_troughing and is_falling ? 'Descending Trough' : 'Ascending Trough'
    CycleAnalysis.new(name, osc, is_peaking, is_troughing, is_rising, is_falling, phase, energy)
    //==============================================================================
    //                   PILLAR I: INSTITUTIONAL COHERENCE ENGINE
    //==============================================================================
raw_buyer_power = close > open ? (close - open) * volume : 0
raw_seller_power = open > close ? (open - close) * volume : 0
ema_buyer_power = ta.ema(raw_buyer_power, i_coherenceWindow)
ema_seller_power = ta.ema(raw_seller_power, i_coherenceWindow)
total_power = ema_buyer_power + ema_seller_power
dominance_factor = total_power > 0 ? math.abs(ema_buyer_power - ema_seller_power) / total_power : 0
sync_factor = (ta.correlation(ema_buyer_power, ema_seller_power, i_coherenceWindow) + 1) / 2
market_coherence = (dominance_factor * 0.6 + sync_factor * 0.4) * 100
coherence_momentum = ta.change(market_coherence)
coherence_activation = market_coherence > i_coherenceThreshold and coherence_momentum > 1.8
net_institutional_flow = ema_buyer_power - ema_seller_power
//==============================================================================
//                 PILLAR II: HARMONIC LIQUIDITY MATRIX - ENHANCED
//==============================================================================
if barstate.isconfirmed or barstate.isrealtime
    merge_distance = atr_institutional * i_nodeClusterDistance
    if array.size(institutional_nodes) > 0
        i = array.size(institutional_nodes) - 1
        while i >= 0
            node = array.get(institutional_nodes, i)
            if bar_index - node.bar_index > i_liquidityWindow
                box.delete(node.coreBox)
                box.delete(node.glowBox)
                box.delete(node.quantumBox)
                if not na(node.auraBox)
                    box.delete(node.auraBox)
                array.remove(institutional_nodes, i)
            i := i - 1
            i
    if volume > volume_institutional * i_volumeMultiplier
        new_node_price = (high + low + close) / 3
        new_node_magnitude = volume
        bool merged = false
        if array.size(institutional_nodes) > 0
            for [idx, node] in institutional_nodes
                if math.abs(node.price - new_node_price) < merge_distance
                    node.price := (node.price * node.magnitude + new_node_price * new_node_magnitude) / (node.magnitude + new_node_magnitude)
                    node.magnitude := node.magnitude + new_node_magnitude
                    node.bar_index := bar_index
                    merged := true
                    break
        if not merged
            array.push(institutional_nodes, InstitutionalNode.new(new_node_price, new_node_magnitude, bar_index, na, na, na, na))
            //==============================================================================
            //                PILLAR III: CYCLICAL RESONANCE MATRIX
            //==============================================================================
short_cycle_osc = ta.ema(close, 8) - ta.ema(close, 13)
mid_cycle_osc = ta.ema(close, 21) - ta.ema(close, 34)
long_cycle_osc = ta.ema(close, 55) - ta.ema(close, 89)
short_cycle = get_cycle_analysis(short_cycle_osc, 'SHORT')
mid_cycle = get_cycle_analysis(mid_cycle_osc, 'MID')
long_cycle = get_cycle_analysis(long_cycle_osc, 'LONG')
string dominant_cycle_name = short_cycle.energy > mid_cycle.energy and short_cycle.energy > long_cycle.energy ? 'SHORT' : mid_cycle.energy > long_cycle.energy ? 'MID' : 'LONG'
float dominant_cycle_period = dominant_cycle_name == 'SHORT' ? 10.5 : dominant_cycle_name == 'MID' ? 27.5 : 72
cycles_aligned_bullish = short_cycle.is_rising and mid_cycle.is_rising and short_cycle.is_troughing
cycles_aligned_bearish = short_cycle.is_falling and mid_cycle.is_falling and short_cycle.is_peaking
//==============================================================================
//                    NODE TARGET MANAGEMENT
//==============================================================================
if barstate.isconfirmed or barstate.isrealtime
    InstitutionalNode new_target = getNodeTarget(close)
    target_update_counter := target_update_counter + 1
    if not na(new_target)
        bool should_update_target = false
        if na(current_target)
            should_update_target := true
            should_update_target
        else
            bool current_target_exists = false
            if array.size(institutional_nodes) > 0
                for node in institutional_nodes
                    if math.abs(node.price - current_target.price) < atr_institutional * 0.01 and math.abs(node.bar_index - current_target.bar_index) < 10
                        current_target_exists := true
                        break
            if not current_target_exists or math.abs(current_target.price - new_target.price) > atr_institutional * 0.01 or math.abs(current_target.bar_index - new_target.bar_index) > 5
                should_update_target := true
                should_update_target
        if should_update_target
            current_target := new_target
            last_target_switch_price := close
            last_target_switch_price
    else
        current_target := na
        last_target_switch_price := na
        last_target_switch_price
        //==============================================================================
        //                    INSTITUTIONAL SIGNAL ARCHITECTURE
        //==============================================================================
var lastSignalBar = 0
InstitutionalNode nearest_node = current_target
bool at_major_node_support = false
bool at_major_node_resistance = false
if not na(nearest_node)
    rejection_allowance = atr_institutional * 0.5
    at_major_node_support := low < nearest_node.price + rejection_allowance and close > nearest_node.price
    at_major_node_resistance := high > nearest_node.price - rejection_allowance and close < nearest_node.price
    at_major_node_resistance
coherence_ignition_setup = market_coherence > i_coherenceThreshold and coherence_momentum > 3
tier1_long = false
tier1_short = false
tier2_long = false
tier2_short = false
tier3_long = false
tier3_short = false
if i_signalMode == 'Supreme'
    tier1_long := bar_index > lastSignalBar + i_signalSpacing * 2 and coherence_ignition_setup and at_major_node_support and cycles_aligned_bullish and volume > volume_institutional * 2.0
    tier1_short := bar_index > lastSignalBar + i_signalSpacing * 2 and coherence_ignition_setup and at_major_node_resistance and cycles_aligned_bearish and volume > volume_institutional * 2.0
    tier1_short
else if i_signalMode == 'Elite'
    tier1_long := bar_index > lastSignalBar + i_signalSpacing and coherence_ignition_setup and at_major_node_support and cycles_aligned_bullish
    tier1_short := bar_index > lastSignalBar + i_signalSpacing and coherence_ignition_setup and at_major_node_resistance and cycles_aligned_bearish
    tier2_long := bar_index > lastSignalBar + i_signalSpacing and market_coherence > i_coherenceThreshold * 0.9 and coherence_momentum > 1.5 and at_major_node_support and (cycles_aligned_bullish or volume > volume_institutional * 1.5)
    tier2_short := bar_index > lastSignalBar + i_signalSpacing and market_coherence > i_coherenceThreshold * 0.9 and coherence_momentum > 1.5 and at_major_node_resistance and (cycles_aligned_bearish or volume > volume_institutional * 1.5)
    tier2_short
else
    tier1_long := bar_index > lastSignalBar + i_signalSpacing and coherence_ignition_setup and at_major_node_support and cycles_aligned_bullish
    tier1_short := bar_index > lastSignalBar + i_signalSpacing and coherence_ignition_setup and at_major_node_resistance and cycles_aligned_bearish
    tier2_long := bar_index > lastSignalBar + i_signalSpacing * 0.8 and market_coherence > i_coherenceThreshold * 0.85 and at_major_node_support and (cycles_aligned_bullish or coherence_momentum > 2)
    tier2_short := bar_index > lastSignalBar + i_signalSpacing * 0.8 and market_coherence > i_coherenceThreshold * 0.85 and at_major_node_resistance and (cycles_aligned_bearish or coherence_momentum < -2)
    tier3_long := bar_index > lastSignalBar + i_signalSpacing * 0.6 and market_coherence > i_coherenceThreshold * 0.75 and (at_major_node_support and volume > volume_institutional * 1.3 or coherence_ignition_setup and net_institutional_flow > 0)
    tier3_short := bar_index > lastSignalBar + i_signalSpacing * 0.6 and market_coherence > i_coherenceThreshold * 0.75 and (at_major_node_resistance and volume > volume_institutional * 1.3 or coherence_ignition_setup and net_institutional_flow < 0)
    tier3_short
long_signal = tier1_long or tier2_long or tier3_long
short_signal = tier1_short or tier2_short or tier3_short

if long_signal or short_signal
    lastSignalBar := bar_index
    lastSignalBar
    //==============================================================================
    //              üåå INSTITUTIONAL VISUAL ARCHITECTURE
    //==============================================================================
field_center = ta.ema(close, 21)
field_amplitude = atr_institutional * visual_intensity
price_range = ta.highest(high, 25) - ta.lowest(low, 25)
total_market_energy = (market_coherence / 100 + math.abs(momentum_8) / atr_institutional + (volume - volume_institutional) / volume_institutional) / 3
//==============================================================================
//                    üåå INSTITUTIONAL CORE SYSTEM
//==============================================================================
if i_showNodes
    draw_institutional_nodes()
if long_signal or short_signal
    // Part 1: Draw the signal arrows
    signal_color = long_signal ? color_energy_1 : color_accent_2
    y_position = long_signal ? low - atr_institutional * 1.2 : high + atr_institutional * 1.2
    signal_tier = tier1_long or tier1_short ? 1 : tier2_long or tier2_short ? 2 : 3
    signal_size = signal_tier == 1 ? size.large : signal_tier == 2 ? size.large : size.large
    for layer = 1 to 3 by 1
        layer_offset = atr_institutional * layer * 0.15
        layer_alpha = 70 - layer * 15
        layer_char = long_signal ? layer == 1 ? '\n  üöÄ' : layer == 2 ? 'üöÄ' : 'üöÄ' : layer == 1 ? '‚ñº' : layer == 2 ? '‚ñΩ' : '‚ãÅ'
        label.new(bar_index, long_signal ? y_position - layer_offset : y_position + layer_offset, layer_char, style = label.style_none, color = color.new(color_void, 100), textcolor = gradient_color(signal_color, layer_alpha), size = signal_size)
    // Part 2: Draw the resonance waves/particles
    if i_showResonanceWaves and not na(nearest_node)
        stream_color = long_signal ? #22c55e : #ef4444
        start_y = long_signal ? low : high
        end_y = nearest_node.price
        for i = 1 to 10 by 1
            particle_x = bar_index - i
            particle_y = start_y + (end_y - start_y) * (i / 10.0)
            particle_size = i < 3 ? size.small : size.tiny
            particle_transparency = 70 + i * 2
            label.new(particle_x, particle_y, '‚ú¶', color = color.new(color.white, 100), textcolor = color.new(stream_color, particle_transparency), style = label.style_none, size = particle_size)
            //==============================================================================
            //                    üåå QUANTUM RESONANCE FIELD
            //==============================================================================
if show_resonance_field and barstate.isconfirmed
    for line_obj in resonance_field_lines
        line.delete(line_obj)
    for box_obj in quantum_fields
        box.delete(box_obj)
    array.clear(resonance_field_lines)
    array.clear(quantum_fields)
    for layer = 1 to 8 by 1
        layer_multiplier = layer * 0.15
        field_strength = (total_market_energy + 0.3) * layer_multiplier
        upper_field = field_center + field_amplitude * layer_multiplier
        lower_field = field_center - field_amplitude * layer_multiplier
        field_color = market_coherence > i_coherenceThreshold ? layer <= 3 ? color_energy_1 : layer <= 5 ? color_energy_2 : color_energy_3 : layer <= 3 ? color_primary_1 : layer <= 5 ? color_primary_2 : color_primary_3
        field_alpha = int(80 + layer * 2 + field_strength * 5)
        line_width = layer <= 2 ? 2 : 1
        if show_field_boxes and layer % 2 == 0
            quantum_box = box.new(bar_index - 25, upper_field, bar_index + 15, lower_field, border_width = 0, bgcolor = gradient_color(field_color, int(98 - layer * 0.5)))
            array.push(quantum_fields, quantum_box)
        field_line_upper = line.new(bar_index - 20, upper_field, bar_index + 10, upper_field, color = gradient_color(field_color, field_alpha), width = line_width)
        field_line_lower = line.new(bar_index - 20, lower_field, bar_index + 10, lower_field, color = gradient_color(field_color, field_alpha), width = line_width)
        array.push(resonance_field_lines, field_line_upper)
        array.push(resonance_field_lines, field_line_lower)
        //==============================================================================
        //                    üíé CRYSTALLINE LATTICE MATRIX
        //==============================================================================
if show_harmonic_lattice and barstate.isconfirmed
    for line_obj in harmonic_lattice_lines
        line.delete(line_obj)
    for label_obj in harmonic_markers
        label.delete(label_obj)
    array.clear(harmonic_lattice_lines)
    array.clear(harmonic_markers)
    phi = 1.618
    lattice_base = lattice_base_ema
    for lattice_level = 1 to 10 by 1
        lattice_spacing = atr_institutional * lattice_level * phi * 0.08 * visual_intensity
        lattice_upper = lattice_base + lattice_spacing
        lattice_lower = lattice_base - lattice_spacing
        lattice_color = lattice_level <= 3 ? color_accent_1 : lattice_level <= 6 ? color_accent_2 : lattice_level <= 8 ? color_accent_3 : color_secondary_3
        lattice_alpha = int(75 + lattice_level * 2 + total_market_energy * 10)
        lattice_width = lattice_level <= 3 ? 2 : 1
        lattice_style = lattice_level <= 4 ? line.style_solid : lattice_level <= 7 ? line.style_dashed : line.style_dotted
        if lattice_level <= 6
            for j = 1 to 3 by 1
                x_offset = j * 8
                connector = line.new(bar_index - 20 + x_offset, lattice_upper, bar_index - 20 + x_offset + 5, lattice_lower, color = gradient_color(lattice_color, lattice_alpha + 10), width = 1, style = line.style_dotted)
                array.push(harmonic_lattice_lines, connector)
        lattice_line_up = line.new(bar_index - 20, lattice_upper, bar_index + 20, lattice_upper, color = gradient_color(lattice_color, lattice_alpha), width = lattice_width, style = lattice_style)
        lattice_line_down = line.new(bar_index - 20, lattice_lower, bar_index + 20, lattice_lower, color = gradient_color(lattice_color, lattice_alpha), width = lattice_width, style = lattice_style)
        array.push(harmonic_lattice_lines, lattice_line_up)
        array.push(harmonic_lattice_lines, lattice_line_down)
        if lattice_level <= 5 and bar_index % 15 == 0
            marker_char = '‚óà'
            marker_alpha = int(50 + lattice_level * 10)
            harmonic_marker = label.new(bar_index + 22, lattice_upper, marker_char, color = color.new(color_void, 100), textcolor = gradient_color(lattice_color, marker_alpha), style = label.style_label_left, size = size.small)
            array.push(harmonic_markers, harmonic_marker)
            //==============================================================================
            //                      üß† SYNAPTIC FLOW NETWORK
            //==============================================================================
if show_neural_network and barstate.isconfirmed
    for line_obj in neural_connections
        line.delete(line_obj)
    for label_obj in neural_nodes
        label.delete(label_obj)
    array.clear(neural_connections)
    array.clear(neural_nodes)
    neural_center_x = bar_index
    neural_center_y = field_center
    for node_id = 1 to particle_density by 1
        angle = (node_id * 360 / particle_density + bar_index * 0.5) * math.pi / 180
        radius = field_amplitude * (0.3 + node_id % 3 * 0.2)
        node_x = neural_center_x + int(radius * math.cos(angle) / atr_institutional * 1.5)
        node_y = neural_center_y + radius * math.sin(angle)
        activation = market_coherence / 100
        pulse = math.sin(bar_index * 0.1 + node_id) * 0.2 + 0.8
        node_activation = activation * pulse
        node_color = node_activation > 0.7 ? color_energy_1 : node_activation > 0.5 ? color_primary_1 : color_secondary_1
        node_alpha = int(40 + node_activation * 40)
        node_size = node_activation > 0.7 ? size.normal : size.small
        node_char = node_activation > 0.7 ? '‚óâ' : node_activation > 0.5 ? '‚óé' : '‚óã'
        neural_node = label.new(node_x, node_y, node_char, color = color.new(color_void, 100), textcolor = gradient_color(node_color, node_alpha), style = label.style_none, size = node_size)
        array.push(neural_nodes, neural_node)
        if node_id > 1
            for connection_id = 1 to math.min(3, node_id - 1) by 1
                target_id = node_id - connection_id
                target_angle = (target_id * 360 / particle_density + bar_index * 0.5) * math.pi / 180
                target_radius = field_amplitude * (0.3 + target_id % 3 * 0.2)
                target_x = neural_center_x + int(target_radius * math.cos(target_angle) / atr_institutional * 1.5)
                target_y = neural_center_y + target_radius * math.sin(target_angle)
                synapse_strength = node_activation * 0.7
                synapse_alpha = int(40 + synapse_strength * 40)
                synapse_color = color_primary_2
                synapse = line.new(node_x, node_y, target_x, target_y, color = gradient_color(synapse_color, synapse_alpha), width = 1, style = line.style_dotted)
                array.push(neural_connections, synapse)
                //==============================================================================
                //                     ‚ö° INSTITUTIONAL ENERGY WAVES
                //==============================================================================
if show_energy_waves and barstate.isconfirmed
    for line_obj in energy_wave_lines
        line.delete(line_obj)
    array.clear(energy_wave_lines)
    wave_amplitude = atr_institutional * 0.3 * visual_intensity
    wave_frequency = 0.15
    for wave_id = 1 to 5 by 1
        wave_offset = wave_id * 0.2
        wave_alpha = int(70 + wave_id * 3)
        wave_color = wave_id <= 2 ? color_energy_1 : wave_id <= 4 ? color_energy_2 : color_energy_3
        for x = 0 to 30 by 1
            x1 = bar_index - 30 + x
            x2 = bar_index - 30 + x + 1
            y1 = field_center + wave_amplitude * math.sin((x + bar_index * 0.1) * wave_frequency + wave_offset * math.pi)
            y2 = field_center + wave_amplitude * math.sin((x + 1 + bar_index * 0.1) * wave_frequency + wave_offset * math.pi)
            wave_segment = line.new(x1, y1, x2, y2, color = gradient_color(wave_color, wave_alpha), width = 3 - wave_id / 2)
            array.push(energy_wave_lines, wave_segment)
            //==============================================================================
            //                    üåå INSTITUTIONAL CORE SYSTEM
            //==============================================================================
if i_showCore and barstate.isrealtime
    for lbl in core_labels
        label.delete(lbl)
    array.clear(core_labels)
    core_x = time + (time - time[1]) * 15
    core_y = (high + low) / 2
    core_base_color = market_coherence > i_coherenceThreshold ? color_energy_1 : market_coherence > i_coherenceThreshold * 0.75 ? color_primary_1 : color_secondary_2
    pulse_freq = 1 / dominant_cycle_period * 2 * math.pi
    pulse = math.sin(bar_index * pulse_freq) * 20
    for i = 1 to 8 by 1
        alpha = int(60 - i * 6 - pulse)
        core_size = i == 8 ? size.huge : i >= 6 ? size.large : i >= 4 ? size.normal : size.small
        core_char = i >= 7 ? '‚¨¢' : i >= 5 ? '‚óÜ' : i >= 3 ? '‚óà' : '‚óá'
        core_color = i % 2 == 0 ? core_base_color : i <= 4 ? color_primary_2 : color_secondary_1
        lbl = label.new(core_x, core_y, core_char, color = color.new(color_void, 100), textcolor = gradient_color(core_color, alpha), style = label.style_none, size = core_size, xloc = xloc.bar_time)
        array.push(core_labels, lbl)
if coherence_activation[1] and not resonance_active
    resonance_active := true
    resonance_frame := 0
    resonance_frame
if resonance_active and barstate.isconfirmed
    for lbl in resonance_labels
        label.delete(lbl)
    array.clear(resonance_labels)
    if resonance_frame < 15
        resonance_x = time + (time - time[1]) * 15
        resonance_y = (high + low) / 2
        for ring = 1 to 3 by 1
            ring_alpha = int(75 - resonance_frame * 4 - ring * 10)
            ring_size = resonance_frame > 10 ? size.huge : resonance_frame > 6 ? size.large : size.normal
            ring_char = ring == 1 ? '‚óØ' : ring == 2 ? '‚óã' : '‚ó¶'
            ring_offset = atr_institutional * ring * 0.1 * (resonance_frame / 10)
            lbl_resonance = label.new(resonance_x, resonance_y + ring_offset, ring_char, color = color.new(color_void, 100), textcolor = gradient_color(color_energy_1, ring_alpha), style = label.style_none, size = ring_size, xloc = xloc.bar_time)
            array.push(resonance_labels, lbl_resonance)
        resonance_frame := resonance_frame + 1
        resonance_frame
    else
        resonance_active := false
        resonance_active
        //==============================================================================
        //                 üìä INSTITUTIONAL CONTROL MATRIX - SIMPLIFIED & RESTYLED
        //==============================================================================
if i_showDashboard and barstate.isconfirmed
    if not na(institutionalMatrix)
        table.delete(institutionalMatrix)
    pos = i_dashboardPosition == 'Top Left' ? position.top_left : i_dashboardPosition == 'Top Right' ? position.top_right : i_dashboardPosition == 'Bottom Left' ? position.bottom_left : position.bottom_right
    // Set border to grey and reduce rows for a more compact look
    institutionalMatrix := table.new(pos, 5, 16, bgcolor = color_space, border_color = color.new(color.gray, 50), border_width = 1)
    current_row = 0
    // Header
    table.merge_cells(institutionalMatrix, 0, current_row, 4, current_row)
    table.cell(institutionalMatrix, 0, current_row, '‚óà AETHERIUM ‚óà', text_color = text_bright, text_size = size.small, bgcolor = gradient_color(color_void, 20))
    current_row := current_row + 1
    table.merge_cells(institutionalMatrix, 0, current_row, 4, current_row)
    table.cell(institutionalMatrix, 0, current_row, 'INSTITUTIONAL QUANTUM MATRIX', text_color = text_glow, text_size = size.tiny, bgcolor = color.new(color_void, 50))
    current_row := current_row + 1
    // Coherence Engine Section
    table.merge_cells(institutionalMatrix, 0, current_row, 4, current_row)
    table.cell(institutionalMatrix, 0, current_row, '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ', text_halign = text.align_center, text_color = color_primary_2, text_size = size.tiny)
    current_row := current_row + 1
    table.merge_cells(institutionalMatrix, 0, current_row, 4, current_row)
    table.cell(institutionalMatrix, 0, current_row, 'üåå COHERENCE ENGINE', text_halign = text.align_center, text_color = color_primary_2, text_size = size.small)
    current_row := current_row + 1
    table.cell(institutionalMatrix, 0, current_row, 'State', text_color = text_dim)
    table.merge_cells(institutionalMatrix, 1, current_row, 4, current_row)
    coherence_state = market_coherence > i_coherenceThreshold ? '‚óâ PHASE LOCK' : market_coherence > i_coherenceThreshold * 0.75 ? '‚óé ORGANIZING' : '‚óã CHAOTIC'
    coherence_color = market_coherence > i_coherenceThreshold ? color_energy_1 : market_coherence > i_coherenceThreshold * 0.75 ? color_primary_2 : color_secondary_2
    table.cell(institutionalMatrix, 1, current_row, coherence_state, text_halign = text.align_right, text_color = coherence_color)
    current_row := current_row + 1
    table.cell(institutionalMatrix, 0, current_row, 'Power', text_color = text_dim)
    table.merge_cells(institutionalMatrix, 1, current_row, 4, current_row)
    power_text = str.tostring(market_coherence, '#.1') + '% ' + (coherence_momentum > 0 ? '‚Üó' : '‚Üò')
    table.cell(institutionalMatrix, 1, current_row, power_text, text_halign = text.align_right, text_color = text_bright)
    current_row := current_row + 1
    // Liquidity Matrix Section
    table.merge_cells(institutionalMatrix, 0, current_row, 4, current_row)
    table.cell(institutionalMatrix, 0, current_row, '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ', text_halign = text.align_center, text_color = color_secondary_1, text_size = size.tiny)
    current_row := current_row + 1
    table.merge_cells(institutionalMatrix, 0, current_row, 4, current_row)
    table.cell(institutionalMatrix, 0, current_row, 'üíé LIQUIDITY MATRIX', text_halign = text.align_center, text_color = color_secondary_1, text_size = size.small)
    current_row := current_row + 1
    table.cell(institutionalMatrix, 0, current_row, 'Nodes', text_color = text_dim)
    table.merge_cells(institutionalMatrix, 1, current_row, 4, current_row)
    nodes_text = str.tostring(array.size(institutional_nodes)) + ' Active'
    table.cell(institutionalMatrix, 1, current_row, nodes_text, text_halign = text.align_right, text_color = text_bright)
    current_row := current_row + 1
    table.cell(institutionalMatrix, 0, current_row, 'Node Target', text_color = text_dim)
    table.merge_cells(institutionalMatrix, 1, current_row, 4, current_row)
    target_text = ''
    target_color = text_dim
    if not na(current_target)
        target_price_str = str.tostring(current_target.price, format.mintick)
        target_distance = math.abs(current_target.price - close)
        target_direction = current_target.price > close ? '‚Üë' : '‚Üì'
        distance_pips = target_distance / syminfo.mintick
        target_text := target_price_str + ' ' + target_direction + ' [' + str.tostring(distance_pips, '#') + ']'
        target_color := text_bright
        target_color
    else
        node_count = array.size(institutional_nodes)
        target_text := 'Scanning... [' + str.tostring(node_count) + ' nodes]'
        target_color := text_dim
        target_color
    table.cell(institutionalMatrix, 1, current_row, target_text, text_halign = text.align_right, text_color = target_color)
    current_row := current_row + 1
    // Cycle Matrix Section
    table.merge_cells(institutionalMatrix, 0, current_row, 4, current_row)
    table.cell(institutionalMatrix, 0, current_row, '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ', text_halign = text.align_center, text_color = color_accent_1, text_size = size.tiny)
    current_row := current_row + 1
    table.merge_cells(institutionalMatrix, 0, current_row, 4, current_row)
    table.cell(institutionalMatrix, 0, current_row, 'üåä CYCLE MATRIX', text_halign = text.align_center, text_color = color_accent_1, text_size = size.small)
    current_row := current_row + 1
    table.cell(institutionalMatrix, 0, current_row, 'Cycle', text_color = text_dim)
    table.merge_cells(institutionalMatrix, 1, current_row, 4, current_row)
    cycle_text = dominant_cycle_name + ' [' + str.tostring(dominant_cycle_period, '#') + ']'
    table.cell(institutionalMatrix, 1, current_row, cycle_text, text_halign = text.align_right, text_color = text_bright)
    current_row := current_row + 1
    table.cell(institutionalMatrix, 0, current_row, 'Sync', text_color = text_dim)
    table.merge_cells(institutionalMatrix, 1, current_row, 4, current_row)
    sync_text = cycles_aligned_bullish ? '‚ñ≤ BULLISH' : cycles_aligned_bearish ? '‚ñº BEARISH' : '‚óÜ DIVERGENT'
    sync_color = cycles_aligned_bullish ? color_energy_1 : cycles_aligned_bearish ? color_accent_2 : text_dim
    table.cell(institutionalMatrix, 1, current_row, sync_text, text_halign = text.align_right, text_color = sync_color)
    current_row := current_row + 1
    // Footer Section
    table.merge_cells(institutionalMatrix, 0, current_row, 4, current_row)
    table.cell(institutionalMatrix, 0, current_row, '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ', text_halign = text.align_center, text_color = color_energy_1, text_size = size.tiny)
    current_row := current_row + 1
    table.merge_cells(institutionalMatrix, 0, current_row, 4, current_row)
    string status_text = ''
    color status_bgcolor = na
    color footer_text_color = na
    if tier1_long or tier1_short
        status_text := tier1_long ? '‚óâ TIER 1 BUY ‚óâ' : '‚óâ TIER 1 SELL ‚óâ'
        status_bgcolor := tier1_long ? color_energy_1 : color_accent_2
        footer_text_color := text_bright
        footer_text_color
    else if tier2_long or tier2_short
        status_text := tier2_long ? '‚óé TIER 2 BUY ‚óé' : '‚óé TIER 2 SELL ‚óé'
        status_bgcolor := tier2_long ? color_energy_2 : color_accent_3
        footer_text_color := text_bright
        footer_text_color
    else if tier3_long or tier3_short
        status_text := tier3_long ? '‚óã TIER 3 BUY ‚óã' : '‚óã TIER 3 SELL ‚óã'
        status_bgcolor := tier3_long ? color_energy_3 : color_secondary_2
        footer_text_color := text_bright
        footer_text_color
    else // Default footer style as requested
        status_text := '‚óà‚ö° Dskyz (DAFE) Trading Systems ‚óà'
        status_bgcolor := color.new(#2A2E39, 0) // Dark Grey Background
        footer_text_color := text_glow // Light whitish-blue text       
        footer_text_color
    table.cell(institutionalMatrix, 0, current_row, status_text, text_halign = text.align_center, text_color = footer_text_color, text_size = size.small, bgcolor = status_bgcolor)
    //==============================================================================
    //                        INSTITUTIONAL ALERTS
    //==============================================================================
alertcondition(tier1_long, title = 'AETHERIUM T1 BUY', message = '‚óâ AETHERIUM V3.0: TIER 1 QUANTUM BUY SIGNAL ‚óâ')
alertcondition(tier1_short, title = 'AETHERIUM T1 SELL', message = '‚óâ AETHERIUM V3.0: TIER 1 QUANTUM SELL SIGNAL ‚óâ')
alertcondition(tier2_long, title = 'AETHERIUM T2 BUY', message = '‚óé AETHERIUM V3.0: TIER 2 INSTITUTIONAL BUY ‚óé')
alertcondition(tier2_short, title = 'AETHERIUM T2 SELL', message = '‚óé AETHERIUM V3.0: TIER 2 INSTITUTIONAL SELL ‚óé')
alertcondition(coherence_activation, title = 'COHERENCE ACTIVATION', message = 'üåå AETHERIUM V3.0: QUANTUM COHERENCE ACTIVATED üåå')
// Safe alert conditions for advanced targets
var bool target_predicted_alert = false
var bool target_reached_alert = false
var bool target_standby_alert = false
// Advanced Target Alerts
alertcondition(target_predicted_alert, 'New Target Predicted', 'üéØ AETHERIUM: New High-Confidence Target Predicted')
alertcondition(target_reached_alert, 'Target Reached', '‚úÖ AETHERIUM: Target Successfully Reached - Entering Standby Mode')
alertcondition(target_standby_alert, 'Standby Mode', '‚è∏Ô∏è AETHERIUM: Target System in Standby - Preparing Next Prediction')















// This work is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License (CC BY-NC-SA 4.0) https://creativecommons.org/licenses/by-nc-sa/4.0/
// ¬© Trendoscope Pty Ltd, Trendoscope¬Æ
//                                       ‚ñë‚ñí             
//                                  ‚ñí‚ñí‚ñí   ‚ñí‚ñí      
//                              ‚ñí‚ñí‚ñí‚ñí‚ñí     ‚ñí‚ñí      
//                      ‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñë     ‚ñí     ‚ñí‚ñí          
//                  ‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí           ‚ñí     ‚ñí‚ñí          
//             ‚ñì‚ñí‚ñí‚ñí       ‚ñí        ‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí  
//   ‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí ‚ñí        ‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí         
//   ‚ñí  ‚ñí       ‚ñë‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñë        
//   ‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñë‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí         
//   ‚ñì‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí ‚ñí‚ñí                       
//    ‚ñí‚ñí‚ñí‚ñí‚ñí         ‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí                            
//                 ‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí                           
//                ‚ñí‚ñí‚ñí‚ñí‚ñí ‚ñí‚ñí‚ñí‚ñí‚ñí                          
//               ‚ñë‚ñí‚ñí‚ñí‚ñí   ‚ñí‚ñí‚ñí‚ñí‚ñì      ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó
//              ‚ñì‚ñí‚ñí‚ñí‚ñí     ‚ñí‚ñí‚ñí‚ñí      ‚ïö‚ïê‚ïê‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù
//              ‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí        ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïî‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó 
//             ‚ñí‚ñí‚ñí‚ñí‚ñí       ‚ñí‚ñí‚ñí‚ñí‚ñí       ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïù ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  
//            ‚ñí‚ñí‚ñí‚ñí‚ñí         ‚ñí‚ñí‚ñí‚ñí‚ñí      ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó
//             ‚ñí‚ñí             ‚ñí                        
////@version=6
import Trendoscope/Drawing/2 as dr
import Trendoscope/Zigzag/10 as zg
import Trendoscope/utils/2 as ut
import Trendoscope/Waves/3 as w

//indicator('Motive Wave Scanner [Trendoscope¬Æ]', 'MW[Trendoscope¬Æ]', overlay = true, max_lines_count = 500, max_labels_count = 500, max_bars_back = 1000)
theme = input.enum(ut.Theme.DARK, title = 'Theme', group = 'Generic Settings', tooltip = 'Chart theme settings. Line and label colors are generted based on the theme settings. If dark theme is selected, ' + 'lighter colors are used and if light theme is selected, darker colors are used.', display = display.none)

zigzagLength = input.int(5, step = 5, minval = 3, title = 'Length', group = 'Zigzag', tooltip = 'Zigzag length for level 0 zigzag', display = display.none)
depth = input.int(200, 'Depth', step = 25, maxval = 500, group = 'Zigzag', tooltip = 'Max number of zigzag swings to consider for recursive calculation', display = display.none)

levelType = input.string('Minimum', 'Level', ['Minimum', 'Absolute'], group = 'Waves', inline = 'l', display = display.none)
level = input.int(1, '', group = 'Waves', minval = 1, inline = 'l', tooltip = 'Zigzag Level to consider for scanning waves', display = display.none)
limitSubwaves = input.bool(true, 'Draw only first subwave', group = 'Waves', tooltip = 'If there are multiple subwave combinations, draw only the first so that chart will look cleaner', display = display.none)
repaint = input.bool(true, 'Rapaint', group = 'Waves', inline = 'r', display = display.none, tooltip = 'If selected, waves are identified immediately, but the formations can repaint. If repaint is not selected,  then the waves are only presented after the confirmation. This means, there may be delay in printing the formation. Please note that, due to some internal pine issues, if repaint is selected, the indicator may throw some runtime error when running through the alerts')

useRealTimeBars = true

allowedTypes = array.from(w.WaveType.ContractingDiagonal, w.WaveType.ExpandingDiagonal, w.WaveType.ImpulseWave)
offset = useRealTimeBars ? 0 : 1

indicators = matrix.new<float>()
indicatorNames = array.new<string>()

var themeColors = theme.getColors()
var zg.Zigzag zigzag = zg.Zigzag.new(zigzagLength, depth, offset)
zigzag.calculate(array.from(high, low), indicators, indicatorNames)

var array<w.Wave> motiveWaves = array.new<w.Wave>()

if zigzag.flags.newPivot and (repaint or not zigzag.flags.updateLastPivot)
    mlzigzag = zigzag
    rowNum = 0
    while mlzigzag.zigzagPivots.size() >= (repaint ? 3 : 4)
        if levelType == 'Minimum' ? mlzigzag.level >= level : mlzigzag.level == level
            pivot = repaint ? mlzigzag.zigzagPivots.first() : mlzigzag.zigzagPivots.get(1)
            lastPivot = repaint ? mlzigzag.zigzagPivots.get(1) : mlzigzag.zigzagPivots.get(2)
            llastPivot = repaint ? mlzigzag.zigzagPivots.get(2) : mlzigzag.zigzagPivots.get(3)

            motiveSubwaveIndices = lastPivot.scanMotiveWave(llastPivot, motiveWaves, allowedTypes)
            if motiveSubwaveIndices.size() > 0
                alert('New Motive wave detected')
                if barstate.islast and barstate.isrealtime
                    log.info('New ImpuMotivelse wave detected')
                labelColor = themeColors.shift()
                themeColors.push(labelColor)

                motiveWave = lastPivot.createWave(labelColor, motiveWaves).createSubWaves(motiveSubwaveIndices).draw(limitSubwaves)
                motiveWave
        mlzigzag := mlzigzag.nextlevel()
        rowNum := rowNum + 1
        rowNum












// //@version=6
// indicator("üî¥ TIM NEW Advanced Trend Momentum [Alpha Extract]", shorttitle="ATM Pro", overlay=false)

// // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// // INPUT PARAMETERS
// // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê


// Trend Analysis Settings
trendGroup_alpha_extract = "‚ïê‚ïê‚ïê TREND ANALYSIS ‚ïê‚ïê‚ïê"
emaFastLen_alpha_extract = input.int(defval=12, display=display.none, title="Fast EMA Length", minval=1, group=trendGroup_alpha_extract)
emaSlowLen_alpha_extract = input.int(defval=26, display=display.none, title="Slow EMA Length", minval=1, group=trendGroup_alpha_extract)
trendStrength_alpha_extract = input.int(defval=14, display=display.none, title="Trend Strength Period", minval=1, group=trendGroup_alpha_extract)

// Support & Resistance Settings
srGroup_alpha_extract = "‚ïê‚ïê‚ïê SUPPORT & RESISTANCE ‚ïê‚ïê‚ïê"
pivotLength_alpha_extract = input.int(defval=10, display=display.none, title="Pivot Length", minval=2, group=srGroup_alpha_extract)
maxLevels_alpha_extract = input.int(defval=3, display=display.none, title="Max S/R Levels", minval=1, maxval=5, group=srGroup_alpha_extract)
showSRLevels_alpha_extract = input.bool(defval=true, display=display.none, title="Show S/R Levels", group=srGroup_alpha_extract)

// Momentum Settings
momentumGroup_alpha_extract = "‚ïê‚ïê‚ïê MOMENTUM ‚ïê‚ïê‚ïê"
rsiLength_alpha_extract = input.int(defval=14, display=display.none, title="RSI Length", minval=1, group=momentumGroup_alpha_extract)
oversoldLevel_alpha_extract = input.int(defval=30, display=display.none, title="Oversold Level", minval=1, maxval=49, group=momentumGroup_alpha_extract)
overboughtLevel_alpha_extract = input.int(defval=70, display=display.none, title="Overbought Level", minval=51, maxval=99, group=momentumGroup_alpha_extract)

// Visual Settings
visualGroup_alpha_extract = "‚ïê‚ïê‚ïê VISUAL SETTINGS ‚ïê‚ïê‚ïê"
show_colored_candles_alpha_extract = input.bool(defval=true, display=display.none, title="Show Colored Candles", group=visualGroup_alpha_extract)
bullColor_alpha_extract = input.color(defval=#00D4AA, display=display.none, title="Bullish Color", group=visualGroup_alpha_extract)
bearColor_alpha_extract = input.color(defval=#FF6B6B, display=display.none, title="Bearish Color", group=visualGroup_alpha_extract)
neutralColor_alpha_extract = input.color(defval=#95A5A6, display=display.none, title="Neutral Color", group=visualGroup_alpha_extract)
transparency_alpha_extract = input.int(defval=80, display=display.none, title="Fill Transparency", minval=0, maxval=100, group=visualGroup_alpha_extract)




// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// CALCULATIONS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// EMAs for trend analysis
emaFast_alpha_extract = ta.ema(close, emaFastLen_alpha_extract)
emaSlow_alpha_extract = ta.ema(close, emaSlowLen_alpha_extract)

// Trend direction and strength
trendDirection_alpha_extract = emaFast_alpha_extract > emaSlow_alpha_extract ? 1 : -1
trendStrengthValue_alpha_extract = math.abs(emaFast_alpha_extract - emaSlow_alpha_extract) / ta.atr(trendStrength_alpha_extract) * 100

// RSI for momentum
rsi_alpha_extract = ta.rsi(close, rsiLength_alpha_extract)
rsiOverbought_alpha_extract = rsi_alpha_extract > overboughtLevel_alpha_extract
rsiOversold_alpha_extract = rsi_alpha_extract < oversoldLevel_alpha_extract

// Advanced momentum calculation
momentumValue_alpha_extract = ta.change(close, 5) / ta.atr(10) * 100

// Support and Resistance levels using pivot points
pivotHigh_alpha_extract = ta.pivothigh(high, pivotLength_alpha_extract, pivotLength_alpha_extract)
pivotLow_alpha_extract = ta.pivotlow(low, pivotLength_alpha_extract, pivotLength_alpha_extract)

// Store recent pivot levels
var float[] resistanceLevels_alpha_extract = array.new<float>()
var float[] supportLevels_alpha_extract = array.new<float>()

if not na(pivotHigh_alpha_extract)
	array.unshift(resistanceLevels_alpha_extract, pivotHigh_alpha_extract)
	if array.size(resistanceLevels_alpha_extract) > maxLevels_alpha_extract
		array.pop(resistanceLevels_alpha_extract)

if not na(pivotLow_alpha_extract)
	array.unshift(supportLevels_alpha_extract, pivotLow_alpha_extract)
	if array.size(supportLevels_alpha_extract) > maxLevels_alpha_extract
		array.pop(supportLevels_alpha_extract)




// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// RSI VISUAL ENHANCEMENTS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// Plot RSI with enhanced visuals
plotRSI_alpha_extract = plot(rsi_alpha_extract, title='Relative Strength Index', color=#95A5A6, linewidth=1)
plotRSI2_alpha_extract = plot(rsi_alpha_extract * 0.97, title='Relative Strength Index', color=#95A5A6, linewidth=1, display=display.pane)
fill(plotRSI_alpha_extract, plotRSI2_alpha_extract, color=color.new(#95A5A6, 80))

// Overbought and Oversold levels with better styling
overboughtline_alpha_extract = hline(overboughtLevel_alpha_extract, title='RSI Overbought', color=color.new(bearColor_alpha_extract, 60), linewidth=1, linestyle=hline.style_dashed)
overboughtline2_alpha_extract = hline(overboughtLevel_alpha_extract * 1.02, title='RSI Overbought', color=color.new(bearColor_alpha_extract, 60), linewidth=1, linestyle=hline.style_dashed)

overboughtline2p_alpha_extract = plot(overboughtLevel_alpha_extract * 1.02, title='RSI Overbought', color=color.new(bearColor_alpha_extract, 60), linewidth=1, display=display.none)

rsibc_alpha_extract = #ffffff00
if rsi_alpha_extract * 0.97 > overboughtLevel_alpha_extract * 1.02
	rsibc_alpha_extract := color.new(bearColor_alpha_extract, 80)
if rsi_alpha_extract * 0.97 < overboughtLevel_alpha_extract * 1.02
	rsibc_alpha_extract := #ffffff00

rsibc2_alpha_extract = #ffffff00
if rsi_alpha_extract > oversoldLevel_alpha_extract * 0.95
	rsibc2_alpha_extract := #ffffff00
if rsi_alpha_extract < oversoldLevel_alpha_extract * 0.95
	rsibc2_alpha_extract := color.new(bullColor_alpha_extract, 80)



// RSI Fills
fill(plotRSI2_alpha_extract, overboughtline2p_alpha_extract, color=rsibc_alpha_extract)
fill(overboughtline_alpha_extract, overboughtline2_alpha_extract, color=color.new(bearColor_alpha_extract, 80))

oversoldline_alpha_extract = hline(oversoldLevel_alpha_extract, title='RSI Oversold', color=color.new(bullColor_alpha_extract, 60), linewidth=1, linestyle=hline.style_dashed)
oversoldline2_alpha_extract = hline(oversoldLevel_alpha_extract * 0.95, title='RSI Oversold', color=color.new(bullColor_alpha_extract, 60), linewidth=1, linestyle=hline.style_dashed)
oversoldline2p_alpha_extract = plot(oversoldLevel_alpha_extract * 0.95, title='RSI Oversold', color=color.new(bullColor_alpha_extract, 60), linewidth=1, display=display.none)

fill(plotRSI_alpha_extract, oversoldline2p_alpha_extract, color=rsibc2_alpha_extract)
fill(oversoldline_alpha_extract, oversoldline2_alpha_extract, color=color.new(bullColor_alpha_extract, 80))

// Midline for reference
hline(50, title='RSI Midline', color=color.new(neutralColor_alpha_extract, 50), linewidth=1, linestyle=hline.style_dotted)
m1_alpha_extract = hline(48, title='RSI Midline', color=color.new(neutralColor_alpha_extract, 70), linewidth=1, linestyle=hline.style_dotted)
m2_alpha_extract = hline(52, title='RSI Midline', color=color.new(neutralColor_alpha_extract, 70), linewidth=1, linestyle=hline.style_dotted)
fill(m1_alpha_extract, m2_alpha_extract, color=color.new(neutralColor_alpha_extract, 80))

// Plot EMAs with dynamic colors
emaFastColor_alpha_extract = trendDirection_alpha_extract > 0 ? bullColor_alpha_extract : bearColor_alpha_extract
emaSlowColor_alpha_extract = trendDirection_alpha_extract > 0 ? color.new(bullColor_alpha_extract, 40) : color.new(bearColor_alpha_extract, 40)

plotEmaFast_alpha_extract = plot(emaFast_alpha_extract, title="Fast EMA", color=emaFastColor_alpha_extract, linewidth=2, force_overlay=true)
plotEmaSlow_alpha_extract = plot(emaSlow_alpha_extract, title="Slow EMA", color=emaSlowColor_alpha_extract, linewidth=2, force_overlay=true)

// Trend fill between EMAs
fillColor_alpha_extract = trendDirection_alpha_extract > 0 ? color.new(bullColor_alpha_extract, transparency_alpha_extract) : color.new(bearColor_alpha_extract, transparency_alpha_extract)


// Trend fill between EMAs
fill(plotEmaFast_alpha_extract, plotEmaSlow_alpha_extract, color=fillColor_alpha_extract, title="Trend Fill")

// Support and Resistance levels
if showSRLevels_alpha_extract and barstate.islast
	if array.size(resistanceLevels_alpha_extract) > 0
		for i = 0 to math.min(array.size(resistanceLevels_alpha_extract) - 1, maxLevels_alpha_extract - 1)
			if i < array.size(resistanceLevels_alpha_extract)
				level_alpha_extract = array.get(resistanceLevels_alpha_extract, i)
				line.new(bar_index - 100, level_alpha_extract, bar_index, level_alpha_extract, color=color.new(bearColor_alpha_extract, 30), style=line.style_dashed, width=1, extend=extend.right, force_overlay=true)
	
	if array.size(supportLevels_alpha_extract) > 0
		for i = 0 to math.min(array.size(supportLevels_alpha_extract) - 1, maxLevels_alpha_extract - 1)
			if i < array.size(supportLevels_alpha_extract)
				level_alpha_extract = array.get(supportLevels_alpha_extract, i)
				line.new(bar_index - 100, level_alpha_extract, bar_index, level_alpha_extract, color=color.new(bullColor_alpha_extract, 30), style=line.style_dashed, width=1, extend=extend.right, force_overlay=true)


// Momentum-based bar coloring
barColor_alpha_extract = if show_colored_candles_alpha_extract
	if rsiOverbought_alpha_extract and momentumValue_alpha_extract < 0
		bearColor_alpha_extract
	else if rsiOversold_alpha_extract and momentumValue_alpha_extract > 0
		bullColor_alpha_extract
	else if trendDirection_alpha_extract > 0 and momentumValue_alpha_extract > 0
		bullColor_alpha_extract
	else if trendDirection_alpha_extract < 0 and momentumValue_alpha_extract < 0
		bearColor_alpha_extract
	else
		neutralColor_alpha_extract
else
	na

plotcandle(open, high, low, close, title="Trend Strength Candles", color=barColor_alpha_extract, wickcolor=barColor_alpha_extract, bordercolor=barColor_alpha_extract, force_overlay=true, display=show_colored_candles_alpha_extract ? display.pane : display.none)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// SIGNALS AND ALERTS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// Trend change signals
trendChange_alpha_extract = ta.change(trendDirection_alpha_extract)
bullishSignal_alpha_extract = trendChange_alpha_extract > 0 and trendStrengthValue_alpha_extract > 1
bearishSignal_alpha_extract = trendChange_alpha_extract < 0 and trendStrengthValue_alpha_extract > 1

// Momentum divergence signals
bullishDivergence_alpha_extract = rsiOversold_alpha_extract and momentumValue_alpha_extract > momentumValue_alpha_extract[1] and close < close[1]
bearishDivergence_alpha_extract = rsiOverbought_alpha_extract and momentumValue_alpha_extract < momentumValue_alpha_extract[1] and close > close[1]

// Plot divergence signals
plotshape(bullishDivergence_alpha_extract, title="Bullish Divergence", style=shape.diamond, location=location.belowbar, color=color.new(bullColor_alpha_extract, 30), size=size.small, force_overlay=true)
plotshape(bearishDivergence_alpha_extract, title="Bearish Divergence", style=shape.diamond, location=location.abovebar, color=color.new(bearColor_alpha_extract, 30), size=size.small, force_overlay=true)
